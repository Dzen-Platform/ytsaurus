# Stubs for pyspark.sql.types (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional

class DataType:
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    @classmethod
    def typeName(cls): ...
    def simpleString(self): ...
    def jsonValue(self): ...
    def json(self): ...
    def needConversion(self): ...
    def toInternal(self, obj): ...
    def fromInternal(self, obj): ...

class DataTypeSingleton(type):
    def __call__(cls): ...

class NullType(DataType):
    __metaclass__ = ...  # type: Any

class AtomicType(DataType): ...
class NumericType(AtomicType): ...

class IntegralType(NumericType):
    __metaclass__ = ...  # type: Any

class FractionalType(NumericType): ...

class StringType(AtomicType):
    __metaclass__ = ...  # type: Any

class BinaryType(AtomicType):
    __metaclass__ = ...  # type: Any

class BooleanType(AtomicType):
    __metaclass__ = ...  # type: Any

class DateType(AtomicType):
    __metaclass__ = ...  # type: Any
    EPOCH_ORDINAL = ...  # type: Any
    def needConversion(self): ...
    def toInternal(self, d): ...
    def fromInternal(self, v): ...

class TimestampType(AtomicType):
    __metaclass__ = ...  # type: Any
    def needConversion(self): ...
    def toInternal(self, dt): ...
    def fromInternal(self, ts): ...

class DecimalType(FractionalType):
    precision = ...  # type: Any
    scale = ...  # type: Any
    hasPrecisionInfo = ...  # type: bool
    def __init__(self, precision: int = ..., scale: int = ...) -> None: ...
    def simpleString(self): ...
    def jsonValue(self): ...

class DoubleType(FractionalType):
    __metaclass__ = ...  # type: Any

class FloatType(FractionalType):
    __metaclass__ = ...  # type: Any

class ByteType(IntegralType):
    def simpleString(self): ...

class IntegerType(IntegralType):
    def simpleString(self): ...

class LongType(IntegralType):
    def simpleString(self): ...

class ShortType(IntegralType):
    def simpleString(self): ...

class ArrayType(DataType):
    elementType = ...  # type: Any
    containsNull = ...  # type: Any
    def __init__(self, elementType, containsNull: bool = ...) -> None: ...
    def simpleString(self): ...
    def jsonValue(self): ...
    @classmethod
    def fromJson(cls, json): ...
    def needConversion(self): ...
    def toInternal(self, obj): ...
    def fromInternal(self, obj): ...

class MapType(DataType):
    keyType = ...  # type: Any
    valueType = ...  # type: Any
    valueContainsNull = ...  # type: Any
    def __init__(self, keyType, valueType, valueContainsNull: bool = ...) -> None: ...
    def simpleString(self): ...
    def jsonValue(self): ...
    @classmethod
    def fromJson(cls, json): ...
    def needConversion(self): ...
    def toInternal(self, obj): ...
    def fromInternal(self, obj): ...

class StructField(DataType):
    name = ...  # type: Any
    dataType = ...  # type: Any
    nullable = ...  # type: Any
    metadata = ...  # type: Any
    def __init__(self, name, dataType, nullable: bool = ..., metadata: Optional[Any] = ...) -> None: ...
    def simpleString(self): ...
    def jsonValue(self): ...
    @classmethod
    def fromJson(cls, json): ...
    def needConversion(self): ...
    def toInternal(self, obj): ...
    def fromInternal(self, obj): ...

class StructType(DataType):
    fields = ...  # type: Any
    names = ...  # type: Any
    def __init__(self, fields: Optional[Any] = ...) -> None: ...
    def add(self, field, data_type: Optional[Any] = ..., nullable: bool = ..., metadata: Optional[Any] = ...): ...
    def __iter__(self): ...
    def __len__(self): ...
    def __getitem__(self, key): ...
    def simpleString(self): ...
    def jsonValue(self): ...
    @classmethod
    def fromJson(cls, json): ...
    def needConversion(self): ...
    def toInternal(self, obj): ...
    def fromInternal(self, obj): ...

class UserDefinedType(DataType):
    @classmethod
    def typeName(cls): ...
    @classmethod
    def sqlType(cls): ...
    @classmethod
    def module(cls): ...
    @classmethod
    def scalaUDT(cls): ...
    def needConversion(self): ...
    def toInternal(self, obj): ...
    def fromInternal(self, obj): ...
    def serialize(self, obj): ...
    def deserialize(self, datum): ...
    def simpleString(self): ...
    def json(self): ...
    def jsonValue(self): ...
    @classmethod
    def fromJson(cls, json): ...
    def __eq__(self, other): ...

class Row(tuple):
    def __new__(self, *args, **kwargs): ...
    def asDict(self, recursive: bool = ...): ...
    def __contains__(self, item): ...
    def __call__(self, *args): ...
    def __getitem__(self, item): ...
    def __getattr__(self, item): ...
    def __setattr__(self, key, value): ...
    def __reduce__(self): ...

class DateConverter:
    def can_convert(self, obj): ...
    def convert(self, obj, gateway_client): ...

class DatetimeConverter:
    def can_convert(self, obj): ...
    def convert(self, obj, gateway_client): ...

