# Stubs for pyspark.mllib.clustering (Python 3.5)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from typing import Any, Optional
from pyspark.mllib.common import JavaModelWrapper
from pyspark.mllib.util import Saveable, Loader, JavaLoader, JavaSaveable

class BisectingKMeansModel(JavaModelWrapper):
    centers = ...  # type: Any
    def __init__(self, java_model) -> None: ...
    @property
    def clusterCenters(self): ...
    @property
    def k(self): ...
    def predict(self, x): ...
    def computeCost(self, x): ...

class BisectingKMeans:
    @classmethod
    def train(self, rdd, k: int = ..., maxIterations: int = ..., minDivisibleClusterSize: float = ..., seed: int = ...): ...

class KMeansModel(Saveable, Loader):
    centers = ...  # type: Any
    def __init__(self, centers) -> None: ...
    @property
    def clusterCenters(self): ...
    @property
    def k(self): ...
    def predict(self, x): ...
    def computeCost(self, rdd): ...
    def save(self, sc, path): ...
    @classmethod
    def load(cls, sc, path): ...

class KMeans:
    @classmethod
    def train(cls, rdd, k, maxIterations: int = ..., runs: int = ..., initializationMode: str = ..., seed: Optional[Any] = ..., initializationSteps: int = ..., epsilon: float = ..., initialModel: Optional[Any] = ...): ...

class GaussianMixtureModel(JavaModelWrapper, JavaSaveable, JavaLoader):
    @property
    def weights(self): ...
    @property
    def gaussians(self): ...
    @property
    def k(self): ...
    def predict(self, x): ...
    def predictSoft(self, x): ...
    @classmethod
    def load(cls, sc, path): ...

class GaussianMixture:
    @classmethod
    def train(cls, rdd, k, convergenceTol: float = ..., maxIterations: int = ..., seed: Optional[Any] = ..., initialModel: Optional[Any] = ...): ...

class PowerIterationClusteringModel(JavaModelWrapper, JavaSaveable, JavaLoader):
    @property
    def k(self): ...
    def assignments(self): ...
    @classmethod
    def load(cls, sc, path): ...

class PowerIterationClustering:
    @classmethod
    def train(cls, rdd, k, maxIterations: int = ..., initMode: str = ...): ...
    class Assignment: ...

class StreamingKMeansModel(KMeansModel):
    def __init__(self, clusterCenters, clusterWeights) -> None: ...
    @property
    def clusterWeights(self): ...
    centers = ...  # type: Any
    def update(self, data, decayFactor, timeUnit): ...

class StreamingKMeans:
    def __init__(self, k: int = ..., decayFactor: float = ..., timeUnit: str = ...) -> None: ...
    def latestModel(self): ...
    def setK(self, k): ...
    def setDecayFactor(self, decayFactor): ...
    def setHalfLife(self, halfLife, timeUnit): ...
    def setInitialCenters(self, centers, weights): ...
    def setRandomCenters(self, dim, weight, seed): ...
    def trainOn(self, dstream): ...
    def predictOn(self, dstream): ...
    def predictOnValues(self, dstream): ...

class LDAModel(JavaModelWrapper, JavaSaveable, Loader):
    def topicsMatrix(self): ...
    def vocabSize(self): ...
    def describeTopics(self, maxTermsPerTopic: Optional[Any] = ...): ...
    @classmethod
    def load(cls, sc, path): ...

class LDA:
    @classmethod
    def train(cls, rdd, k: int = ..., maxIterations: int = ..., docConcentration: Any = ..., topicConcentration: Any = ..., seed: Optional[Any] = ..., checkpointInterval: int = ..., optimizer: str = ...): ...
