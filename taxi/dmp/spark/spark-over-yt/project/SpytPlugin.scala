package spyt

import sbt.Keys._
import sbt.PluginTrigger.NoTrigger
import sbt._
import sbtrelease.ReleasePlugin.autoImport._
import sbtrelease.ReleaseStateTransformations._
import sbtrelease._
import spyt.SparkPackagePlugin.autoImport._
import spyt.SpytRelease._

import java.io.File

object SpytPlugin extends AutoPlugin {
  override def trigger = NoTrigger

  override def requires = super.requires

  object autoImport {
    val spytClusterVersion = settingKey[String]("Spyt cluster version")
    val spytClientVersion = settingKey[String]("Spyt client version")
    val spytClientPythonVersion = settingKey[String]("yandex-spyt version")
    val spytSparkPythonVersion = settingKey[String]("yandex-spark version")

    val spytPublishClusterSnapshot = taskKey[Unit]("Publish spyt cluster with snapshot version")
    val spytPublishClientSnapshot = taskKey[Unit]("Publish spyt client with snapshot version")
    val spytPublishAllSnapshot = taskKey[Unit]("Publish spyt client & cluster with snapshot version")

    val spytPublishCluster = taskKey[Unit]("Publish spyt cluster")
    val spytPublishClient = taskKey[Unit]("Publish spyt client")
    val spytPublishAll = taskKey[Unit]("Publish spyt client & cluster")

    val spytIncreasePythonBetaVersion = taskKey[Unit]("Increase beta-version of yandex-spyt")
    val spytIncreaseSparkPythonBetaVersion = taskKey[Unit]("Increase beta-version of yandex-spark")
    val spytUpdatePythonVersion = taskKey[Unit]("Update versions in data-source/version.py")

    val spytClusterVersionFile = settingKey[File]("Spyt cluster version")
    val spytClientVersionFile = settingKey[File]("Spyt client version")
    val spytClientVersionPyFile = settingKey[File]("Spyt client version")
    val spytSparkVersionFile = settingKey[File]("yandex-spark version")
    val spytSparkVersionPyFile = settingKey[File]("yandex-spark version")

    val releaseClusterCommitMessage = taskKey[String]("")
    val releaseNextClusterCommitMessage = taskKey[String]("")
    val releaseClientCommitMessage = taskKey[String]("")
    val releaseNextClientCommitMessage = taskKey[String]("")
    val releaseAllCommitMessage = taskKey[String]("")
    val releaseNextAllCommitMessage = taskKey[String]("")

    val releaseComponent = settingKey[ReleaseComponent]("")

    val spytReleaseProcess = settingKey[Seq[ReleaseStep]]("")
  }

  sealed abstract class ReleaseComponent(val name: String)

  object ReleaseComponent {
    case object Cluster extends ReleaseComponent("cluster")

    case object Client extends ReleaseComponent("client")

    case object All extends ReleaseComponent("all")

    def fromString(name: String): Option[ReleaseComponent] = Seq(Cluster, Client, All).find(_.name == name)
  }

  import autoImport._

  def updatePythonVersion(spytVersion: String,
                          spytVersionFile: File,
                          sparkVersion: String,
                          sparkVersionFile: File): Unit = {
    val content =
      s"""# This file is autogenerated, don't edit it manually
         |
         |__version__ = "$spytVersion"
         |__spark_version__ = "$sparkVersion"
         |""".stripMargin
    IO.write(spytVersionFile, content)

    val sparkVersionContent = IO.readLines(sparkVersionFile)
      .map {
        case line if line.startsWith("__version__") =>
          s"""__version__ = "$sparkVersion""""
        case line => line
      }
      .mkString("\n")
    IO.write(sparkVersionFile, sparkVersionContent)
  }

  def increaseBetaVersion(oldVersion: String): String = {
    val (version, beta) = if (oldVersion.contains("b")) {
      val split = oldVersion.split("b").toSeq
      (split(0), split(1).toInt)
    } else {
      val Seq(sparkVersion, spytVersion) = oldVersion.split("\\+", 2).toList
      val newSpytVersion = Version(spytVersion).map(_.bump(Version.Bump.Bugfix).string)
        .getOrElse(versionFormatError(spytVersion))
      (s"$sparkVersion+$newSpytVersion", 0)
    }

    s"${version}b${beta + 1}"
  }

  override def projectSettings: Seq[Def.Setting[_]] = super.projectSettings ++ Seq(
    spytClusterVersionFile := baseDirectory.value / "cluster_version.sbt",
    spytClientVersionFile := baseDirectory.value / "client_version.sbt",
    spytSparkVersionFile := baseDirectory.value / "spark_version.sbt",
    // TODO
    spytClientVersionPyFile := baseDirectory.value / "data-source" / "src" / "main" / "python" / "spyt" / "version.py",
    spytSparkVersionPyFile := (ThisBuild / sparkVersionPyFile).value,
    spytIncreasePythonBetaVersion := {
      val oldVersion = spytClientPythonVersion.value
      val newVersion = increaseBetaVersion(oldVersion)
      writeVersion(Seq(
        spytClientVersion -> spytClientVersion.value,
        spytClientPythonVersion -> newVersion
      ), spytClientVersionFile.value)
      updatePythonVersion(
        newVersion,
        spytClientVersionPyFile.value,
        (ThisBuild / spytSparkPythonVersion).value,
        spytSparkVersionPyFile.value
      )
    },
    spytUpdatePythonVersion := {
      updatePythonVersion(
        (ThisBuild / spytClientPythonVersion).value,
        spytClientVersionPyFile.value,
        (ThisBuild / spytSparkPythonVersion).value,
        spytSparkVersionPyFile.value
      )
    },
    spytIncreaseSparkPythonBetaVersion := {
      val oldVersion = spytSparkPythonVersion.value
      val newVersion = increaseBetaVersion(oldVersion)
      streams.value.log.info(s"New spark python version: $newVersion")
      writeVersion(Seq(
        spytSparkPythonVersion -> newVersion
      ), spytSparkVersionFile.value)
      updatePythonVersion(
        (ThisBuild / spytClientPythonVersion).value,
        spytClientVersionPyFile.value,
        newVersion,
        spytSparkVersionPyFile.value
      )
    },
    spytPublishClusterSnapshot := spytPublishCluster.value,
    spytPublishClientSnapshot := Def.sequential(
      spytPublishClient,
      spytIncreasePythonBetaVersion
    ).value,
    spytPublishAllSnapshot := Def.taskDyn {
      val rebuildSpark = Option(System.getProperty("rebuildSpark")).exists(_.toBoolean)
      if (rebuildSpark) {
        Def.sequential(
          spytIncreaseSparkPythonBetaVersion,
          spytPublishAll,
          spytIncreasePythonBetaVersion
        )
      } else {
        Def.sequential(
          spytPublishCluster,
          spytPublishClient,
          spytIncreasePythonBetaVersion
        )
      }
    }.value,
    releaseClusterCommitMessage := s"Release cluster ${(ThisBuild / spytClusterVersion).value}",
    releaseNextClusterCommitMessage := s"Start cluster ${(ThisBuild / spytClusterVersion).value}",
    releaseClientCommitMessage := s"Release client ${(ThisBuild / spytClientVersion).value}",
    releaseNextClientCommitMessage := s"Start client ${(ThisBuild / spytClientVersion).value}",
    releaseAllCommitMessage := s"Release cluster ${(ThisBuild / spytClusterVersion).value}," +
      s" client ${(ThisBuild / spytClientVersion).value}",
    releaseNextAllCommitMessage := s"Start cluster ${(ThisBuild / spytClusterVersion).value}," +
      s" client ${(ThisBuild / spytClientVersion).value}",
    releaseComponent := {
      Option(System.getProperty("component")).flatMap(ReleaseComponent.fromString).getOrElse(ReleaseComponent.All)
    },
    spytReleaseProcess := {
      releaseComponent.value match {
        case ReleaseComponent.Cluster =>
          Seq[ReleaseStep](
            checkSnapshotDependencies,
            runClean,
            runTest,
            clusterReleaseVersions,
            setReleaseClusterVersion,
            setYtProxies,
            releaseStepTask(spytPublishCluster),
            maybeCommitReleaseClusterVersion,
            maybeSetNextClusterVersion,
            maybeCommitNextClusterVersion,
            maybePushChanges
          )
        case ReleaseComponent.Client =>
          Seq[ReleaseStep](
            checkSnapshotDependencies,
            runClean,
            runTest,
            clientReleaseVersions,
            setReleaseClientVersion,
            releaseStepTask(spytUpdatePythonVersion),
            setYtProxies,
            releaseStepTask(spytPublishClient),
            maybeCommitReleaseClientVersion,
            maybeSetNextClientVersion,
            releaseStepTask(spytUpdatePythonVersion),
            maybeCommitNextClientVersion,
            maybePushChanges
          )
        case ReleaseComponent.All =>
          Seq[ReleaseStep](
            checkSnapshotDependencies,
            runClean,
            runTest,
            allReleaseVersions,
            setReleaseClusterVersion,
            setReleaseClientVersion,
            setReleaseSparkVersion,
            releaseStepTask(spytUpdatePythonVersion),
            setYtProxies,
            setRebuildSpark,
            releaseStepTask(spytPublishAll),
            commitReleaseAllVersion,
            maybeSetNextClusterVersion,
            maybeSetNextClientVersion,
            releaseStepTask(spytUpdatePythonVersion),
            commitNextAllVersion,
            pushChanges
          )
      }
    }
  )
}
