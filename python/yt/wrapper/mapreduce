#!/usr/bin/env python

# Options that not supported:
# -lock
# -unlock
#
# -archive
# -unarchive
# -repair
#
# -profileformat
#
# -partialcommit
# -timelimit
# -spawnbackupjobs
# -maxjobfails
# -averagetimelimit
#
# -savestderrtail
# -savestdouttail
#
# -srcserver

from yt.wrapper.cli_helpers import write_silently, run_main, die
from yt.wrapper.table_commands import copy_table, move_table, _remove_locks, _get_format_from_tables
from yt.wrapper.cypress_commands import remove_with_empty_dirs
from yt.wrapper.table import check_prefix

from yt.wrapper.common import flatten, first_not_none, bool_to_string, get_value, get_version, MB, chunk_iter_stream
import yt.wrapper.config as config
import yt.yson as yson
import yt.packages.simplejson as json
import yt.wrapper as yt

import os
import sys
import types
from argparse import ArgumentParser, RawTextHelpFormatter, REMAINDER, Action
from operator import attrgetter
from itertools import imap, groupby

def unlist_destination_tables(tables):
    if tables is None:
        die("Destination table required")
    elif len(tables) == 1:
        return tables[0]
    else:
        die("Multiple destination tables are forbidden")

def calculate_if_function(obj):
    if hasattr(obj, '__call__'):
        return obj()
    else:
        return obj

def remove_prefix(table):
    if table.startswith(config.PREFIX):
        return table[len(config.PREFIX):]
    return table

def list_all_entities(type):
    if config.PREFIX is None:
        die("You should specify PREFIX for list command")
    check_prefix(config.PREFIX)
    tables = yt.search(config.PREFIX[:-1], type,
                       path_filter=lambda path: path.startswith(config.PREFIX))
    return sorted(map(remove_prefix, tables))

def add_eoln(str):
    return str + "\n"

class ForbidRepeatedArgumentsAction(Action):
    def __call__(self, parser, namespace, values, option_string=None):
        if namespace.__dict__[self.dest] is not None:
            parser.error("Repeated argument -" + self.dest)
        setattr(namespace, self.dest, values)

class AppendAction(Action):
    def __init__(self, option_strings, **kwargs):
        super(AppendAction, self).__init__(option_strings, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        value = getattr(namespace, self.dest)
        if value is None:
            value = []
        value.append((option_string, values))
        setattr(namespace, self.dest, value)

class MissingValue(object):
    pass

class MaybeMissingValueArgumentAction(Action):
    def __call__(self, parser, namespace, values, option_string=None):
        if values is None:
            values = MissingValue()
        setattr(namespace, self.dest, values)

def add_maybe_missing_value_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, nargs="?", action=MaybeMissingValueArgumentAction)
def add_store_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action=ForbidRepeatedArgumentsAction)
def add_bool_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action="store_true", default=False)
def add_multiple_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action="append")

def add_multiple_args_to_one_dest(parser, args, dest=None):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action=AppendAction, dest=dest)

def add_integer_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, type=int)

def add_help_message(parser, arg_name, message):
    arg_name = "-" + arg_name
    args_tuple = parser._get_option_tuples(arg_name)
    for arg in args_tuple:
        if arg[1] == arg_name:
            arg[0].help = message
            return
    assert "There is no such option"

def add_help_messages(parser, args):
    for arg, message in args:
        add_help_message(parser, arg, message)

class SortingHelpFormatter(RawTextHelpFormatter):
    def add_arguments(self, actions):
        actions = sorted(actions, key=attrgetter('option_strings'))
        super(SortingHelpFormatter, self).add_arguments(actions)

def get_smart_format(tables, smart_format_flag, has_subkey, lenval, ignore_unexisting_tables=False):
    if not (smart_format_flag or "YT_SMART_FORMAT" in os.environ):
        return None
    try:
        result_format = _get_format_from_tables(tables, ignore_unexisting_tables)
    except yt.YtError as e:
        die(str(e))
    if not result_format:
        return None
    # Dirty hacks :(
    if result_format.name() in ["yamr", "yamred_dsv"]:
        result_format.attributes["has_subkey"] = has_subkey
        result_format.attributes["lenval"] = lenval
    return result_format

def main():
    yt.set_yamr_mode()

    parser = ArgumentParser(
        formatter_class=SortingHelpFormatter,
        description="Shell utility to work with YT system.\n"
                    "This utility is back-compatible with mapreduce for Yamr.",
        epilog=
"""
Examples:
    Write data to the table with replication factor one and gzip codec:
            mapreduce-yt -createtable 'table' -codec gzip_normal -replicationfactor 1
            mapreduce-yt -write 'table' -append < data

    Read 10 records from the table:
            mapreduce-yt -read 'table[:#10]'

    Run operation on the range of the table:
            mapreduce-yt
                -subkey
                -map 'awk '"'"'{sum+=$1+$2} END {print "\\t\\t"sum}'"'"
                -src "ignat/temp{key,subkey}[("aaa"):("zzz")]"
                -dst "ignat/sum"

    Run map-reduce operation:
            mapreduce-yt
                -subkey
                -map 'grep "A"'
                -reduce 'awk '"'"'{a[$1]+=$3} END {for (i in a) {print i"\\t\\t"a[i]}}'"'"
                -src "ignat/temp"
                -dst "ignat/reduced"

    Use already uploaded files:
            mapreduce-yt -upload ignat/mapper.py < mapper.py
            mapreduce-yt -subkey -map "./mapper.py" -ytfile "ignat/mapper.py" -src "ignat/temp" -dst "ignat/mapped"

    Use you own attrbiutes:
            mapreduce-yt -set "log/@my_attr"  -value 10
            mapreduce-yt -get "log/@my_attr"
    It returns 10.
"""
    )

    action_maybe_stores = ["write"]
    action_stores = ["read", "writesorted", "map", "reduce", "reducews", "reducewsonly", "drop",
                     "erase", "aborttx", "committx", "renewtx", "set", "get", "upload", "download",
                     "createtable", "exists", "track", "ytlock"]
    action_flags = ["version", "copy", "move", "sort", "merge", "list", "listfiles", "starttx"]

    add_bool_args(parser, action_flags + ["subkey", "lenval", "append", "dynallocmode", "dsv", "pingtx",
                                          "smartformat", "force", "executable", "waitable", "failonemptysrctable", "nocreatetmptable"])

    add_maybe_missing_value_args(parser, action_maybe_stores)

    add_store_args(parser, action_stores + ["server", "lowerkey", "upperkey", "prefix", "codec",
                                            "format", "inputformat", "outputformat", "tx", "value",
                                            "replicationfactor", "memlimit", "timeout", "title", "fs", "rs",
                                            "mode", "tablereader", "tablewriter"])
    add_multiple_args(parser, ["src", "file", "mapfile", "reducefile", "ytfile", "opt", "ytspec", "sortby", "reduceby"])
    add_multiple_args_to_one_dest(parser, ["dst", "dstappend", "dstsorted"], "dst")
    add_integer_args(parser, ["jobcount", "threadcount", "chunksize", "jcmultiplier", "detached", "waitfor", "stderrlevel", "maxjobfails", "count"])

    add_help_messages(parser,
        [
            ("aborttx",
             "NEW! abort given transaction"),
            ("append",
             "turn on append mode in write operation"),
            ("chunksize",
             "bound for the size of the chunk in write operation"),
            ("codec",
             "NEW! type of comression used while writing table, "
             "possible values 'snappy', 'lz4', 'lz4_high_compression', "
             "'gzip_normal', 'gzip_best_compression', 'quick_lz', "
             "by default value depends on yt installation."),
            ("committx",
             "NEW! commit given transaction"),
            ("copy",
             "copy given tables to one destination table"),
            ("createtable",
             "NEW! creates empty table"),
            ("detached",
             "NEW! run operation in detached mode. Operation continues even"
             "if connection from client would be broken"),
            ("download",
             "NEW! download file from given path"),
            ("drop",
             "delete given table"),
            ("dst",
             "destination table, option can be passed multiple times"),
            ("dstappend",
             "destination table in append mode, option can be passed multiple times"),
            ("dstsorted",
             "check that output of your operation to this table is sorted"),
            ("dsv",
             "NEW! use delimited separated value format"),
            ("dynallocmode",
             "OLD! this option do nothing"),
            ("erase",
             "NEW! delete the table, this option supports range specifications"),
            ("exists",
             "NEW! check table for existance"),
            ("failonemptysrctable",
             "OLD! Error if one of input table does not exist"),
            ("file",
             "file for both map and reduce operations"),
            ("force",
             "force removing object of any type"),
            ("fs",
             "field separator for yamr format"),
            ("get",
             "NEW! returns subtree at given path in JSON format"),
            ("inputformat",
             "NEW! specifies operation input format. "
             "This option has the following format: "
             "'<format options as YSON map fragment>format'"),
            ("jcmultiplier",
             "OLD! this option do nothing"),
            ("jobcount",
             "specifies jobcount (only for map and reduce operations)"),
            ("lenval",
             "turn on yamr format with lenval"),
            ("list",
             "list all tables"),
            ("listfiles",
             "NEW! list all files"),
            ("lowerkey",
             "specifies lowerkey for the range in the read operation"),
            ("map",
             "specifies map operation command"),
            ("mapfile",
             "NEW! file for the map stage of mapreduce operation"),
            ("maxjobfails",
             "OLD! Limit to the number of failed jobs of operation"),
            ("memlimit",
             "Memory limit for user job in Mb."),
            ("merge",
             "merge given tables"),
            ("mode",
             "NEW! describes how to merge tables. Should be unordered, ordered or sorted (default)."),
            ("move",
             "OLD! Move src table to dst table"),
            ("nocreatetmptable",
             "OLD! this option do nothing"),
            ("opt",
             "OLD! this option do nothing"),
            ("outputformat",
             "NEW! specifies operation output format. "
             "This option has the following format: "
             "'<format options as YSON map fragment>format'"),
            ("pingtx",
             "NEW! turn on pinging ancestor transactions"),
            ("prefix",
             "YT use tree structure to store meta information about system objects. "
             "Each path in the tree (except root) starts with '//'. "
             "Therefore, (for back compatibility purpose) we use this option as prefix "
             "for each option that means path in the tree. Default='//statbox/'"),
            ("read",
             "read given table"),
            ("reduce",
             "specifies reduce operation command"),
            ("reducefile",
             "NEW! file for the reduce stage of mapreduce operation"),
            ("reducews",
                 ""),
            ("renewtx",
             "NEW! renew given transaction"),
            ("replicationfactor",
             "NEW! specifies replication factor of tables to write"),
            ("rs",
             "record separator for yamr format"),
            ("server",
             "address of the proxy "
             "(port usually equals to 80 and can be omitted)"),
            ("set",
             "NEW! set value to given path, value should be in JSON format"),
            ("smartformat",
             "try to extract input and output formats from inputs and outputs (by '_format' attribute)"),
            ("sort",
             "sort source tables to destination table"),
            ("sortby",
             "NEW! columns to sortby, this option can be passed multiple times. "
             "The order is important, by default=key,subkey."),
            ("reduceby",
             "NEW! columns to reduceby, this option can be passed multiple times. "
             "The order is important, by default=key."),
            ("src",
             "source table, this option can be passed multiple times"),
            ("starttx",
             "NEW! start transaction, returns transaction id"),
            ("subkey",
             "turn on yamr format with subkey"),
            ("tablereader",
             "NEW! config of table reader for read operation"),
            ("tablewriter",
             "NEW! config of table writer for write operation"),
            ("timeout",
             "NEW! timeout for transaction"),
            ("title",
             "NEW! title of the operation to print in the web interface"),
            ("threadcount",
             "OLD! this option do nothing"),
            ("track",
             "NEW! track operation progress"),
            ("tx",
             "NEW! perform command in the context of the given transaction"),
            ("upload",
             "NEW! upload given file to destination"),
            ("upperkey",
             "specifies upperkey for the range in the read operation"),
            ("value",
             "specifies value for set operation"),
            ("version",
             "print version"),
            ("write",
             "write stdin to given table"),
            ("writesorted",
             "write stdin to given table, holds table sorted"),
            ("ytfile",
             "NEW! specifies path to the file in YT tree for use it in current operation"),
            ("ytspec",
             "NEW! spec for given operation in JSON format"),
            ("ytlock",
             "NEW! get lock on the given path"),
        ]
        +
        [(name, "this argument is inherited from Yandex Mapreduce and it is ignored")
         for name in ["threadcount", "jcmultiplier", "dynallocmode", "opt",
                      "failonemptysrctable", "nocreatetmptable"]
        ]
    )

    # Ignore all positional arguments
    parser.add_argument("ignored", nargs=REMAINDER);

    args = parser.parse_args()

    actions_count = sum([vars(args)[arg] is not None for arg in action_stores + action_maybe_stores]) + \
                    sum([vars(args)[arg] for arg in action_flags])
    mapreduce_case = args.map is not None and args.reduce is not None and actions_count == 2
    if actions_count != 1 and not mapreduce_case:
        die("You should pass exactly one action", 1)
    if args.version:
        die("Version: YT wrapper " + get_version(), 0)

    if args.failonemptysrctable:
        config.TREAT_UNEXISTING_AS_EMPTY = False
    if args.chunksize is not None:
        config.CHUNK_SIZE = args.chunksize
    if args.server is not None:
        config.set_proxy(args.server)
    if args.prefix is not None:
        config.PREFIX = args.prefix
    if args.timeout is not None:
        config.TRANSACTION_TIMEOUT = int(args.timeout)

    spec = {}
    if args.ytspec is not None:
        for spec_arg in args.ytspec:
            spec.update(json.loads(spec_arg))

    if args.title is not None:
        spec["title"] = args.title

    if args.maxjobfails is not None:
        spec["max_failed_job_count"] = args.maxjobfails

    has_dstsorted = False
    dst = []
    for option_name, value in get_value(args.dst, []):
        assert option_name in ["-dst", "-dstappend", "-dstsorted"]
        if option_name == "-dst":
            dst.append(yt.TablePath(value, append=args.append))
        elif option_name == "-dstappend":
            dst.append(yt.TablePath(value, append=True))
        elif option_name == "-dstsorted":
            has_dstsorted = True
            dst.append(yt.TablePath(value, sorted_by=["key", "subkey"]))

    if not dst:
        dst = None

    def to_list(arg):
        if arg is None:
            return []
        else:
            return flatten(arg)
    map_files = to_list(args.file) + to_list(args.mapfile)
    reduce_files = to_list(args.file) + to_list(args.reducefile)

    config.DEFAULT_FORMAT = yt.YamrFormat(lenval=args.lenval,
                                          has_subkey=args.subkey,
                                          field_separator=args.fs,
                                          record_separator=args.rs)
    if args.dsv:
        if args.lenval or args.subkey:
            die("Options subkey and lenval are mutually exclusive with dsv option")
        args.dsv = yt.DsvFormat()
        # Try it if occur problem with reduce_by and sort_by
        #config.USE_YAMR_SORT_REDUCE_COLUMNS = False

    commands_that_use_format = ["get", "set", "read", "write", "writesorted", "map", "reduce", "reducews"]
    if sum([vars(args)[arg] is not None for arg in commands_that_use_format]) == 0 \
        and any(vars(args)[option] is not None for option in ["format", "inputformat", "outputformat"]):
        die("You should not specify format for given command")


    for option in ["format", "inputformat", "outputformat"]:
        if vars(args)[option] is not None:
            vars(args)[option] = yt.create_format((vars(args)[option]))

    inputformat = first_not_none(imap(calculate_if_function,
        [args.format,
         args.inputformat,
         args.dsv,
         lambda: get_smart_format([args.src, args.read], args.smartformat, args.subkey, args.lenval,
                                  ignore_unexisting_tables=True),
         config.DEFAULT_FORMAT]))

    write_tables = args.write if not isinstance(args.write, MissingValue) else None
    outputformat = first_not_none(imap(calculate_if_function,
        [args.format,
         args.outputformat,
         args.dsv,
         lambda: get_smart_format([dst, write_tables], args.smartformat, args.subkey, args.lenval),
         config.DEFAULT_FORMAT]))

    if isinstance(outputformat, str):
        outputformat = yt.create_format(outputformat)
    if not (isinstance(outputformat, yt.YamrFormat) or isinstance(outputformat, yt.YamredDsvFormat)) and has_dstsorted:
        die("Output format must be yamr or yamred_dsv if dstsorted is non-trivial")

    if args.tx is not None:
        config.TRANSACTION = args.tx
    config.PING_ANCESTOR_TRANSACTIONS = args.pingtx

    if args.memlimit is not None:
        config.MEMORY_LIMIT = int(args.memlimit) * MB

    config.DETACHED = (args.detached is None) or bool(args.detached)

    attributes = {}

    replication_factor = args.replicationfactor
    if replication_factor is not None:
        replication_factor = int(args.replicationfactor)
        attributes["replication_factor"] = replication_factor

    if args.codec is not None:
        attributes["compression_codec"] = args.codec

    if args.tablewriter is not None:
        args.tablewriter = json.loads(args.tablewriter)
    if args.tablereader is not None:
        args.tablereader = json.loads(args.tablereader)


    if args.list:
        write_silently(imap(add_eoln, list_all_entities("table")))
    if args.listfiles:
        write_silently(imap(add_eoln, list_all_entities("file")))
    if args.read is not None:
        write_silently(
            chunk_iter_stream(
                yt.read_table(
                    yt.TablePath(args.read, lower_key=args.lowerkey, upper_key=args.upperkey),
                    format=inputformat),
                16 * MB))
    if args.createtable is not None:
        yt.create_table(args.createtable, attributes=attributes)
    if args.write is not None:
        if isinstance(args.write, MissingValue):
            write_tables = dst
        else:
            write_tables = [yt.TablePath(args.write, append=args.append)]
        if len(write_tables) == 1:
            yt.write_table(write_tables[0], sys.stdin, format=outputformat,
                           table_writer=args.tablewriter,
                           replication_factor=replication_factor,
                           compression_codec=args.codec)
        else:
            with yt.Transaction():
                visited = set()
                for key, records in groupby(outputformat.load_rows(sys.stdin), key=lambda rec: rec.tableIndex):
                    table = dst[key]
                    if key in visited:
                        table.append = True
                    visited.add(key)

                    yt.write_table(table, records, format=outputformat, raw=False,
                                   table_writer=args.tablewriter,
                                   replication_factor=replication_factor,
                                   compression_codec=args.codec)

    if args.writesorted is not None:
        table = yt.TablePath(args.writesorted, append=args.append, sorted_by=["key", "subkey"])
        yt.write_table(table, sys.stdin, format=outputformat,
                       replication_factor=replication_factor,
                       compression_codec=args.codec)
    if mapreduce_case:
        map_input_format = inputformat
        map_output_format = reduce_input_format = reduce_output_format = outputformat
        yt.run_map_reduce(args.map, args.reduce, args.src, dst,
                          map_files=map_files, reduce_files=reduce_files,
                          map_file_paths=args.ytfile, reduce_file_paths=args.ytfile,
                          map_input_format=map_input_format, map_output_format=map_output_format,
                          reduce_input_format=reduce_input_format, reduce_output_format=reduce_output_format,
                          sort_by=args.sortby, reduce_by=args.reduceby,
                          replication_factor=replication_factor,
                          compression_codec=args.codec,
                          spec=spec)
    elif args.map is not None:
        yt.run_map(args.map, args.src, dst, files=map_files, file_paths=args.ytfile,
                   input_format=inputformat, output_format=outputformat,
                   replication_factor=replication_factor,
                   compression_codec=args.codec,
                   job_count=args.jobcount,
                   spec=spec)
    elif args.reduce is not None or args.reducews is not None or args.reducewsonly is not None:
        if inputformat.name() == "yamred_dsv" and args.reduceby is None:
            args.reduceby = inputformat.attributes.get("key_column_names", [])
        op = first_not_none([args.reduce, args.reducews, args.reducewsonly])
        yt.run_reduce(op, args.src, dst, files=reduce_files, file_paths=args.ytfile,
                      input_format=inputformat, output_format=outputformat,
                      reduce_by=args.reduceby,
                      sort_by=args.sortby,
                      replication_factor=replication_factor,
                      compression_codec=args.codec,
                      job_count=args.jobcount,
                      spec=spec)
    if args.drop is not None:
        if yt.exists(args.drop):
            if not args.force and yt.get_type(args.drop) not in ["table", "file"]:
                die("You are trying to remove object of type " + yt.get_type(args.drop))
            if args.force:
                _remove_locks(args.drop)
            remove_with_empty_dirs(args.drop)

    if args.copy or args.move:
        if args.copy:
            method = copy_table
        if args.move:
            method = move_table
        if isinstance(dst, types.ListType) and len(dst) > 1:
            if len(args.src) != len(dst):
                exit("Number of source and destination tables must be the same "
                     "in case of multiple destination tables in copy or move")
            with yt.Transaction():
                for source_table, destination_table in zip(args.src, dst):
                    method(source_table, destination_table)
        else:
            method(args.src, unlist_destination_tables(dst))

    if args.sort:
        if inputformat.name() == "yamred_dsv" and args.sortby is None:
            args.sortby = inputformat.attributes.get("key_column_names", []) + \
                          inputformat.attributes.get("subkey_column_names", [])
        yt.run_sort(args.src, unlist_destination_tables(dst), sort_by=args.sortby,
                      replication_factor=replication_factor,
                      compression_codec=args.codec,
                      spec=spec)
    if args.merge:
        yt.run_merge(args.src, unlist_destination_tables(dst), mode=get_value(args.mode, "sorted"),
                     replication_factor=replication_factor,
                     compression_codec=args.codec,
                     job_count=args.jobcount,
                     spec=spec)

    if args.erase is not None:
        yt.run_erase(args.erase)
    if args.upload is not None:
        if yt.exists(args.upload) and yt.get_type(args.upload) == "file":
            remove_with_empty_dirs(args.upload)
        yt.mkdir(os.path.dirname(args.upload))
        yt.upload_file(sys.stdin, args.upload)
        if args.executable:
            yt.set_attribute(args.upload, "executable", bool_to_string(True))
    if args.download is not None:
        if yt.exists(args.download):
            write_silently(chunk_iter_stream(yt.download_file(args.download), 16 * MB))

    if args.exists is not None:
        print bool_to_string(yt.exists(args.exists))

    if args.get is not None:
        sys.stdout.write(yt.get(args.get, spec=spec, format=yt.create_format("<format=pretty>json")))
    if args.set is not None:
        if args.value is None:
            die("Value option is necessary for set command")
        yt.set(args.set, yson.json_to_yson(json.loads(args.value)))

    if args.starttx:
        print yt.start_transaction()
    if args.committx is not None:
        yt.commit_transaction(args.committx)
    if args.aborttx is not None:
        yt.abort_transaction(args.aborttx)
    if args.renewtx is not None:
        yt.ping_transaction(args.renewtx)

    if args.ytlock is not None:
        print yt.lock(args.ytlock, mode=args.mode, waitable=args.waitable, wait_for=args.waitfor)

    if args.track is not None:
        config.DETACHED = True
        config.KEYBOARD_ABORT = False
        yt.WaitStrategy().process_operation("unknown", args.track)

if __name__ == "__main__":
    run_main(main)
