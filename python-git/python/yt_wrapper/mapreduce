#!/usr/bin/env python

# Params:
# +++ -version
# -fs
# -rs
# +++ -lenval
# +++ -subkey
# +++ -src
# +++ -dst
# +++ -dstappend
# -dstsorted
# +++ -copy
# +++ -sort
# +++ -merge
# +++ -map
# +++ -reduce
# +++ -reducews
# +++ -file
# -memlimit
# -timelimit
# +++ -list
# +++ -read
# +++ -write
# +++ -writesorted
# +++ -drop
# -lock
# -unlock
# +++ -lowerkey
# +++ -upperkey
# +++ -append
# +++ -jobcount
# +++ -threadcount IS IGNORED
# +++ -jcmultiplier IS IGNORED
# +++ -chunksize
# +++ -dynallocmode IS IGNORED
# +++ -opt  IS IGNORED

import ast
import yt
import config
from common import flatten, unlist

import sys
from argparse import ArgumentParser
from functools import partial
from itertools import imap

config.PREFIX = "//statbox/"

def add_prefix(table):
    return config.PREFIX + table

def remove_prefix(table):
    if table.startswith(config.PREFIX):
        return table[len(config.PREFIX):]
    return table

def list_all_tables():
    result = []
    def walk(path, object):
        object_type = object["$attributes"]["type"]
        if object_type == "table":
            if path.startswith(config.PREFIX):
                result.append(path)
        elif object_type == "map_node" and object["$value"] is not None:
            for key, value in object["$value"].iteritems():
                walk(path + '/%s' % key, value)
        else:
            # All other objects are ignored
            pass
    walk("/", yt.get("/", attributes=["type"]))
    return map(remove_prefix, sorted(result))

def add_eoln(str):
    return str + "\n"

def add_store_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg)
def add_bool_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action="store_true", default=False)
def add_multiple_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action="append")

def add_integer_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, type=int)

def add_help_message(parser, arg_name, message):
    arg_name = "-" + arg_name
    args_tuple = parser._get_option_tuples(arg_name)
    for arg in args_tuple:
        if arg[1] == arg_name:
            arg[0].help = message
            return
    assert "There is no such option"

def add_help_messages(parser, args):
    for arg, message in args:
        add_help_message(parser, arg, message)

def parse_format(format):
    return None if format is None else yt.RawFormat(format)

def main():
    config.FORCE_SORT_IN_REDUCE = True
    config.USE_MAPREDUCE_STYLE_DST_TABLES = True

    # TODO(ignat): add unsupported arguments
    action_stores = ["read", "write", "writesorted", "map", "reduce", "mapreduce", "reducews", "drop",
                     "erase", "abort_tx", "commit_tx", "renew_tx", "set", "get", "upload", "download"]
    action_flags = ["version", "copy", "sort", "merge", "list", "start_tx"]

    parser = ArgumentParser()
    add_bool_args(parser, action_flags + ["subkey", "lenval", "append", "dynallocmode", "dsv", "ping"])
    add_store_args(parser, action_stores + ["server", "lowerkey", "upperkey", "prefix", "codec",
                                            "inputformat", "outputformat", "tx", "value", "replication_factor"])
    add_multiple_args(parser, ["src", "dst", "dstappend", "file", "mapfile", "reducefile", "ytfile", "opt", "ytspec"])
    add_integer_args(parser, ["jobcount", "threadcount", "chunksize", "jcmultiplier"])

    add_help_messages(parser,
        [
            ("codec",
             "type of comression used while writing table, "
             "possible values 'snappy', 'gzip_normal'' (lz4)"),
            ("server",
             "name of the proxy, port usually equals to 80 "
             "and can be ommited in this argument"),
            ("prefix",
             "prefix that would add to each passed table, "
             "each path in YT starts with //, for example '//home/username/my_table'"),
            ("file",
             "file for bath map and reduce operations"),
            ("mapfile",
             "file for map stage of mapreduce operation"),
            ("reducefile",
             "file for reduce stage of mapreduce operation"),
            ("map",
             "command for run map operation"),
            ("reduce",
             "command for run reduce operation"),
            ("prefix",
             "prefix that would add to each passed table, "
             "each path in YT starts with //, for example '//home/username/my_table'"),
        ]
        + 
        [(name, "this argument is inherited from Yandex Mapreduce and it is ignored")
         for name in ["threadcount", "jcmultiplier", "dynallocmode", "opt"]
        ]
    )

    args = parser.parse_args()

    actions_count = sum([vars(args)[arg] is not None for arg in action_stores]) + \
                    sum([vars(args)[arg] for arg in action_flags])
    mapreduce_case = args.map is not None and args.reduce is not None and actions_count == 2
    if actions_count != 1 and not mapreduce_case:
        print >>sys.stderr, "You should pass exactly one action"
        exit(0)

    if args.version:
        print "Version: YT wrapper"
        exit(0)

    if args.chunksize is not None:
        config.WRITE_BUFFER_SIZE = args.chunksize
    if args.server is not None:
        config.PROXY = args.server
    if args.prefix is not None:
        config.PREFIX = args.prefix

    spec = {}
    if vars(args)["ytspec"] is not None:
        for spec_arg in args.ytspec:
            spec.update(ast.literal_eval(spec_arg))
    if args.jobcount is not None:
        spec.update({"job_count": args.jobcount})

    # Fix table names
    method = add_prefix
    for option in ["src", "dst", "dstappend", "ytfile"]:
        if vars(args)[option] is not None:
            vars(args)[option] = map(method, vars(args)[option])
    for option in ["read", "write", "writesorted", "drop", "get", "set"]:
        if vars(args)[option] is not None:
            vars(args)[option] = method(vars(args)[option])


    dst = []
    if args.dst is not None:
        dst += args.dst
    if args.dstappend is not None:
        dst += map(partial(yt.Table, append=True), args.dstappend)
    if not dst:
        dst = None

    def to_list(arg):
        if arg is None:
            return []
        else:
            return flatten(arg)
    map_files = to_list(args.file) + to_list(args.mapfile)
    reduce_files = to_list(args.file) + to_list(args.reducefile)

    config.DEFAULT_FORMAT = config.YamrFormat(lenval=args.lenval, has_subkey=args.subkey)
    if args.dsv:
        if args.lenval or args.subkey:
            print >>sys.stderr, "Options subkey and lenval are mutually exclusive with dsv option"
            exit(1)
        config.DEFAULT_FORMAT = yt.DsvFormat()

    args.inputformat = parse_format(args.inputformat)
    args.outputformat = parse_format(args.outputformat)

    if args.tx is not None:
        config.TRANSACTION = args.tx

    table_writer = {}
    if args.codec is not None:
        table_writer["codec_id"] = args.codec
    if args.replication_factor is not None:
        table_writer["replication_factor"] = args.replication_factor
        table_writer["upload_replication_factor"] = args.replication_factor

    if args.list:
        sys.stdout.writelines(imap(add_eoln, list_all_tables()))
    if args.read is not None:
        sys.stdout.writelines(yt.read_table(
            yt.Table(args.read, lower_key=args.lowerkey, upper_key=args.upperkey)))
    if args.write is not None:
        args.write = yt.Table(args.write, append=args.append)
        yt.write_table(args.write, sys.stdin, table_writer=table_writer)
    if args.writesorted is not None:
        args.writesorted = yt.Table(args.writesorted, append=args.append)
        yt.write_table(args.writesorted, sys.stdin, table_writer=table_writer)
        yt.set_attribute(args.writesorted.name, "sorted", "true")
    if mapreduce_case:
        yt.run_map_reduce(args.map, args.reduce, args.src, dst,
                          map_files=map_files, reduce_files=reduce_files,
                          map_file_paths=args.ytfile, reduce_file_paths=args.ytfile,
                          input_format=args.inputformat, output_format=args.outputformat,
                          table_writer=table_writer, spec=spec)
    elif args.map is not None:
        yt.run_map(args.map, args.src, dst, files=map_files, file_paths=args.ytfile,
                   input_format=args.inputformat, output_format=args.outputformat,
                   table_writer=table_writer, spec=spec)
    elif args.reduce is not None or args.reducews is not None:
        yt.run_reduce(args.reduce, args.src, dst, files=reduce_files, file_paths=args.ytfile,
                      input_format=args.inputformat, output_format=args.outputformat,
                      table_writer=table_writer, spec=spec)
    if args.drop is not None:
        yt.remove_table(args.drop)
    if args.copy:
        yt.copy_table(args.src, unlist(dst))
    if args.sort:
        yt.sort_table(args.src, unlist(dst), table_writer=table_writer, spec=spec)
    if args.merge:
        yt.merge_tables(args.src, unlist(dst), mode="sorted", table_writer=table_writer, spec=spec)

    if args.erase is not None:
        yt.erase(args.erase)
    if args.upload is not None:
        if yt.exists(dst[0]):
            yt.remove(dst[0])
        yt.upload_file(args.upload, destination=dst[0])
    if args.download is not None:
        sys.stdout.writelines(yt.download_file(args.download))

    if args.set:
        if args.value is None:
            print >>sys.stderr, "Value option is necessary for set command"
            exit(1)
        yt.set(args.set, args.value)
    if args.get:
        if yt.exists(args.get):
            print yt.get(args.get)

    if args.start_tx:
        print yt.start_transaction(args.tx, args.ping)
    if args.commit_tx is not None:
        yt.commit_transaction(args.commit_tx, args.ping)
    if args.abort_tx is not None:
        yt.abort_transaction(args.abort_tx, args.ping)
    if args.renew_tx is not None:
        yt.renew_transaction(args.renew_tx, args.ping)

if __name__ == "__main__":
    main()
