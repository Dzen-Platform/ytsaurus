#!/usr/bin/env python

# Options that not yet implemented:
# -timelimit
# -lock
# -unlock

from yt.wrapper.table_commands import copy_table
from yt.wrapper.tree_commands import remove_with_empty_dirs
from yt.wrapper.table import check_prefix

from yt.wrapper.common import flatten, unlist, first_not_none, bool_to_string, get_value
from yt.wrapper.version import VERSION
import yt.wrapper.config as config
import yt.wrapper as yt
import yt.yson as yson

import os
import sys
import traceback
import simplejson as json
from argparse import ArgumentParser, RawTextHelpFormatter, REMAINDER
from operator import attrgetter
from functools import partial
from itertools import imap

def die(message=None, return_code=1):
    if message is not None:
        print >>sys.stderr, message
    if "ALWAYS_RAISE" in os.environ:
        raise
    sys.exit(return_code)

def remove_prefix(table):
    if "PREFIX" in config.__dict__ and table.startswith(config.PREFIX):
        return table[len(config.PREFIX):]
    return table

def list_all_entities(type):
    if config.PREFIX is None:
        die("You should specify PREFIX for list command")
    check_prefix(config.PREFIX)
    tables = yt.search(config.PREFIX[:-1], type,
                       path_filter=lambda path: path.startswith(config.PREFIX))
    return sorted(map(remove_prefix, tables))

def add_eoln(str):
    return str + "\n"

def add_store_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg)
def add_bool_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action="store_true", default=False)
def add_multiple_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action="append")

def add_integer_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, type=int)

def add_help_message(parser, arg_name, message):
    arg_name = "-" + arg_name
    args_tuple = parser._get_option_tuples(arg_name)
    for arg in args_tuple:
        if arg[1] == arg_name:
            arg[0].help = message
            return
    assert "There is no such option"

def add_help_messages(parser, args):
    for arg, message in args:
        add_help_message(parser, arg, message)

class SortingHelpFormatter(RawTextHelpFormatter):
    def add_arguments(self, actions):
        actions = sorted(actions, key=attrgetter('option_strings'))
        super(SortingHelpFormatter, self).add_arguments(actions)

def writelines_silently(lines):
    try:
        for line in lines:
            sys.stdout.write(line)
    except IOError:
        sys.exit(1)
    except:
        raise

def get_smart_format(tables, smart_format_flag, has_subkey):
    def extract_format(table):
        table = yt.to_table(table)
        if "channel" in table.name.attributes:
            return yt.RawFormat.from_yson(yson.loads("<line_prefix=tskv>dsv"))
        elif yt.has_attribute(table.name, "_format"):
            return yt.RawFormat.from_yson(yt.get_attribute(table.name, "_format"))
        else:
            return None
    if not(smart_format_flag or "SMART_FORMAT" in os.environ):
        return None
    tables = filter(lambda x: yt.exists(yt.to_name(x)), filter(None, flatten(tables)))
    formats = map(extract_format, tables)
    if formats and any(format != formats[0] for format in formats):
        die("Tables have different attribute _format: " + repr(formats))
    formats = filter(None, formats)
    if formats:
        # Dirty hacks :(
        if formats[0]._format in ["yamr", "yamred_dsv"]:
            formats[0]._format.attributes["has_subkey"] = bool_to_string(has_subkey)
        return formats[0]


def main():
    config.set_mapreduce_mode()

    parser = ArgumentParser(
        formatter_class=SortingHelpFormatter,
        description="Shell utility to work with YT system.\n"
                    "This utitlity is back-compatible with mapreduce for Yamr.",
        epilog=
"""
Examples:
    Append data to table with replication factor one, gzip codec and chunks of size 1Gb:
            ./mapreduce -write 'table' -replicationfactor 1 -codec 'gzip_normal' -chunksize 1073741824 -append < data

    Read 10 records from the table:
            ./mapreduce -read 'table[:#10]'

    Run operation on the range of the table:
            ./mapreduce
                -subkey
                -map 'awk '"'"'{sum+=$1+$2} END {print "\\t\\t"sum}'"'"
                -src "ignat/temp{key,subkey}[("aaa"):("zzz")]"
                -dst "ignat/sum"

    Run map-reduce operation:
            ./mapreduce
                -subkey
                -map 'grep "A"'
                -reduce 'awk '"'"'{a[$1]+=$3} END {for (i in a) {print i"\\t\\t"a[i]}}'"'"
                -src "ignat/temp"
                -dst "ignat/reduced"

    Use already uploaded files:
            ./mapreduce -upload mapper.py < ignat/mapper.py
            ./mapreduce -subkey -map "./mapper.py" -ytfile "ignat/mapper.py" -src "ignat/temp" -dst "ignat/mapped"

    Use attrbiutes:
            ./mapreduce -set "log/@my_attr"  -value 10
            ./mapreduce -get "log/@my_attr"
    It returns 10.
"""
    )

    action_stores = ["read", "write", "writesorted", "map", "reduce", "reducews", "drop",
                     "erase", "aborttx", "committx", "renewtx", "set", "get", "upload", "download",
                     "createtable", "exists", "track", "ytlock"]
    action_flags = ["version", "copy", "sort", "merge", "list", "listfiles", "starttx"]

    add_bool_args(parser, action_flags + ["subkey", "lenval", "append", "dynallocmode", "dsv", "pingtx",
                                          "smartformat", "force", "executable"])

    add_store_args(parser, action_stores + ["server", "lowerkey", "upperkey", "prefix", "codec",
                                            "format", "inputformat", "outputformat", "tx", "value",
                                            "replicationfactor", "memlimit", "timeout", "title", "fs", "rs",
                                            "mode", "tablereader", "tablewriter"])
    add_multiple_args(parser, ["src", "dst", "dstappend", "dstsorted", "file", "mapfile", "reducefile", "ytfile", "opt", "ytspec", "sortby", "reduceby"])
    add_integer_args(parser, ["jobcount", "threadcount", "chunksize", "jcmultiplier", "detached"])

    add_help_messages(parser,
        [
            ("aborttx",
             "NEW! abort given transaction"),
            ("append",
             "turn on append mode in write operation"),
            ("chunksize",
             "bound for the size of the chunk in write operation"),
            ("codec",
             "NEW! type of comression used while writing table, "
             "possible values 'snappy', 'lz4', 'lz4_high_compression', "
             "'gzip_normal', 'gzip_best_compression', 'quick_lz', "
             "by default value depends on yt installation."),
            ("committx",
             "NEW! commit given transaction"),
            ("copy",
             "copy given tables to one destination table"),
            ("createtable",
             "NEW! creates empty table"),
            ("detached",
             "NEW! run operation in detached mode. Operation continues even"
             "if connection from client would be broken"),
            ("download",
             "NEW! download file from given path"),
            ("drop",
             "delete given table"),
            ("dst",
             "destination table, option can be passed multiple times"),
            ("dstappend",
             "destination table in append mode, option can be passed multiple times"),
            ("dstsorted",
             "check that output of your operation to this table is sorted"),
            ("dsv",
             "NEW! use delimited separated value format"),
            ("dynallocmode",
             "OLD! this option do nothing"),
            ("erase",
             "NEW! delete the table, this option supports range specifications"),
            ("exists",
             "NEW! check table for existance"),
            ("file",
             "file for both map and reduce operations"),
            ("force",
             "force removing object of any type"),
            ("fs",
             "field separator for yamr format"),
            ("get",
             "NEW! returns subtree at given path in json format"),
            ("inputformat",
             "NEW! specifies operation input format. "
             "This option has the following format: "
             "'<format options as yson map fragment>format'"),
            ("jcmultiplier",
             "OLD! this option do nothing"),
            ("jobcount",
             "specifies jobcount (only for map and reduce operations)"),
            ("lenval",
             "turn on yamr format with lenval"),
            ("list",
             "list all tables"),
            ("listfiles",
             "NEW! list all files"),
            ("lowerkey",
             "specifies lowerkey for the range in the read operation"),
            ("map",
             "specifies map operation command"),
            ("mapfile",
             "NEW! file for the map stage of mapreduce operation"),
            ("memlimit",
             "Memory limit for user job in Mb."),
            ("merge",
             "merge given tables"),
            ("mode",
             "NEW! describes how to merge tables. Should be unordered, ordered or sorted (default)."),
            ("opt",
             "OLD! this option do nothing"),
            ("outputformat",
             "NEW! specifies operation output format. "
             "This option has the following format: "
             "'<format options as yson map fragment>format'"),
            ("pingtx",
             "NEW! turn on pinging ancestor transactions"),
            ("prefix",
             "YT use tree structure to store meta information about system objects. "
             "Each path in the tree (except root) starts with '//'. "
             "Therefore, (for back compatibility purpose) we use this option as prefix "
             "for each option that means path in the tree. Default='//statbox/'"),
            ("read",
             "read given table"),
            ("reduce",
             "specifies reduce operation command"),
            ("reducefile",
             "NEW! file for the reduce stage of mapreduce operation"),
            ("reducews",
                 ""),
            ("renewtx",
             "NEW! renew given transaction"),
            ("replicationfactor",
             "NEW! specifies replication factor of tables to write"),
            ("rs",
             "record separator for yamr format"),
            ("server",
             "address of the proxy "
             "(port usually equals to 80 and can be omitted)"),
            ("set",
             "NEW! set value to given path, value should be in json format"),
            ("sort",
             "sort source tables to destination table"),
            ("sortby",
             "NEW! columns to sortby, this option can be passed multiple times. "
             "The order is important, by default=key,subkey."),
            ("reduceby",
             "NEW! columns to reduceby, this option can be passed multiple times. "
             "The order is important, by default=key."),
            ("src",
             "source table, this option can be passed multiple times"),
            ("starttx",
             "NEW! start transaction, returns transaction id"),
            ("subkey",
             "turn on yamr format with subkey"),
            ("tablereader",
             "NEW! config of table reader for read operation"),
            ("tablewriter",
             "NEW! config of table writer for write operation"),
            ("timeout",
             "NEW! timeout for transaction"),
            ("title",
             "NEW! title of the operation to print in the web interface"),
            ("threadcount",
             "OLD! this option do nothing"),
            ("track",
             "NEW! track operation progress"),
            ("tx",
             "NEW! perform command in the context of the given transaction"),
            ("upload",
             "NEW! upload given file to destination"),
            ("upperkey",
             "specifies upperkey for the range in the read operation"),
            ("value",
             "specifies value for set operation"),
            ("version",
             "print version"),
            ("write",
             "write stdin to given table"),
            ("writesorted",
             "write stdin to given table, holds table sorted"),
            ("ytfile",
             "NEW! specifies path to the file in YT tree for use it in current operation"),
            ("ytspec",
             "NEW! spec for given operation in json format"),
            ("ytlock",
             "NEW! get lock on the given path"),
        ]
        +
        [(name, "this argument is inherited from Yandex Mapreduce and it is ignored")
         for name in ["threadcount", "jcmultiplier", "dynallocmode", "opt"]
        ]
    )

    # Ignore all positional arguments
    parser.add_argument("ignored", nargs=REMAINDER);

    args = parser.parse_args()

    actions_count = sum([vars(args)[arg] is not None for arg in action_stores]) + \
                    sum([vars(args)[arg] for arg in action_flags])
    mapreduce_case = args.map is not None and args.reduce is not None and actions_count == 2
    if actions_count != 1 and not mapreduce_case:
        die("You should pass exactly one action", 1)
    if args.version:
        die("Version: YT wrapper " + VERSION, 0)

    if args.chunksize is not None:
        config.WRITE_BUFFER_SIZE = args.chunksize
    if args.server is not None:
        config.PROXY = args.server
    if args.prefix is not None:
        config.PREFIX = args.prefix
    if args.timeout is not None:
        config.TRANSACTION_TIMEOUT = int(args.timeout)

    spec = {}
    if args.jobcount is not None:
        spec.update({"job_count": args.jobcount})
    if vars(args)["ytspec"] is not None:
        for spec_arg in args.ytspec:
            spec.update(json.loads(spec_arg))

    if args.title is not None:
        spec["title"] = args.title

    dst = []
    if args.dst is not None:
        dst += map(partial(yt.TablePath, append=args.append), args.dst)
    if args.dstappend is not None:
        dst += map(partial(yt.TablePath, append=True), args.dstappend)
    if args.dstsorted is not None:
        dst += map(partial(yt.TablePath, sorted_by=["key", "subkey"]), args.dstsorted)
    if not dst:
        dst = None

    def to_list(arg):
        if arg is None:
            return []
        else:
            return flatten(arg)
    map_files = to_list(args.file) + to_list(args.mapfile)
    reduce_files = to_list(args.file) + to_list(args.reducefile)

    config.DEFAULT_FORMAT = yt.YamrFormat(lenval=args.lenval,
                                          has_subkey=args.subkey,
                                          field_separator=args.fs,
                                          record_separator=args.rs)
    if args.dsv:
        if args.lenval or args.subkey:
            die("Options subkey and lenval are mutually exclusive with dsv option")
        args.dsv = yt.DsvFormat()
        # Try it if occur problem with reduce_by and sort_by
        #config.USE_YAMR_SORT_REDUCE_COLUMNS = False

    commands_that_use_format = ["get", "set", "read", "write", "writesorted", "map", "reduce", "reducews"]
    if sum([vars(args)[arg] is not None for arg in commands_that_use_format]) == 0 \
        and any(vars(args)[option] is not None for option in ["format", "inputformat", "outputformat"]):
        die("You should not specify format for given command")


    for option in ["format", "inputformat", "outputformat"]:
        if vars(args)[option] is not None:
            vars(args)[option] = yt.RawFormat.from_yson_string(vars(args)[option])

    inputformat = first_not_none(
        [args.format,
         args.inputformat,
         args.dsv,
         get_smart_format([args.src, args.read], args.smartformat, args.subkey),
         config.DEFAULT_FORMAT])
    outputformat = first_not_none(
        [args.format,
         args.outputformat,
         args.dsv,
         get_smart_format([dst, args.write], args.smartformat, args.subkey),
         config.DEFAULT_FORMAT])

    if args.tx is not None:
        config.TRANSACTION = args.tx
    config.PING_ANSECTOR_TRANSACTIONS = args.pingtx

    if args.memlimit is not None:
        config.MEMORY_LIMIT = int(args.memlimit) * config.MB

    if args.detached is None or bool(args.detached):
        config.DETACHED = True

    replication_factor = args.replicationfactor
    if replication_factor is not None:
        replication_factor = int(args.replicationfactor)

    if args.tablewriter is not None:
        args.tablewriter = json.loads(args.tablewriter)
    if args.tablereader is not None:
        args.tablereader = json.loads(args.tablereader)


    if args.list:
        writelines_silently(imap(add_eoln, list_all_entities("table")))
    if args.listfiles:
        writelines_silently(imap(add_eoln, list_all_entities("file")))
    if args.read is not None:
        writelines_silently(
            yt.read_table(
                yt.TablePath(args.read, lower_key=args.lowerkey, upper_key=args.upperkey),
                format=inputformat,
                response_type="iter_content"))
    if args.createtable is not None:
        yt.create_table(args.createtable)
    if args.write is not None:
        args.write = yt.TablePath(args.write, append=args.append)
        yt.write_table(args.write, sys.stdin, format=outputformat,
                       table_writer=args.tablewriter,
                       replication_factor=replication_factor,
                       compression_codec=args.codec)
    if args.writesorted is not None:
        args.writesorted = yt.TablePath(args.writesorted, append=args.append)#, sorted_by=["key", "subkey"])
        yt.write_table(args.writesorted, sys.stdin, format=outputformat,
                       replication_factor=replication_factor,
                       compression_codec=args.codec)
        # TODO: sorted_by has no proper support now. Delete it with remaking in system.
        yt.run_sort(args.writesorted)
    if mapreduce_case:
        if inputformat != outputformat:
            map_input_format = inputformat
            map_output_format = reduce_input_format = reduce_output_format = outputformat
        else:
            map_input_format = map_output_format = reduce_input_format = reduce_output_format = outputformat
        yt.run_map_reduce(args.map, args.reduce, args.src, dst,
                          map_files=map_files, reduce_files=reduce_files,
                          map_file_paths=args.ytfile, reduce_file_paths=args.ytfile,
                          map_input_format=map_input_format, map_output_format=map_output_format,
                          reduce_input_format=reduce_input_format, reduce_output_format=reduce_output_format,
                          sort_by=args.sortby, reduce_by=args.reduceby,
                          replication_factor=replication_factor,
                          compression_codec=args.codec,
                          spec=spec)
    elif args.map is not None:
        yt.run_map(args.map, args.src, dst, files=map_files, file_paths=args.ytfile,
                   input_format=inputformat, output_format=outputformat,
                   replication_factor=args.replicationfactor,
                   compression_codec=args.codec,
                   spec=spec)
    elif args.reduce is not None or args.reducews is not None:
        op = args.reduce if args.reduce is not None else args.reducews
        yt.run_reduce(op, args.src, dst, files=reduce_files, file_paths=args.ytfile,
                      input_format=inputformat, output_format=outputformat,
                      reduce_by=args.reduceby,
                      replication_factor=replication_factor,
                      compression_codec=args.codec,
                      spec=spec)
    if args.drop is not None:
        if yt.exists(args.drop):
            if not args.force and yt.get_type(args.drop) not in ["table", "file"]:
                die("You are trying to remove object of type " + yt.get_type(args.drop))
            if args.force:
                for lock in yt.get_attribute(args.drop, "locks", []):
                    if lock["mode"] != "snapshot":
                        if yt.exists("//sys/transactions/" + lock["transaction_id"]):
                            yt.abort_transaction(lock["transaction_id"])
            remove_with_empty_dirs(args.drop)
    if args.copy:
        copy_table(args.src, unlist(dst))
    if args.sort:
        yt.run_sort(args.src, unlist(dst), sort_by=args.sortby,
                      replication_factor=replication_factor,
                      compression_codec=args.codec,
                      spec=spec)
    if args.merge:
        yt.run_merge(args.src, unlist(dst), mode=get_value(args.mode, "sorted"),
                     replication_factor=replication_factor,
                     compression_codec=args.codec,
                     spec=spec)

    if args.erase is not None:
        yt.run_erase(args.erase)
    if args.upload is not None:
        if yt.exists(args.upload) and yt.get_type(args.upload) == "file":
            remove_with_empty_dirs(args.upload)
        yt.mkdir(os.path.dirname(args.upload))
        yt.upload_file(sys.stdin, args.upload)
        if args.executable:
            yt.set_attribute(args.upload, "executable", "true")
    if args.download is not None:
        if yt.exists(args.download):
            writelines_silently(yt.download_file(args.download, response_type="iter_content"))

    if args.exists is not None:
        print yt.exists(args.exists)

    if args.get is not None:
        print yt.get(args.get, spec=spec, format=yt.RawFormat.from_yson_string("<format=pretty>json"))
    if args.set is not None:
        if args.value is None:
            die("Value option is necessary for set command")
        yt.set(args.set, json.loads(args.value))

    if args.starttx:
        print yt.start_transaction()
    if args.committx is not None:
        yt.commit_transaction(args.committx)
    if args.aborttx is not None:
        yt.abort_transaction(args.aborttx)
    if args.renewtx is not None:
        yt.renew_transaction(args.renewtx)

    if args.ytlock is not None:
        yt.lock(args.ytlock, mode=args.mode)

    if args.track is not None:
        config.DETACHED = True
        config.KEYBOARD_ABORT = False
        yt.WaitStrategy().process_operation("unknown", args.track)

    # Set _format for exisitng destination tables
    if args.smartformat:
        output_tables = []
        if args.write is not None: output_tables.append(args.write)
        if args.writesorted is not None: output_tables.append(args.writesorted)
        if dst is not None: output_tables += dst

        for table in map(yt.to_name, output_tables):
            if yt.exists(table):
                yt.set_attribute(table, "_format", outputformat.to_json())

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        die("Shutdown requested... exiting")
    except yt.YtOperationFailedError as error:
        die(str(error))
    except yt.YtResponseError as error:
        die(str(error))
    except yt.ConnectionError as error:
        die("Connection problem: " + str(error))
    except yt.HTTPError as error:
        die("Connection was broken: " + str(error))
    except Exception:
        traceback.print_exc(file=sys.stderr)
        die()
