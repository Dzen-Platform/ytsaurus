#!/usr/bin/env python

# Options that not yet implemented:
# -fs
# -rs
# -dstsorted
# -timelimit
# -lock
# -unlock

from yt.wrapper.common import flatten, unlist, first_not_none, bool_to_string
import yt.wrapper.config as config
import yt.wrapper as yt

import os
import sys
import traceback
import simplejson as json
from argparse import ArgumentParser, RawTextHelpFormatter, REMAINDER
from operator import attrgetter
from functools import partial
from itertools import imap

def die(message=None, return_code=1):
    if message is not None:
        print >>sys.stderr, message
    if "ALWAYS_RAISE" in os.environ:
        raise
    sys.exit(return_code)

def check_prefix():
    if not "PREFIX" in config.__dict__:
        die("You should set variable YT_PREFIX or option -prefix or use absolute paths.")
    if not config.PREFIX.startswith("//"):
        die("Prefix should starts with //")
    if not config.PREFIX.endswith("/"):
        die("Prefix should ends with /")

def add_prefix(table):
    if table.startswith("//"):
        return table
    check_prefix()
    return config.PREFIX + table

def remove_prefix(table):
    if "PREFIX" in config.__dict__ and table.startswith(config.PREFIX):
        return table[len(config.PREFIX):]
    return table

def list_all_entities(type):
    check_prefix()
    tables = yt.search(config.PREFIX[:-1], type,
                       path_filter=lambda path: path.startswith(config.PREFIX))
    return sorted(map(remove_prefix, tables))

def add_eoln(str):
    return str + "\n"

def add_store_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg)
def add_bool_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action="store_true", default=False)
def add_multiple_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, action="append")

def add_integer_args(parser, args):
    for arg in flatten(args):
        parser.add_argument("-" + arg, type=int)

def add_help_message(parser, arg_name, message):
    arg_name = "-" + arg_name
    args_tuple = parser._get_option_tuples(arg_name)
    for arg in args_tuple:
        if arg[1] == arg_name:
            arg[0].help = message
            return
    assert "There is no such option"

def add_help_messages(parser, args):
    for arg, message in args:
        add_help_message(parser, arg, message)

class SortingHelpFormatter(RawTextHelpFormatter):
    def add_arguments(self, actions):
        actions = sorted(actions, key=attrgetter('option_strings'))
        super(SortingHelpFormatter, self).add_arguments(actions)

def writelines_silently(lines):
    try:
        for line in lines:
            sys.stdout.write(line)
    except IOError:
        sys.exit(1)
    except:
        raise

def get_smart_format(tables, smart_format_flag, has_subkey):
    def extract_format(table):
        table = yt.to_table(table)
        if table.specificators and table.specificators[0] == '{':
            return yt.RawFormat.from_yson("<line_prefix=tskv>dsv")
        elif yt.has_attribute(table.name, "_format"):
            return yt.RawFormat.from_tree(yt.get_attribute(table.name, "_format"))
        else:
            return None
    if not(smart_format_flag or "SMART_FORMAT" in os.environ):
        return None
    tables = flatten(filter(None, tables))
    formats = map(extract_format, tables)
    if formats and any(format != formats[0] for format in formats):
        die("Tables have different attribute _format: " + repr(formats))
    formats = filter(None, formats)
    if formats:
        # Dirty hacks :(
        if formats[0]._format in ["yamr", "yamred_dsv"]:
            formats[0]._format.attributes["has_subkey"] = bool_to_string(has_subkey)
        return formats[0]


def main():
    config.set_mapreduce_mode()

    parser = ArgumentParser(
        formatter_class=SortingHelpFormatter,
        description="Shell utility to work with YT system.\n"
                    "This utitlity is back-compatible with mapreduce for Yamr.",
        epilog=
"""
Examples:
    Append data to table with replication factor one, gzip codec and chunks of size 1Gb:
            ./mapreduce -write 'table' -replicationfactor 1 -codec 'gzip_normal' -chunksize 1073741824 -append < data

    Read 10 records from the table:
            ./mapreduce -read 'table[:#10]'

    Run operation on the range of the table:
            ./mapreduce
                -subkey
                -map 'awk '"'"'{sum+=$1+$2} END {print "\\t\\t"sum}'"'"
                -src "ignat/temp{key,subkey}[("aaa"):("zzz")]"
                -dst "ignat/sum"

    Run map-reduce operation:
            ./mapreduce
                -subkey
                -map 'grep "A"'
                -reduce 'awk '"'"'{a[$1]+=$3} END {for (i in a) {print i"\\t\\t"a[i]}}'"'"
                -src "ignat/temp"
                -dst "ignat/reduced"

    Use already uploaded files:
            ./mapreduce -upload my_mapper.py -dst ignat/mapper.py
            ./mapreduce -subkey -map "./mapper.py" -ytfile "ignat/mapper.py" -src "ignat/temp" -dst "ignat/mapped"

    Use attrbiutes:
            ./mapreduce -set "log/@my_attr"  -value 10
            ./mapreduce -get "log/@my_attr"
    It returns 10.
"""
    )

    # TODO(ignat): add unsupported arguments
    action_stores = ["read", "write", "writesorted", "map", "reduce", "reducews", "drop",
                     "erase", "aborttx", "committx", "renewtx", "set", "get", "upload", "download",
                     "createtable", "exists", "track"]
    action_flags = ["version", "copy", "sort", "merge", "list", "listfiles", "starttx"]

    add_bool_args(parser, action_flags + ["subkey", "lenval", "append", "dynallocmode", "dsv", "pingtx",
                                          "smartformat", "force", "executable"])
    add_store_args(parser, action_stores + ["server", "lowerkey", "upperkey", "prefix", "codec",
                                            "format", "inputformat", "outputformat", "tx", "value",
                                            "replicationfactor", "memlimit", "timeout"])
    add_multiple_args(parser, ["src", "dst", "dstappend", "file", "mapfile", "reducefile", "ytfile", "opt", "ytspec", "sortby", "reduceby"])
    add_integer_args(parser, ["jobcount", "threadcount", "chunksize", "jcmultiplier"])

    add_help_messages(parser,
        [
            ("aborttx",
             "NEW! abort given transaction"),
            ("append",
             "turn on append mode in write operation"),
            ("chunksize",
             "bound for the size of the chunk in write operation"),
            ("codec",
             "NEW! type of comression used while writing table, "
             "possible values 'snappy', 'lz4', 'lz4_high_compression', "
             "'gzip_normal', 'gzip_best_compression', 'quick_lz', "
             "by default value depends on yt installation."),
            ("committx",
             "NEW! commit given transaction"),
            ("copy",
             "copy given tables to one destination table"),
            ("createtable",
             "NEW! creates empty table"),
            ("download",
             "NEW! download file from given path"),
            ("drop",
             "delete given table"),
            ("dst",
             "destination table, option can be passed multiple times"),
            ("dstappend",
             "destination table in append mode, option can be passed multiple times"),
            ("dsv",
             "NEW! use delimited separated value format"),
            ("dynallocmode",
             "OLD! this option do nothing"),
            ("erase",
             "NEW! delete the table, this option supports range specifications"),
            ("exists",
             "NEW! check table for existance"),
            ("file",
             "file for both map and reduce operations"),
            ("force",
             "force removing object of any type"),
            ("get",
             "NEW! returns subtree at given path in json format"),
            ("inputformat",
             "NEW! specifies operation input format. "
             "This option has the following format: "
             "'<format options as yson map fragment>format'"),
            ("jcmultiplier",
             "OLD! this option do nothing"),
            ("jobcount",
             "specifies jobcount (only for map and reduce operations)"),
            ("lenval",
             "turn on yamr format with lenval"),
            ("list",
             "list all tables"),
            ("listfiles",
             "NEW! list all files"),
            ("lowerkey",
             "specifies lowerkey for the range in the read operation"),
            ("map",
             "specifies map operation command"),
            ("mapfile",
             "NEW! file for the map stage of mapreduce operation"),
            ("merge",
             "merge given tables"),
            ("opt",
             "OLD! this option do nothing"),
            ("outputformat",
             "NEW! specifies operation output format. "
             "This option has the following format: "
             "'<format options as yson map fragment>format'"),
            ("pingtx",
             "NEW! turn on pinging ancestor transactions"),
            ("prefix",
             "YT use tree structure to store meta information about system objects. "
             "Each path in the tree (except root) starts with '//'. "
             "Therefore, (for back compatibility purpose) we use this option as prefix "
             "for each option that means path in the tree. Default='//statbox/'"),
            ("read",
             "read given table"),
            ("reduce",
             "specifies reduce operation command"),
            ("reducefile",
             "NEW! file for the reduce stage of mapreduce operation"),
            ("reducews",
                 ""),
            ("renewtx",
             "NEW! renew given transaction"),
            ("replicationfactor",
             "NEW! specifies replication factor of tables to write"),
            ("server",
             "address of the proxy "
             "(port usually equals to 80 and can be omitted)"),
            ("set",
             "NEW! set value to given path, value should be in json format"),
            ("sort",
             "sort source tables to destination table"),
            ("sortby",
             "NEW! columns to sortby, this option can be passed multiple times. "
             "The order is important, by default=key,subkey."),
            ("reduceby",
             "NEW! columns to reduceby, this option can be passed multiple times. "
             "The order is important, by default=key."),
            ("src",
             "source table, this option can be passed multiple times"),
            ("starttx",
             "NEW! start transaction, returns transaction id"),
            ("subkey",
             "turn on yamr format with subkey"),
            ("timeout",
             "NEW! timeout for transaction"),
            ("threadcount",
             "OLD! this option do nothing"),
            ("track",
             "NEW! track operation progress"),
            ("tx",
             "NEW! perform command in the context of the given transaction"),
            ("upload",
             "NEW! upload given file to destination"),
            ("upperkey",
             "specifies upperkey for the range in the read operation"),
            ("value",
             "specifies value for set operation"),
            ("version",
             "print version"),
            ("write",
             "write stdin to given table"),
            ("writesorted",
             "write stdin to given table, holds table sorted"),
            ("ytfile",
             "NEW! specifies path to the file in YT tree for use it in current operation"),
            ("ytspec",
             "NEW! spec for given operation in json format"),
        ]
        +
        [(name, "this argument is inherited from Yandex Mapreduce and it is ignored")
         for name in ["threadcount", "jcmultiplier", "dynallocmode", "opt"]
        ]
    )

    # Ignore all positional arguments
    parser.add_argument("ignored", nargs=REMAINDER);

    args = parser.parse_args()

    actions_count = sum([vars(args)[arg] is not None for arg in action_stores]) + \
                    sum([vars(args)[arg] for arg in action_flags])
    mapreduce_case = args.map is not None and args.reduce is not None and actions_count == 2
    if actions_count != 1 and not mapreduce_case:
        die("You should pass exactly one action", 1)
    if args.version:
        die("Version: YT wrapper", 0)

    if args.chunksize is not None:
        config.WRITE_BUFFER_SIZE = args.chunksize
    if "YT_PROXY" in os.environ:
        config.PROXY = os.environ["YT_PROXY"]
    if "YT_PREFIX" in os.environ:
        config.PREFIX = os.environ["YT_PREFIX"]
    if args.server is not None:
        config.PROXY = args.server
    if args.prefix is not None:
        config.PREFIX = args.prefix

    spec = {}
    if args.jobcount is not None:
        spec.update({"job_count": args.jobcount})
    if vars(args)["ytspec"] is not None:
        for spec_arg in args.ytspec:
            spec.update(json.loads(spec_arg))

    # Fix table names
    for option in ["src", "dst", "dstappend", "ytfile"]:
        if vars(args)[option] is not None:
            vars(args)[option] = map(add_prefix, vars(args)[option])
    for option in ["read", "write", "writesorted", "drop", "get", "set", "download", "upload", "createtable"]:
        if vars(args)[option] is not None:
            vars(args)[option] = add_prefix(vars(args)[option])


    dst = []
    if args.dst is not None:
        dst += map(partial(yt.TablePath, append=args.append), args.dst)
    if args.dstappend is not None:
        dst += map(partial(yt.TablePath, append=True), args.dstappend)
    if not dst:
        dst = None

    def to_list(arg):
        if arg is None:
            return []
        else:
            return flatten(arg)
    map_files = to_list(args.file) + to_list(args.mapfile)
    reduce_files = to_list(args.file) + to_list(args.reducefile)

    config.DEFAULT_FORMAT = config.YamrFormat(lenval=args.lenval, has_subkey=args.subkey)
    if args.dsv:
        if args.lenval or args.subkey:
            die("Options subkey and lenval are mutually exclusive with dsv option")
        config.DEFAULT_FORMAT = yt.DsvFormat()

    for option in ["format", "inputformat", "outputformat"]:
        if vars(args)[option] is not None:
            vars(args)[option] = yt.RawFormat.from_yson(vars(args)[option])

    inputformat = first_not_none(
        [get_smart_format([args.src, args.read], args.smartformat, args.subkey),
         args.format,
         args.inputformat,
         config.DEFAULT_FORMAT])
    outputformat = first_not_none(
        [get_smart_format([dst, args.write], args.smartformat, args.subkey),
         args.format,
         args.outputformat,
         config.DEFAULT_FORMAT])

    if args.tx is not None:
        config.TRANSACTION = args.tx
    config.PING_ANSECTOR_TRANSACTIONS = args.pingtx

    if args.memlimit is not None:
        config.MEMORY_LIMIT = int(args.memlimit)

    table_writer = {}
    if args.codec is not None:
        table_writer["codec_id"] = args.codec
    if args.replicationfactor is not None:
        table_writer["replicationfactor"] = args.replicationfactor
        table_writer["upload_replicationfactor"] = args.replicationfactor
    if not table_writer:
        table_writer = None

    if args.list:
        writelines_silently(imap(add_eoln, list_all_entities("table")))
    if args.listfiles:
        writelines_silently(imap(add_eoln, list_all_entities("file")))
    if args.read is not None:
        writelines_silently(
            yt.read_table(
                yt.TablePath(args.read, lower_key=args.lowerkey, upper_key=args.upperkey),
                format=inputformat,
                response_type="iter_content"))
    if args.createtable is not None:
        yt.create_table(args.createtable)
    if args.write is not None:
        args.write = yt.TablePath(args.write, append=args.append)
        yt.write_table(args.write, sys.stdin, table_writer=table_writer, format=outputformat)
    if args.writesorted is not None:
        args.writesorted = yt.TablePath(args.writesorted, append=args.append)
        yt.write_table(args.writesorted, sys.stdin, table_writer=table_writer, format=outputformat)
        yt.set_attribute(args.writesorted.name, "sorted", "true")
    if mapreduce_case:
        yt.run_map_reduce(args.map, args.reduce, args.src, dst,
                          map_files=map_files, reduce_files=reduce_files,
                          map_file_paths=args.ytfile, reduce_file_paths=args.ytfile,
                          input_format=inputformat, output_format=outputformat,
                          sort_by=args.sortby, reduce_by=args.reduceby,
                          table_writer=table_writer, spec=spec)
    elif args.map is not None:
        yt.run_map(args.map, args.src, dst, files=map_files, file_paths=args.ytfile,
                   input_format=inputformat, output_format=outputformat,
                   table_writer=table_writer, spec=spec)
    elif args.reduce is not None or args.reducews is not None:
        op = args.reduce if args.reduce is not None else args.reducews
        yt.run_reduce(op, args.src, dst, files=reduce_files, file_paths=args.ytfile,
                      input_format=inputformat, output_format=outputformat,
                      reduce_by=args.reduceby,
                      table_writer=table_writer, spec=spec)
    if args.drop is not None:
        if yt.exists(args.drop):
            if not args.force and yt.get_type(args.drop) not in ["table", "file"]:
                die("You are trying to remove object of type " + yt.get_type(args.drop))
            yt.remove_with_empty_dirs(args.drop)
    if args.copy:
        yt.copy_table(args.src, unlist(dst))
    if args.sort:
        yt.sort_table(args.src, unlist(dst), table_writer=table_writer, sort_by=args.sortby, spec=spec)
    if args.merge:
        yt.merge_tables(args.src, unlist(dst), mode="sorted", table_writer=table_writer, spec=spec)

    if args.erase is not None:
        yt.erase_table(args.erase)
    if args.upload is not None:
        if yt.exists(args.upload) and yt.get_type(args.upload) == "file":
            yt.remove_with_empty_dirs(args.upload)
        yt.upload_file(sys.stdin.read(), args.upload)
        if args.executable:
            yt.set_attribute(args.upload, "executable", "true")
    if args.download is not None:
        writelines_silently(yt.download_file(args.download, response_type="iter_content"))

    if args.exists is not None:
        print yt.exists(args.exists)

    if args.get is not None:
        print json.dumps(yt.get(args.get, spec=spec), indent="  ")
    if args.set is not None:
        if args.value is None:
            die("Value option is necessary for set command")
        yt.set(args.set, json.loads(args.value))

    if args.starttx:
        print yt.start_transaction()
    if args.committx is not None:
        yt.commit_transaction(args.committx)
    if args.aborttx is not None:
        yt.abort_transaction(args.aborttx)
    if args.renewtx is not None:
        yt.renew_transaction(args.renewtx)

    if args.track is not None:
        config.KEYBOARD_ABORT = False
        yt.WaitStrategy().process_operation("unknown", args.track)

    # Set _format for exisitng destination tables
    if args.smartformat:
        output_tables = []
        if args.write is not None: output_tables.append(args.write)
        if args.writesorted is not None: output_tables.append(args.writesorted)
        if dst is not None: output_tables += dst

        for table in map(yt.to_name, output_tables):
            if yt.exists(table):
                yt.set_attribute(table, "_format", outputformat.to_json())

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        die("Shutdown requested... exiting")
    except yt.YtOperationFailedError as error:
        die(error.message)
    except yt.YtResponseError as error:
        die(error.message)
    except yt.ConnectionError as error:
        die("Connection problem: " + error.message)
    except yt.HTTPError as error:
        die("Connection was broken: " + error.message)
    except Exception:
        traceback.print_exc(file=sys.stdout)
        die()
