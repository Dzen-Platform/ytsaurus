#!/usr/bin/env python

from yt.wrapper.cli_helpers import run_main
from yt.wrapper.client import Yt
from yt.wrapper.http import get_token
from yt.common import YtError, get_value, remove_file
from yt.tools.yamr import Yamr
from yt.transfer_manager.client import TransferManager
import yt.wrapper as yt

import os
import stat
import socket
import random
import atexit
import string
import tempfile
import argparse
import subprocess
import logging
from collections import defaultdict

logger = logging.getLogger("TMChecker")

_tm_client = None

class FakeClient(object):
    pass

def init_tm_client(url, token):
    global _tm_client
    _tm_client = TransferManager(url=url, token=token)

def get_tm_client():
    return _tm_client

def configure_logger():
    logger.propagate = False
    if not logger.handlers:
        logger.addHandler(logging.StreamHandler())
    logger.handlers[0].setFormatter(logging.Formatter("%(asctime)s %(levelname)s\t%(message)s"))
    logger.setLevel(logging.INFO)

def get_src_dst_table(src_client, dst_client):
    CHARSET = string.ascii_letters + string.digits

    if src_client._type == "yt":
        src_path = src_client.create_temp_table()
        src_client.write_table(src_path, ["k\tv\n"], format=yt.YamrFormat(), raw=True)
    elif src_client._type == "yamr":
        src_path = "tmp/yt_" + "".join(random.sample(CHARSET, 7))
        src_client.write(src_path, "k\tv\n")
    else:
        raise YtError("Unsupported source client type: {0}".format(src_client._type))

    if dst_client._type == "yt":
        dst_path = dst_client.create_temp_table()
    elif dst_client._type == "yamr":
        dst_path = "tmp/yt_" + "".join(random.sample(CHARSET, 7))
    else:
        raise YtError("Unsupported destination client type: {0}".format(dst_client._type))

    return src_path, dst_path

def check_direction(src_cluster, dst_cluster, clusters_clients, availability_graph):
    logger.info("Starting direction check (from: %s, to: %s)", src_cluster, dst_cluster)

    def get_client(cluster):
        client = clusters_clients.get(cluster)
        if client is None:
            raise YtError("Check failed: cluster {0} not found".format(cluster))
        return client

    src_client, dst_client = get_client(src_cluster), get_client(dst_cluster)
    if src_client._type not in ["yt", "yamr"] or dst_client._type not in ["yt", "yamr"]:
        logger.warning("Direction from %s to %s skipped because it has non-YT and non-YAMR cluster",
                       src_cluster, dst_cluster)
        return

    try:
        src_path, dst_path = get_src_dst_table(src_client, dst_client)
    except Exception as err:
        raise YtError("Check failed during prepare step", inner_errors=[err])

    params = None
    if src_client._type == "yamr" or dst_client._type == "yamr":
        # XXX(asaitgalin): Usually userdata user has big enough quota on YAMR clusters.
        params = {"mr_user": "userdata"}

    try:
        get_tm_client().add_task(src_cluster, src_path, dst_cluster, dst_path, params=params, sync=True)
    except Exception as err:
        raise YtError("Check failed", inner_errors=[err])

    logger.info("Check successfully finished")

def get_active_transfer_manager_server_address(backend_config):
    client = Yt(**backend_config["yt_backend_options"])
    return client.get(backend_config["path"] + "/@address")

def run_process(*args, **kwargs):
    kwargs.pop("stdout", None)
    kwargs.pop("stderr", None)

    p = subprocess.Popen(*args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, **kwargs)
    out, err = p.communicate()
    if p.returncode != 0:
        raise YtError("Failed to run {0}: {1}".format(" ".join(*args), err))
    return out, err

class FilesCache(dict):
    def __init__(self, *args, **kwargs):
        super(FilesCache, self).__init__(*args, **kwargs)
        atexit.register(self.cleanup)

    def cleanup(self):
        for path in self.itervalues():
            remove_file(path, force=True)

def get_yamr_binary(options, active_tm_server_address):
    # YAMR binary is heavy. No need to download the same client for each cluster.
    if not hasattr(get_yamr_binary, "_cache"):
        get_yamr_binary._cache = FilesCache()
    if not hasattr(get_yamr_binary, "_fqdn"):
        get_yamr_binary._fqdn = socket.getfqdn()

    binary_path = options["binary"]
    if get_yamr_binary._fqdn == active_tm_server_address:
        logger.info("Running on the same host as active Transfer Manager. "
                    "Local mapreduce binaries will be used.")
        return binary_path

    local_binary_path = get_yamr_binary._cache.get(binary_path)
    if local_binary_path is not None:
        return local_binary_path

    fd, filepath = tempfile.mkstemp(prefix="mapreduce")
    os.close(fd)
    logger.info("Copying mapreduce binary from %s:%s to %s", active_tm_server_address, binary_path, filepath)
    run_process(["scp", "{0}:{1}".format(active_tm_server_address, binary_path), filepath])
    os.chmod(filepath, stat.S_IXUSR | stat.S_IRUSR | stat.S_IWUSR)

    get_yamr_binary._cache[binary_path] = filepath
    return filepath

def create_clusters_clients(backend_config, token):
    clusters = backend_config.get("clusters")
    if clusters is None:
        raise YtError("Failed to get clusters configuration from backend config")

    active_tm_server_address = get_active_transfer_manager_server_address(backend_config)

    result = {}
    for name, configuration in clusters.iteritems():
        logger.info("Preparing client for cluster %s", name)
        type_ = configuration["type"]
        options = configuration.get("options", {})

        if type_ == "yt":
            options.pop("token", None)  # Do not use token from TM backend config if present.
            result[name] = Yt(token=token, **options)
        elif type_ == "yamr":
            # Copy remote YAMR binary if necessary and use it for checks.
            options["binary"] = get_yamr_binary(options, active_tm_server_address)
            result[name] = Yamr(**options)
        else:
            result[name] = FakeClient()
            logger.warning("Check is now available only for YT and YAMR clusters. "
                           "Skipping %s cluster %s", type_, name)

        result[name]._type = type_

    return result

def get_cluster_graphs(backend_config):
    graph = backend_config.get("availability_graph")
    if graph is None:
        raise YtError("Failed to get availability graph from backend config")

    for cluster in backend_config["clusters"]:
        graph.setdefault(cluster, [])

    transposed_graph = defaultdict(list)
    for cluster in graph:
        for neighbour in graph[cluster]:
            transposed_graph[neighbour].append(cluster)

    return graph, transposed_graph

def parse_arguments():
    parser = argparse.ArgumentParser(
        description="Tool for checking Transfer Manager copy directions")

    def parse_direction(arg):
        if "~>" not in arg:
            raise argparse.ArgumentTypeError('"~>" symbol is expected in direction')
        src, dst = map(lambda s: s.strip(), arg.split("~>"))
        if not src and not dst:
            raise argparse.ArgumentTypeError(
                'Direction is expected to have at least one cluster name and cannot be only "~>"')
        return src, dst

    parser.add_argument("direction", nargs="*", type=parse_direction,
                        help='Direction to check. Specified with "cluster1~>cluster2" notation. '
                             'Also "~>cluster" and "cluster~>" notations can be used to check '
                             'all available directions to and from cluster. Can be specified '
                             'multiple times.')

    parser.add_argument("--url", help="Transfer Manager url")
    parser.add_argument("--token", help="YT token. Detected by general rules if not specified.")

    return parser.parse_args()

def main():
    configure_logger()
    args = parse_arguments()

    token = get_value(args.token, get_token())
    init_tm_client(args.url, token)

    backend_config = get_tm_client().get_backend_config()
    clusters_clients = create_clusters_clients(backend_config, token)
    graph, transposed_graph = get_cluster_graphs(backend_config)

    if not args.direction:
        # Check all available directions.
        for cluster in graph:
            for neighbour in graph[cluster]:
                try:
                    check_direction(cluster, neighbour, clusters_clients, graph)
                except:
                    logger.exception("Check from %s to %s failed", cluster, neighbour)
        return

    for src_cluster, dst_cluster in args.direction:
        if src_cluster and dst_cluster:
            if dst_cluster not in graph[src_cluster]:
                raise YtError("Check failed: cluster {0} is not available from {1}"
                              .format(dst_cluster, src_cluster))
            check_direction(src_cluster, dst_cluster, clusters_clients, graph)
        elif src_cluster and not dst_cluster:
            for neighbour in graph[src_cluster]:
                check_direction(src_cluster, neighbour, clusters_clients, graph)
        else:
            for neighbour in transposed_graph[dst_cluster]:
                check_direction(neighbour, dst_cluster, clusters_clients, graph)

if __name__ == "__main__":
    run_main(main)
