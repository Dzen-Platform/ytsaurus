#!/usr/bin/env python

from __future__ import print_function
import sys

from yt.wrapper.native_driver import get_driver_instance

from argparse import ArgumentParser

def build_snapshot(*args, **kwargs):
    print(get_driver_instance(None).build_snapshot(*args, **kwargs))

def gc_collect(*args, **kwargs):
    get_driver_instance(None).gc_collect(*args, **kwargs)

def kill_process(*args, **kwargs):
    print('NB: If process was actually killed, there should be a "Socket was closed" below\n', file=sys.stderr)
    get_driver_instance(None).kill_process(*args, **kwargs)

def clear_metadata_caches(*args, **kwargs):
    get_driver_instance(None).clear_metadata_caches(*args, **kwargs)

def main():
    parser = ArgumentParser(description="Script to run some administer stuff directly through driver")
    subparsers = parser.add_subparsers(metavar="command")
    subparsers.required = True

    build_snapshot_parser = subparsers.add_parser("build-snapshot", help="Build snapshot")
    build_snapshot_parser.set_defaults(func=build_snapshot)
    build_snapshot_parser.add_argument("--set-read-only", action="store_true", default=False)
    build_snapshot_parser.add_argument("--cell-id", required=True)

    gc_collect_parser = subparsers.add_parser("gc-collect", help="Run garbage collection")
    gc_collect_parser.set_defaults(func=gc_collect)

    kill_process_parser = subparsers.add_parser("kill-process", help="Force remote YT process (node, scheduler or master) " +
                                                                     "listening to a given address exit immediately, use with care. " +
                                                                     "This command always finishes with an error")
    kill_process_parser.add_argument("address")
    kill_process_parser.set_defaults(func=kill_process)

    clear_metadata_caches_parser = subparsers.add_parser("clear-caches", help="Clear metadata caches")
    clear_metadata_caches_parser.set_defaults(func=clear_metadata_caches)

    args = parser.parse_args()
    func_args = dict(vars(args))
    func_args.pop("func")
    args.func(**func_args)

if __name__ == "__main__":
    main()
