#!/usr/bin/env python

from yt.local import start, stop, delete, get_proxy, list_instances
from yt.local.helpers import YTCheckingThread

from yt.wrapper.cli_helpers import run_main
from yt.wrapper.keyboard_interrupts_catcher import KeyboardInterruptsCatcher

import argparse
import logging
import time

DESCRIPTION = """Command-line utility to work with local YT instances."""

logger = logging.getLogger("Yt.local")

def fix_parser(parser):
    old_add_argument = parser.add_argument

    def add_argument(*args, **kwargs):
        help = [kwargs.get("help", "")]
        if "default" in kwargs:
            default = str(kwargs["default"])
            help.append(" (default: {0})".format(default))
        kwargs["help"] = "".join(help)
        old_add_argument(*args, **kwargs)

    parser.add_argument = add_argument
    return parser

def patch_add_parser(subparsers):
    old_add_parser = subparsers.add_parser

    def add_parser(*args, **kwargs):
        func = kwargs.get("func", None)
        if func is not None:
            kwargs.pop("func")
        parser = fix_parser(old_add_parser(*args, **kwargs))
        if func is not None:
            parser.set_defaults(func=func)
        return parser

    subparsers.add_parser = add_parser

def start_func(**kwargs):
    sync = kwargs.get("sync", False)
    kwargs.pop("sync")
    quiet = kwargs.get("quiet", False)
    kwargs.pop("quiet")
    no_proxy = kwargs.get("no_proxy", False)
    kwargs.pop("no_proxy")
    kwargs["start_proxy"] = not no_proxy

    if quiet:
        logger.setLevel(logging.WARNING)
    else:
        logger.setLevel(logging.INFO)

    environment = start(**kwargs)

    if sync:
        if quiet:
            print environment.id

        checking_thread = YTCheckingThread(environment, delay=2)
        checking_thread.start()

        def interrupt_action():
            logger.info("Stopping environment...")
            checking_thread.stop()
            environment.clear_environment()

        with KeyboardInterruptsCatcher(interrupt_action):
            while True:
                time.sleep(2.5)
    else:
        print environment.id

def add_start_subparser(subparsers):
    parser = subparsers.add_parser("start", help="Start local YT environment with specified options",
                                   func=start_func)
    parser.add_argument("--masters-count", type=int, default=1, help="masters count")
    parser.add_argument("--nodes-count", type=int, default=3, help="nodes count")
    parser.add_argument("--schedulers-count", type=int, default=1, help="schedulers count")

    for service in ["master", "node", "scheduler", "proxy"]:
        parser.add_argument("--{0}-config".format(service), help="{0} config path".format(service))

    parser.add_argument("--sync", action="store_true", default=False,
                        help="start in synchronized mode (hangs up console and prints info there)")
    parser.add_argument("--id", help="local YT id (guid will be generated if not specified)")
    parser.add_argument("--local-cypress-dir", help="local Cypress directory (map_nodes and tables will be created in "
                                                    "Cypress according to this directory layout)")

    parser.add_argument("-q", "--quiet", action="store_true", default=False,
                        help="decrease verbosity (leave only warnings and errors)")

    parser.add_argument("--use-proxy-from-yt-source", action="store_true", default=False,
                        help="Do not start proxy from package, start from YT source tree using run_proxy.sh. "
                             "Can be specified through YT_LOCAL_USE_PROXY_FROM_SOURCE.")
    parser.add_argument("--no-proxy", action="store_true", default=False, help="do not start proxy")
    parser.add_argument("--proxy-port", type=int, help="proxy port for http requests")
    parser.add_argument("--enable-debug-logging", action="store_true", default=False,
                        help="set logging level threshold to DEBUG")
    parser.add_argument("--tmpfs-path", help="path to mounted tmpfs. "
                                             "Will be used to store performance critical parts.")
    parser.add_argument("--ports-range-start", type=int,
                        help="assign ports from continuous range starting from this port number.")
    parser.add_argument("--fqdn", help="FQDN to use in all addresses. Detected automatically if not specified.")

def add_stop_subparser(subparsers):
    parser = subparsers.add_parser("stop", help="Stop local YT with given id", func=stop)
    parser.add_argument("id", help="local YT id")
    parser.add_argument("--delete", help="remove working directory after stopping", action="store_true",
                        dest="remove_working_dir")

def add_delete_subparser(subparsers):
    parser = subparsers.add_parser("delete", help="Delete stopped local YT working directory.",
                                   func=delete)
    parser.add_argument("id", help="local YT id")

def get_proxy_func(**kwargs):
    print get_proxy(**kwargs)

def add_get_proxy_subparser(subparsers):
    parser = subparsers.add_parser("get_proxy", help="Get proxy address for local YT with given id",
                                   func=get_proxy_func)
    parser.add_argument("id", help="local YT id")

def print_instances(**kwargs):
    for instance_id, status, proxy_address in list_instances(**kwargs):
        if status == "running":
            if proxy_address is None:
                print "{0}\tstatus: {1}\tproxy: not started".format(instance_id, status)
            else:
                print "{0}\tstatus: {1}\tproxy: {2}".format(instance_id, status, proxy_address)
        else:
            print "{0}\tstatus: {1}".format(instance_id, status)

def add_list_subparser(subparsers):
    subparsers.add_parser("list", help="List local YT instances", func=print_instances)

def main():
    options_parser = argparse.ArgumentParser(add_help=False)
    options_parser.add_argument("--path", help="local YTs root path, can be specified "
                                               "with YT_LOCAL_ROOT_PATH variable")

    parser = argparse.ArgumentParser(parents=[options_parser],
                                     description=DESCRIPTION)

    subparsers = parser.add_subparsers(metavar="command")
    patch_add_parser(subparsers)

    add_start_subparser(subparsers)
    add_stop_subparser(subparsers)
    add_delete_subparser(subparsers)
    add_get_proxy_subparser(subparsers)
    add_list_subparser(subparsers)

    options, remaining_args = options_parser.parse_known_args()
    args = parser.parse_args(remaining_args)

    func_args = dict(vars(args))
    func_args.update(vars(options))

    func_args.pop("func")
    args.func(**func_args)

if __name__ == "__main__":
    run_main(main)

