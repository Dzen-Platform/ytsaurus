package NYP.NClient.NNodes.NProto;

import "yp/client/api/proto/data_model.proto";
import "yp/client/api/proto/enums.proto";
import "yp/client/api/proto/secrets.proto";
import "yp/client/api/proto/dynamic_attributes.proto";
import "yp/client/api/proto/host_infra.proto";
import "yp/client/api/proto/conditions.proto";
import "yp/client/api/proto/persistent_volume.proto";

import "yt/core/misc/proto/error.proto";

import "google/protobuf/any.proto";

option java_package = "ru.yandex.yp.client.nodes";
option java_outer_classname = "NodeTracker";

////////////////////////////////////////////////////////////////////////////////

message TReqHandshake
{
    // Id (==fqdn) of the node.
    required string node_id = 1;

    // GRPC address of AgentService.
    required string address = 2;

    // Agent version.
    // COMPAT(babenko): make required
    optional string version = 3;
}

message TRspHandshake
{
    // Unique (and opaque) epoch id.
    required string epoch_id = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TPodStatus
{
    oneof payload
    {
        // COMPAT(babenko): A YP-opaque ISS-compatible pod status exposed via status/iss_payload attribute.
        bytes iss_payload = 1;
        NYP.NClient.NApi.NProto.TPodStatus.TAgent.TPodAgentPayload pod_agent_payload = 4;
    }

    // The current state of POD's FSM at the agent.
    // COMPAT(babenko): this is deprecated and moved to TReqHeartbeat.TPodEntry
    optional NYP.NClient.NApi.NProto.EPodCurrentState current_state = 2;

    // If given, contains the error occurred during pod lifecycle at agent.
    optional NYT.NProto.TError execution_error = 3;

    // List of validation errors for latest pod spec.
    // May be non-empty even if payload field is set if the agent is maintaining an older valid version.
    repeated string validation_failures = 5;
}

message TPodSpec
{
    oneof payload
    {
        // COMPAT(babenko): A YP-opaque ISS-compatible pod spec configured via spec/iss_payload attribute.
        bytes iss_payload = 1;
        NYP.NClient.NApi.NProto.TPodSpec.TPodAgentPayload pod_agent_payload = 9;
    }

    message TProperty
    {
        required string key = 1;
        required string value = 2;
    }

    // Passed as-is to Porto.
    repeated TProperty porto_properties = 2;

    // Controls pod state transitions.
    // If target_state == ETargetState.Removed and current_state == ECurrentState.Stopped then
    // the master is allowed to forget about the pod and stop passing it in heartbeat responses.
    // COMPAT(babenko): this is deprecated and moved to TRspHeartbeat.TPodEntry
    optional NYP.NClient.NApi.NProto.EPodTargetState target_state = 3;

    // The following section of fields contains values obtained from pod spec/status.
    optional NYP.NClient.NApi.NProto.TPodSpec.TResourceRequests resource_requests = 13;

    repeated NYP.NClient.NApi.NProto.TPodSpec.TIP6AddressRequest ip6_address_requests = 4;
    repeated NYP.NClient.NApi.NProto.TPodStatus.TIP6AddressAllocation ip6_address_allocations = 5;

    repeated NYP.NClient.NApi.NProto.TPodSpec.TIP6SubnetRequest ip6_subnet_requests = 6;
    repeated NYP.NClient.NApi.NProto.TPodStatus.TIP6SubnetAllocation ip6_subnet_allocations = 7;

    optional NYP.NClient.NApi.NProto.TPodStatus.TDns dns = 8;

    // TODO(babenko): rename to transient_volume_allocations
    repeated NYP.NClient.NApi.NProto.TPodStatus.TDiskVolumeAllocation disk_volume_allocations = 10;

    message TPersistentVolumeMount
    {
        // UUID of the volume; this either refers to the existing volume reported by the node
        // or to the volume whose creation is requested in the same heartbeat.
        required string volume_uuid = 1;

        // TODO(babenko): rename TDiskVolumeAllocation.id to name.
        // Altogether, TDiskVolumeAllocation.id and TPersistentVolumeMount.name are pod-wise unique
        // and enable addressing volumes (both transient and persistent) within a pod.
        required string name = 2;
    }
    repeated TPersistentVolumeMount persistent_volume_mounts = 19;

    repeated NYP.NClient.NApi.NProto.TPodStatus.TGpuAllocation gpu_allocations = 16;

    message TNetworkAllocation
    {
        optional uint64 tx_bandwidth_guarantee = 1;
        optional uint64 tx_bandwidth_limit = 2;
        optional uint64 rx_bandwidth_limit = 3;
    }
    optional TNetworkAllocation network_allocation = 17;

    // Contains (raw, unencrypted) secrets to be injected into the pod.
    // These are obtained via TVM magic from secret descriptors provided in /pod/spec/secrets.
    repeated NYP.NClient.NApi.NProto.TSecret secrets = 11;

    // Contains dynamic attributes extracted from pod's metadata.
    optional NYP.NClient.NApi.NProto.TDynamicAttributes pod_dynamic_attributes = 12;

    // Resource cache for the pod.
    optional NYP.NClient.NApi.NProto.TPodSpec.TPodAgentResourceCache resource_cache = 14;

    optional NYP.NClient.NApi.NProto.THostInfraInfo host_infra = 15;

    // Host capability names.
    // http://man7.org/linux/man-pages/man7/capabilities.7.html
    repeated string capabilities = 18;
}

message TPersistentVolumeSpec
{
    message TManagedPolicy
    {
        // Volume capacity, in bytes.
        required uint64 capacity = 1;

        // Guaranteed volume read bandwidth in bytes per second.
        optional uint64 read_bandwidth_guarantee = 3;

        // Volume read bandwidth limit in bytes per second.
        optional uint64 read_bandwidth_limit = 4;

        // Guaranteed volume write bandwidth in bytes per second.
        optional uint64 write_bandwidth_guarantee = 5;

        // Volume write bandwidth limit in bytes per second.
        optional uint64 write_bandwidth_limit = 6;

        // Guaranteed volume read operation rate in operations per second.
        optional uint64 read_operation_rate_guarantee = 7;

        // Volume read operation rate limit in operations per second.
        optional uint64 read_operation_rate_limit = 8;

        // Guaranteed volume write operation rate in operations per second.
        optional uint64 write_operation_rate_guarantee = 9;

        // Volume write operation rate limit in operations per second.
        optional uint64 write_operation_rate_limit = 10;
    }

    message TRbindPolicy
    {
        // Path to volume data on host FS.
        required string mount_path = 1;
    }

    oneof concrete_policy
    {
        TManagedPolicy managed_policy = 1;
        TRbindPolicy rbind_policy = 2;
    }
}

message TPersistentDiskStatus
{
    // Currently empty.
}

message TPersistentVolumeStatus
{
    required NYP.NClient.NApi.NProto.EPersistentVolumeState state = 1;

    // If given, contains the error occurred during volume lifecycle at agent.
    optional NYT.NProto.TError execution_error = 2;

    // List of validation errors for latest volume spec.
    repeated string validation_failures = 3;
}

message TReqHeartbeat
{
    message TPodEntry
    {
        // Unique (and opaque) pod id.
        required string pod_id = 1;

        // Describes pod spec timestamp known to the agent.
        // If this is missing or corresponds to an outdated spec, the master will send an update.
        optional uint64 spec_timestamp = 2;

        // Timestamp of a spec currently considered as target.
        optional uint64 current_spec_timestamp = 6;

        // Whether current spec is applied completely.
        optional NYP.NClient.NApi.NProto.TCondition current_spec_applied = 7;

        // If present, requests the master to update pod status.
        // The agent is encouraged to leave this null if no status change happens since last successful heartbeat.
        optional TPodStatus status = 4;

        // The current state of POD's FSM at the agent.
        // COMPAT(babenko): mark as required
        optional NYP.NClient.NApi.NProto.EPodCurrentState current_state = 5;
    }

    message TPersistentDiskEntry
    {
        // Current disk status.
        // If missing then no changes happened since the last successful heartbeat.
        optional TPersistentDiskStatus status = 1;
    }

    message TPersistentVolumeEntry
    {
        // Id of PersistentDisk object indicating the disk where the volume resides.
        required string disk_id = 1;

        // Timestamp of the current spec.
        required uint64 current_spec_timestamp = 4;

        // Current volume status.
        // If missing then no changes happened since the last successful heartbeat.
        optional TPersistentVolumeStatus status = 5;
    }

    // The id of the node issuing the request; cf. TRspHeartbeat.node_id.
    required string node_id = 1;

    // The epoch id; cf. TRspHeartbeat.epoch_id.
    required string epoch_id = 2;

    // Must start from 1 and increase monotonically with each heartbeat (either successful or not).
    required uint64 sequence_number = 3;

    // All pods currently residing on this node together with their statuses.
    // Some status payloads may be missing (if the agent has no relevant changes)
    // but all pod IDs must be listed.
    repeated TPodEntry pods = 4;

    // Indicates that the agent supports persistent volumes.
    // Attempting to create a volume on a node lacking this feature will be detected and logged as an error.
    optional bool supports_persistent_volumes = 7;

    // All persistent disks currently attached to this node.
    // Keys are disk IDs.
    map<string, TPersistentDiskEntry> persistent_disks = 5;

    // All persistent volumes found on disks currently attached to this node.
    // Keys are volume UUIDs.
    map<string, TPersistentVolumeEntry> persistent_volumes = 6;
}

message TRspHeartbeat
{
    message TPodEntry
    {
        // Unique (and opaque) pod id.
        required string pod_id = 1;

        // Describes pod spec timestamp known to the master.
        // The agent is expected to be passing this timestamp in TPodStatus upon subseqent heartbeats
        // to minimize master-to-agent traffic.
        // The agent is also expected to silently drop spec update requests with revisions
        // less than the current one.
        // If this is null then the agent must unconditionally accept spec update.
        // This is useful for forcing removal of pods.
        optional uint64 spec_timestamp = 2;

        // If present, requests the needed pod spec updates.
        // In particular, this is always present when the pod is first started.
        optional TPodSpec spec = 3;

        // Controls pod state transitions.
        // If target_state == ETargetState.Removed and current_state == ECurrentState.Stopped then
        // the master is allowed to forget about the pod and stop passing it in heartbeat responses.
        // TODO(babenko): mark as required
        optional NYP.NClient.NApi.NProto.EPodTargetState target_state = 4;
    }

    message TPersistentVolumeCreationRequest
    {
        // Disk id where the volume must be created.
        required string disk_id = 1;

        // Timestamp of volume spec at the moment of creation.
        required uint64 spec_timestamp = 3;

        // Spec of the newly created volume.
        required TPersistentVolumeSpec spec = 4;
    }

    message TPersistentVolumeRemovalRequest
    {
        // Currently empty.
        // May indicate some specific destruction strategy in the future.
    }

    message TPersistentVolumeUpdateRequest
    {
        // Timestamp of volume spec at the moment of update.
        required uint64 spec_timestamp = 2;

        // New spec to apply.
        required TPersistentVolumeSpec spec = 3;
    }

    // Describes all pods that are expected to be present at the node.
    // If the node has some pod that is missing in this list, the pod must be dropped.
    // If the node does not have some pod that is present in this list, the pod must be started.
    // Otherwise (for those pods that are both present at the node and in this list)
    // some spec updates may be needed.
    repeated TPodEntry pods = 1;

    message TNodeEntry
    {
        // Requests the CPU spec updates.
        optional NYP.NClient.NApi.NProto.TResourceSpec.TCpuSpec cpu = 1;
    }

    // Describes the data updated on the node.
    optional TNodeEntry node = 2;

    // Instructs the node to create certain persistent volumes.
    // Keys are volume UUIDs.
    // Upon receiving the request, node must start reporting this volume in "creating" state.
    // Once creation is complete, the volume state must change to "active".
    // Master continues sending these requests for all to-be-created volumes until
    // it receives a heartbeat within which a volume with the matching id is present.
    map<string, TPersistentVolumeCreationRequest> persistent_volume_creation_requests = 3;

    // Instructs the node to remove certain persistent volumes.
    // Keys are volume UUIDs.
    // Upon receiving the request, node must change the volume state to "removing".
    // Once removal is complete, the volume must vanish from TReqHeartbeat.persistent_volumes.
    // Master continues sending these requests for all to-be-removed volumes until
    // it receives a heartbeat within which no volume with the matching id is present.
    map<string, TPersistentVolumeRemovalRequest> persistent_volume_removal_requests = 4;

    // Instructs the node to update certain persistent volumes.
    // Keys are volume UUIDs.
    // Upon receiving the request, node must change the volume state to "updating".
    // Once update is complete, the state must change to "active".
    // Master continues sending these requests for all to-be-updated volumes until
    // it receives a heartbeat within which a volume with the matching id and spec timestamp
    // is mentioned.
    map<string, TPersistentVolumeUpdateRequest> persistent_volume_update_requests = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetHostSpec
{
    // Id (==fqdn) of the node.
    required string node_id = 1;
}

message TRspGetHostSpec
{
    // Spec retrieved from /node/spec/host_manager.
    required google.protobuf.Any spec = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqSetHostStatus
{
    // Id (==fqdn) of the node.
    required string node_id = 1;

    // Status to push to /node/status/host_manager.
    required google.protobuf.Any status = 2;
}

message TRspSetHostStatus
{ }

////////////////////////////////////////////////////////////////////////////////

// Node-to-master communication.
// The caller must be providing proper SSL credentials with each call.
service NodeTrackerService
{
    // Called by Node Agent once upon initialization to establish the connection
    // and obtain the node id.
    rpc Handshake (TReqHandshake) returns (TRspHandshake);

    // Called by Node Agent periodically to notify the master about pod status changes and
    // to request pod spec updates.
    rpc Heartbeat (TReqHeartbeat) returns (TRspHeartbeat);

    // Called by Host Manager to retrieve the host spec from DB.
    rpc GetHostSpec (TReqGetHostSpec) returns (TRspGetHostSpec);

    // Called by Host Manager to push the host status to DB.
    rpc SetHostStatus (TReqSetHostStatus) returns (TRspSetHostStatus);
}

////////////////////////////////////////////////////////////////////////////////
