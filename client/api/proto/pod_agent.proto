syntax = "proto3";

option java_package = "ru.yandex.yp.client.pods";
option java_outer_classname = "Pod";

package NInfra.NPodAgent.API;

import "google/protobuf/timestamp.proto";
import "yt/core/yson/proto/protobuf_interop.proto";

option (NYT.NYson.NProto.derive_underscore_case_names) = true;

//TODO: itype (labels)
//TODO: coredump probabilty

// Конфигурация Пода, передаваемая в Pod-agent.
// NOTE: сущности верхнего уровня имеют уникальные в рамках Пода идентификаторы (поле Id)
// и могут ссылаться друг на друга по этим идентификаторам (поля *Refs)
// NOTE: Валидация - нет висячих ссылок
// NOTE: Валидация - на каждый Workload ссылается ровно один MutableWorkload, нет ссылок из MutableWorkload на несуществующие Workload
message TPodAgentSpec {
    //pod revision, server-side монотонно возрастаюшая последовательность
    uint32 Revision = 1;

    //идентификатор пода
    string Id = 2;

    //Слои и ресурсы, которые необходимо скачать в рамках лимитов @see ResourceGang
    TResourceGang Resources = 3;

    //Все вольюмы
    repeated TVolume Volumes = 4;

    //Все workload, изменение любого поля приводит к рестарту @see MutableWorkloads
    repeated TWorkload Workloads = 5;

    //Все окружения, в которых могут быть запущены Workloads
    repeated TBox Boxes = 8;

    //Часть Workload, изменение которой не приведет к полной пересборке Workload
    repeated TMutableWorkload MutableWorkloads = 9;
}

// Кэш ресурсы, которые надо скачать на под
// Хеш ресурса считается как hash(Url, Checksum), т.е. он не зависит от Id/Revision/Meta/CheckPeriodMs/..
// Если в спеке пода окажется layer или ресурс, у которого совпал хеш с каким-то ресурсом из кэша,
// то этот ресурс не будет закачиваться заново, а просто подставится из кэша
// NOTE: Для всех TResource с одинаковым хешом выбирается минимальное из времен TVerification::CheckPeriodMs,
// т.е. если в спеку пода придет TResource, который лежит в кэше, но его период верификации меньше
// периода верификации кэш ресурса, этот ресурс начнет верифицироваться с меньшим периодом
// NOTE: Валидация - сущности имеют уникальные в рамках пода идентификаторы (Пара Id, Revision)
message TPodAgentResourceCacheSpec {
    // Кэш слои
    repeated TCacheLayer Layers = 1;

    // Кэш ресурсы
    repeated TCacheResource StaticResources = 2;
}

// Текущее состояние Пода, возвращаемое из Pod-agent
message TPodAgentStatus {
    //последняя известная pod revision
    uint32 Revision = 1;

    //идентификатор пода
    string Id = 2;

    // Момент отправки сообщения с агента
    uint64 HostTimestamp = 3;

    repeated TVolumeStatus Volumes = 4;

    TResourceGangStatus ResourceGang = 5;

    repeated TWorkloadStatus Workloads = 6;

    repeated TBoxStatus Boxes = 7;
    // Если хотя бы один из Ready вложенных T*Status имеет Status == EConditionStatus_UNKNOWN,
    // обращается в EConditionStatus_UNKNOWN.
    // Иначе, если хотя бы один из них имеет Status == EConditionStatus_FALSE,
    // обращается в EConditionStatus_FALSE.
    // Иначе обращается в EConditionStatus_TRUE.
    // LastTransitionTime -- максимальное значение Ready.LastTransitionTime среди всех вложеных T*Status
    TCondition Ready = 8;
    // Если хотя бы один из InProgress вложенных T*Status имеет Status == EConditionStatus_UNKNOWN,
    // обращается в EConditionStatus_UNKNOWN.
    // Иначе, если хотя бы один из них имеет Status == EConditionStatus_TRUE,
    // обращается в EConditionStatus_TRUE.
    // Иначе обращается в EConditionStatus_FALSE.
    // LastTransitionTime -- максимальное значение InProgress.LastTransitionTime среди всех вложеных T*Status
    TCondition InProgress = 9;

    TResourceGangStatus ResourceCache = 10;
}

//============================== SPEC ==========================
message TComputeResources {
    reserved 1;

    // Ограничения по CPU, в виртуальных миллиядрах (vcpu). Тем самым, заказав vcpu = 1000, мы получим одно виртуальное ядро.
    uint64 VCpuGuarantee = 2;
    uint64 VCpuLimit = 3;

    // Ограничения по памяти, в байтах
    uint64 MemoryGuarantee = 4;
    uint64 MemoryLimit = 5;
    uint64 AnonymousMemoryLimit = 6;
}

// Проверки целостности ресурса
message TVerification {
    // Контрольная сумма, формат <схема>:<значение> Поддерживаемые схемы "MD5:", "EMPTY:"  "SHA256:" - case sensitive
    string Checksum = 1;

    // Периодичность проверки контрольной суммы. Первая проверка выполняется сразу после завершения скачивания.
    //TODO: добавить валидацию минимального значения периода проверки
    uint64 CheckPeriodMs = 2;
}

message TSandboxResource {
    string TaskType = 1;
    string TaskId = 2;
    string ResourceType = 3;
    string ResourceId = 4;
}

message TResourceMeta {
    oneof Meta {
        TSandboxResource SandboxResource = 2;
    }
}

message TResource {
    string Id = 1; // Уникальное имя ресурса (в рамках pod'а). Должно состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)

    //не нужно для Pod-agent
    TResourceMeta Meta = 2; // Мета информация о ресурсе, необходимо для интеграции с CI/CD

    //@see TVerification
    TVerification Verification = 3;

    // URL для скачивания, протоколы: http, https, rbtorrent
    // Для записи строчки в файл URL должен быть равен "raw:<строка>"
    string Url = 4;

    //TODO: not implemented
    oneof StorageRef {
        bool DefaultStorage = 5;
        string FileStorageRef = 6; //Указатель на файловый сторедж
    }
}

message TCacheResource {
    // Ревизия кэш ресурса
    uint32 Revision = 1;

    TResource Resource = 2;
}

message TLayer {
    reserved 2;

    // Уникальный идентификатор (произвольная строка)
    string Id = 1;

    //не нужно для Pod-agent
    TResourceMeta Meta = 3; // Мета информация о ресурсе, необходимо для интеграции с CI/CD

    // Контрольная сумма, формат <схема>:<значение> Поддерживаемые схемы "MD5:", "EMPTY:"  "SHA256:" - case sensitive
    string Checksum = 4;

    // URL для скачивания, протоколы: http, https, rbtorrent
    // Для записи строчки в файл URL должен быть равен "raw:<строка>"
    string Url = 5;
}

message TCacheLayer {
    // Ревизия кэш слоя
    uint32 Revision = 1;

    TLayer Layer = 2;
}

enum EVolumeMountMode {
    EVolumeMountMode_READ_ONLY = 0 [(NYT.NYson.NProto.enum_value_name) = "read_only"];
    EVolumeMountMode_READ_WRITE = 1 [(NYT.NYson.NProto.enum_value_name) = "read_write"];
}

//Позволяет монитровать один вольюм в разные mountPoint
message TMountedVolume {
    //id Volume который требуется подмонтировать
    string VolumeRef = 1;
    // точка монтирования
    string MountPoint = 2;
    //ro, rw
    EVolumeMountMode Mode = 3;
}

message TMountedStaticResource {
    // id Resource который требуется подмонтировать
    string ResourceRef = 1;
    // точка монтирования
    string MountPoint = 2;
}

message TRootfsVolume {
    // Квота на размер
    uint64 QuotaBytes = 1;

    // Слои, из которых собирается volume
    // как и в porto, слои идут в порядке top-layer;...;bottom-layer
    //NOTE: Валидация ids в списке должны быть уникальные
    repeated string LayerRefs = 4;
}

message TFileStorage {
    // Квота на размер
    // NOTE: не обрабатывается - porto не умеет во вложенные квоты по диску
    uint64 QuotaBytes = 1;
}

message TGenericVolume {
    reserved 1,2,3;

    // Квота на размер
    // NOTE: не обрабатывается - porto не умеет во вложенные квоты по диску
    uint64 QuotaBytes = 5;

    // Слои, из которых собирается volume
    //NOTE: Валидация ids в списке должны быть уникальные
    repeated string LayerRefs = 4;
}

message TVolume {
    string Id = 1; // Уникальный в рамках pod идентификатор Volume. Должен состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)

    oneof Volume {
        TFileStorage Storage = 3; // TODO: not implemented
        TGenericVolume Generic = 4;
    }
}

// Ограничения на время исполнения и интервал между запусками хука.
// Все времена в миллисекундах, однако времена, возвращаемые porto,
// имеют точность до секунды.
// Поэтому все значения будут округляться вверх до секунд.
// maxExecutionTimeMs - ограничение на время выполнения.
// Интервал между запусками рассчитывается по формуле
// min(maxRestartPeriodMs, minRestartPeriodMs + restartPeriodScaleMs * (restartPeriodBackoff ^ step))
// step считается с 0 и равен max(0, ConsecutiveFailuresCounter - 1) для workload stop
// и max(0, ConsecutiveSuccessesCounter - 1) для всех остальных хуков
message TTimeLimit {
    uint64 InitialDelayMs = 1;
    uint64 RestartPeriodScaleMs = 2;
    uint64 RestartPeriodBackOff = 3;
    // Следующие поля должны быть > 0
    uint64 MaxRestartPeriodMs = 4;
    uint64 MinRestartPeriodMs = 5;
    uint64 MaxExecutionTimeMs = 6;
}

message TTimeLimitStatus {
    google.protobuf.Timestamp LastCallTime = 1;
    uint32 ConsecutiveSuccessesCounter = 2;
    uint32 ConsecutiveFailuresCounter = 3;
}

// Id секрета из TPodAgentRequest.Secrets
// Alias секрета из TPodAgentRequest.Secrets
// В момент обработки спеки будет добавлена переменная окружения с значением равным value секрета
message SecretEnvSelector {
    string Id = 1;

    string Alias = 2;
}

message LiteralEnvSelector {
    string Value = 1;
}

message TEnvVarValue {
    oneof Value {
        SecretEnvSelector SecretEnv = 2;
        LiteralEnvSelector LiteralEnv = 3;
    }
}

message TEnvVar {
    string Name = 1;
    TEnvVarValue Value = 2;
}

enum EWorkloadTargetState {
    EWorkloadTarget_ACTIVE = 0 [(NYT.NYson.NProto.enum_value_name) = "active"];
    EWorkloadTarget_REMOVED = 1 [(NYT.NYson.NProto.enum_value_name) = "removed"];
}

message TWorkload {
    reserved 2,4,10;

    // уникальный в рамках pod идентификатор Workload. Должeн состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string Id = 1;

    //Указатель на Box, в котором надо запускаться
    string BoxRef = 8;

    //Переменные окружения - прокидываются во все контейнеры ворклода
    repeated TEnvVar Env = 5;

    //Набор команд, запускаемых перед стартом основного процесса.
    //Гарантируется, что каждая отработает at least once.
    //Если команда падает - она перезапускается до победного
    repeated TUtilityContainer Init = 3;

    // Описание основного процесса
    TUtilityContainer Start = 11;

    //В случае возврата 0 - workload переходит в состояние ACTIVE, в других случаях SEMI_FAILED
    //Нет такого кода возврата status hook, при котором контейнер будет убит
    //Это соответствет текущему поведению instaceCTL и qloudinit
    //     https://wiki.yandex-team.ru/jandekspoisk/sepe/instancectl/#ortho-tags
    //     https://docs.platform.yandex-team.ru/doc/component#status_hook
    // Если это поведение поменять сделать миграцию автоматической будет сложнее
    // Если пользователь хочет пробпросить кастомный стуктурированный status, то рекомендуемое место для этого
    // stdout этого хука
    TReadinessCheck ReadinessCheck = 6;

    //В случае ненулевого возврата - workload убивается и переходит в состояние DEACTIVATED_BY_LIVENESS
    TLivenessCheck LivenessCheck = 9;

    TStopPolicy StopPolicy = 7;

    TDestroyPolicy DestroyPolicy = 12;
}

// Mutable поля Workload
message TMutableWorkload {
    // Ссылка на workload
    string WorkloadRef = 1;

    EWorkloadTargetState TargetState = 2;
}

// При переводе TMutableWorkload.TargetState в состояние REMOVED или обновления ревизии workload или любой его зависимости
// будет вызван stop hook, который должен выполнить gracefully завершение контейнера start
// Если после завершения stop hook контейнер start находится в состоянии dead или stopped, то он будет уничтожен,
// иначе stop hook будет перезапускаться до тех пор, пока контейнер start не перейдет в одно из этих состояний
// Если stop hook был запущен MaxTries раз, но так и не перевел start в состоянии dead или stopped, то start будет немедленно убит
// Если stop hook выполняется при помощи контейнера и завершился с НУЛЕВЫМ кодом возврата, но start не в состоянии dead или stopped,
// то start будет немедленно убит
message TStopPolicy {
    oneof Policy {
        TUtilityContainer Stop = 1;
        THttpGet HttpStop = 2;
        TUtilityContainer Container = 4;
        THttpGet HttpGet = 5;
    }

    // Количестно попыток выполнить gracefully stop перед тем, как убить процесс
    // Должно быть > 0
    uint32 MaxTries = 3;
}

// При удалении workload из спеки
// будет вызван destroy hook, который выпонится только после окончания выполнения stop hook и перехода start контейнера в состояние dead.
// в случае если destroy hook завершится ненулевым кодом возврата, он будет перезапущен MaxTries раз
// пока не завершится успехом
message TDestroyPolicy {
    oneof Policy {
        TUtilityContainer Destroy = 1;
        THttpGet HttpDestroy = 2;
        TUtilityContainer Container = 4;
        THttpGet HttpGet = 5;
    }

    // Количестно попыток выполнить gracefully destroy перед тем, как убить процесс
    // Должно быть > 0
    uint32 MaxTries = 3;
}

// Обеспечивает изоляцию по диску и pidns
// Сеть между боксами не изолирована - workloadы разных боксов могут общаться друг с другом по localhost
message TBox {
    // уникальный в рамках pod идентификатор Box. Должен состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string Id = 1;

    TRootfsVolume Rootfs = 2;

    //TODO: валидация должна гарантировать, что не может быть двух вольюмов в этом списке, у которых совпадает mountPoint
    //TODO: валидация уникальности id в списке
    repeated TMountedVolume Volumes = 8;

    // Процессы, запускаемые при подготовке Box после создания вольюмов
    repeated TUtilityContainer Init = 9;

    //TODO: валидация должна гарантировать, что не может быть двух ресурсов в этом списке, у которых совпадает mountPoint
    //TODO: валидация уникальности id в списке
    repeated TMountedStaticResource StaticResources = 10;
}

// Успешными кодами ответов считаются те, что лежат в полуинтервале [200, 300)
message THttpGet {
    uint32 Port = 1;

    // Путь к ручке, например: "/ping"
    string Path = 2;
    // Только для Readiness check и Liveness check
    string ExpectedAnswer = 3;

    //@see TimeLimit
    TTimeLimit TimeLimit = 4;
}

// проверяет только, что connect по данному порту успешно завершился
message TTcpCheck {
    uint32 Port = 1;

    //@see TimeLimit
    TTimeLimit TimeLimit = 2;
}

message TReadinessCheck {
    oneof Check {
        TUtilityContainer Container = 2;
        TTcpCheck TcpCheck = 3;
        THttpGet HttpCheck = 4;
        THttpGet HttpGet = 5;
    }
}

message TLivenessCheck {
    oneof Check {
        TUtilityContainer Container = 1;
        TTcpCheck TcpCheck = 2;
        THttpGet HttpCheck = 3;
        THttpGet HttpGet = 4;
    }
}

message TCoreDump {
    // porto property core_command
    string CoreCommand = 1;

    // porto property ulimit[core]
    string CoreUlimit = 2;
}

//Наследует Env от TWorkload
message TUtilityContainer {
    //атрибуты контейнера (по сути это сквозной проброс опций Porto)
    //Тут важно разделять интерфейс предоствляемый пользователю и внутренний между YP<->agent
    TComputeResources ComputeResources = 2;

    string CommandLine = 3;

    //@see TimeLimit
    TTimeLimit TimeLimit = 4;

    // параметры обработки корок
    TCoreDump CoreDump = 5;
}

//Позволяет выставить ограничение сверху на все закачки. Важным моментом является, что сумма лимитов
//ресурсов может быть больше, чем даже лимиты Pod. Поэтому pod-agent должен будет запускать закачки так:
//Снача запускаются закачки для активных workload и параллельно запускаются только те, которые можно разместить
//в рамках лимитов box
message TResourceGang {
    //Идея убрать произвольные ресурсы, а оставить слои в том, чтобы форсить пользователя готовить во вне воспроизводимое
    //окружение для своего сервиса. По сути это аналог деплоя готовых docker образов.
    repeated TLayer Layers = 2;

    repeated TResource StaticResources = 3;
}

// ======================  STATUS ===================

message TBoxStatus {
    string Id = 1;

    EBoxState State = 2;

    repeated TContainerStatus Inits = 3;

    // Адрес из подсети c id 'boxes_subnet', выделенной на поде (см ip6_subnet_allocations)
    // Пустая строка, если подсеть не выделена
    string ip6_address = 10;

    // Неструктурированное описание последней ошибки
    string FailReason = 5;

    TCondition Ready = 6;

    TCondition InProgress = 7;

    // Ревизия к которой относится box
    uint32 Revision = 8;

    // Количество неудачных попыток собрать box
    uint32 FailCounter = 9;
}

enum EBoxState {
    EBoxState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Ждет пока заимпортится rootfs
    EBoxState_WAITING_FOR_ROOTFS_LAYERS = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_rootfs_layers"];

    // В процессе сборки rootfs volume
    EBoxState_CREATING_ROOTFS_VOLUME = 2 [(NYT.NYson.NProto.enum_value_name) = "creating_rootfs_volume"];

    // Ждет пока соберутся MountedVolumes
    EBoxState_WAITING_FOR_VOLUMES = 3 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_volumes"];

    // Приликовывает MountedVolumes к RootfsVolume
    EBoxState_LINKING_VOLUMES = 4 [(NYT.NYson.NProto.enum_value_name) = "linking_volumes"];

    // Запуск Init процессов
    EBoxState_INIT_PROCESSES = 5 [(NYT.NYson.NProto.enum_value_name) = "init_processes"];

    // Вольюмы смонтированы, окружение готово к запуску хуков
    EBoxState_READY = 6 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления box
    EBoxState_REMOVING = 7 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому box
    EBoxState_REMOVED = 8 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Box находится в невалидном состоянии и значит будет полнотью пересобран
    EBoxState_INVALID = 9 [(NYT.NYson.NProto.enum_value_name) = "invalid"];

    // Ждет пока заимпортятся статические ресурсы
    EBoxState_WAITING_FOR_STATIC_RESOURCES = 10 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_static_resources"];
}

//Q: Почему нет DEBUG состояния, чтобы поотлаживать упавшую джобу
//A: Дело в том, в pod agent не будет понятия джобы. pod agent запускает только сервисы.
//     одним из сервисов может быть сервис, который выполняет джобы.
enum EWorkloadState {
    EWorkloadState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Соответсвует ожиданию готовности Box
    EWorkloadState_WAITING_FOR_BOX = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_box"];

    // readiness сообщает, что Workload не готов
    EWorkloadState_SEMI_FAILURE = 2 [(NYT.NYson.NProto.enum_value_name) = "semi_failure"];

    // start hook запущен и status еще ни разу не завершился
    EWorkloadState_ACTIVATING = 3 [(NYT.NYson.NProto.enum_value_name) = "activating"];

    // Соответствует запущенному start hook при условии что хотябы единожды status завершился успешно
    EWorkloadState_ACTIVE = 4 [(NYT.NYson.NProto.enum_value_name) = "active"];

    // Соотвестует остановке start hook и работе stop hook
    EWorkloadState_DEACTIVATING = 5 [(NYT.NYson.NProto.enum_value_name) = "deactivating"];

    // Соотвествует процессу удаления workload
    EWorkloadState_REMOVING = 6 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому worload
    EWorkloadState_REMOVED = 7 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Workload находится в не валидном состоянии и значит будет полнотью пересобран
    EWorkloadState_INVALID = 8 [(NYT.NYson.NProto.enum_value_name) = "invalid"];

    // Workload deactivated by liveness
    EWorkloadState_DEACTIVATED_BY_LIVENESS = 9 [(NYT.NYson.NProto.enum_value_name) = "deactivated_by_liveness"];

    // running init commands
    EWorkloadState_INIT_PROCESESS = 10 [(NYT.NYson.NProto.enum_value_name) = "init_procesess"];
}

// Описание результата выполнения хука
enum EContainerState {
    EContainerState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Процесс завершился.
    EContainerState_EXITED = 1 [(NYT.NYson.NProto.enum_value_name) = "exited"];

    // Процесс убили из-за превышения памяти
    EContainerState_OUT_OF_MEMORY = 2 [(NYT.NYson.NProto.enum_value_name) = "out_of_memory"];

    // Произошел таймаут выполенния
    EContainerState_TIMEOUT = 3 [(NYT.NYson.NProto.enum_value_name) = "timeout"];

    // Процесс был убит извне (кто-то вызвал kill или destroy)
    EContainerState_KILLED_EXTERNALLY = 4 [(NYT.NYson.NProto.enum_value_name) = "killed_externally"];

    // Произошла системная ошибка (например ошибка от порто или т.п.)
    EContainerState_SYSTEM_FAILURE = 5 [(NYT.NYson.NProto.enum_value_name) = "system_failure"];

    EContainerState_RUNNING = 6 [(NYT.NYson.NProto.enum_value_name) = "running"];
    // Процесс ожидает истечения InitialDelayMs
    EContainerState_WAITING_INIT = 7 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];
    // Процесс ожидает истечения restart period - см. TTimeLimit
    EContainerState_WAITING_RESTART = 8 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];
}

//Q: Почему нет статистики контейнера
//A: Я считаю, что в данном случае сливать статистику в обратную связь бесполезно, т.к. нет возможности строить графики
//    если статистика реально нужна, то её надо выливать в какой-то из существующих сервисов: YT, solomon, golovan, statface
message TContainerStatus {
    reserved 1, 2, 3, 4, 5, 7, 12, 13, 14;

    message TAttemptFeedback {
        EContainerState State = 1;

        int32 ReturnCode = 2;

        // Последний 4KB stderr
        string Stderr = 3;

        // Последние 4KB stdout
        string Stdout = 4;

        //Неструктурированное описание последней ошибки связанной c запуском контейнера
        string FailReason = 5;
    }

    TAttemptFeedback Current = 16;
    TAttemptFeedback Last = 17;

    uint32 ZeroReturnCodeCounter = 6;
    uint32 PositiveReturnCodeCounter = 18;
    uint32 OomCounter = 8;
    uint32 TimeoutCounter = 9;
    uint32 KilledExternallyCounter = 10;
    uint32 SystemFailureCounter = 11;

    TTimeLimitStatus TimeLimit = 15;
}

enum EConditionStatus {
    EConditionStatus_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];
    EConditionStatus_TRUE = 1 [(NYT.NYson.NProto.enum_value_name) = "true"];
    EConditionStatus_FALSE = 2 [(NYT.NYson.NProto.enum_value_name) = "false"];
}

message TCondition {
    EConditionStatus Status = 10; // True, False, Unknown
    string Reason = 20; // One word (e.g. ProcessCrash) for computers and short summary
    string Message = 30; // Some human readable message
    google.protobuf.Timestamp LastTransitionTime = 40;
}

message TWorkloadStatus {
    reserved 5, 13;

    // уникальный в рамках pod идентификатор Workload
    string Id = 1;

    EWorkloadState State = 2;

    repeated TContainerStatus Init = 3;

    //Добавить валидацию, что указан непустой start
    TContainerStatus Start = 4;

    TStopStatus StopStatus = 14;

    TDestroyStatus DestroyStatus = 15;

    TReadinessStatus ReadinessStatus = 6;

    TLivenessStatus LivenessStatus = 10;

    TCondition Ready = 7;

    TCondition InProgress = 8;

    // mutalbe target state
    EWorkloadTargetState TargetState = 11;

    // Ревизия к которой относится workload
    uint32 Revision = 12;
}

enum EHttpGetState {
    EHttpGetState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Ошибка во время выполнения(превышен таймаут, ошибка соединения, ...)
    EHttpGetState_FAILURE = 1 [(NYT.NYson.NProto.enum_value_name) = "failure"];
    // Ответ не равен THttpGet::ExpectedAnswer, только для Readiness check и Liveness check
    EHttpGetState_WRONG_ANSWER = 2 [(NYT.NYson.NProto.enum_value_name) = "wrong_answer"];

    EHttpGetState_RUNNING = 3 [(NYT.NYson.NProto.enum_value_name) = "running"];
    // Ожидание истечения InitialDelayMs
    EHttpGetState_WAITING_INIT = 4 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];
    // Ожидание истечения restart period - см. TTimeLimit
    EHttpGetState_WAITING_RESTART = 5 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];
}

enum ETcpCheckState {
    ETcpCheckState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Connect не завершился успешно
    ETcpCheckState_FAILURE = 1 [(NYT.NYson.NProto.enum_value_name) = "failure"];

    ETcpCheckState_RUNNING = 2 [(NYT.NYson.NProto.enum_value_name) = "running"];
    // Ожидание истечения InitialDelayMs
    ETcpCheckState_WAITING_INIT = 3 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];
    // Ожидание истечения restart period - см. TTimeLimit
    ETcpCheckState_WAITING_RESTART = 4 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];
}

message TTcpCheckStatus {
    reserved 1, 2, 3, 4, 6;

    message TAttemptFeedback {
        ETcpCheckState State = 1;
        string FailReason = 2;
    }

    TAttemptFeedback Current = 7;
    TAttemptFeedback Last = 8;

    TTimeLimitStatus TimeLimit = 5;
}

message THttpGetStatus {
    reserved 1, 2, 3, 4, 6, 8;

    message TAttemptFeedback {
        EHttpGetState State = 1;
        string FailReason = 2;
        string InnerFailReason = 3;
    }

    TAttemptFeedback Current = 9;
    TAttemptFeedback Last = 10;

    uint32 RequestsCount = 7;

    TTimeLimitStatus TimeLimit = 5;
}

message TStopStatus {
    reserved 2;

    oneof Status {
        TContainerStatus ContainerStatus = 1;
        THttpGetStatus HttpGetStatus = 3;
    }
}

message TDestroyStatus {
    reserved 2;

    oneof Status {
        TContainerStatus ContainerStatus = 1;
        THttpGetStatus HttpGetStatus = 3;
    }
}

message TReadinessStatus {
    reserved 3;

    oneof Status {
        TContainerStatus ContainerStatus = 1;
        TTcpCheckStatus TcpCheckStatus = 2;
        THttpGetStatus HttpGetStatus = 4;
    }
}

message TLivenessStatus {
    reserved 3;

    oneof Status {
        TContainerStatus ContainerStatus = 1;
        TTcpCheckStatus TcpCheckStatus = 2;
        THttpGetStatus HttpGetStatus = 4;
    }
}

//Ресурс при скачивании и проверке проиходит через несколько стадий
enum ELayerState {
    ELayerState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    //в процессе скачивания
    ELayerState_DOWNLOADING = 1 [(NYT.NYson.NProto.enum_value_name) = "downloading"];

    //Проверка контрольной суммы
    ELayerState_VERIFYING = 2 [(NYT.NYson.NProto.enum_value_name) = "verifying"];

    //импортируется
    ELayerState_IMPORTING = 3 [(NYT.NYson.NProto.enum_value_name) = "importing"];

    //готов к использованию
    ELayerState_READY = 4 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления ресурса
    ELayerState_REMOVING = 5 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому ресурсу
    ELayerState_REMOVED = 6 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Layer находится в невалидном состоянии и значит будет полнотью пересобран
    ELayerState_INVALID = 7 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

//Статический ресурс при скачивании и проверке проиходит через несколько стадий
enum EStaticResourceState {
    EStaticResourceState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    //в процессе скачивания
    EStaticResourceState_DOWNLOADING = 1 [(NYT.NYson.NProto.enum_value_name) = "downloading"];

    //Проверка контрольной суммы
    EStaticResourceState_VERIFYING = 2 [(NYT.NYson.NProto.enum_value_name) = "verifying"];

    // Соотвествует процессу удаления ресурса
    EStaticResourceState_REMOVING = 3 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвествует удалённому ресурсу
    EStaticResourceState_REMOVED = 4 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    //готов к использованию
    EStaticResourceState_READY = 5 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Ресурс находится в невалидном состоянии
    EStaticResourceState_INVALID = 7 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

//TODO: нужно придумать как сделать прогресс скачивания
message TLayerStatus {
    string Id = 1;

    ELayerState State = 2;

    //NOTE: нет гарантии монотонно растущих счётчиков, т.к. их значения могут быть удалены на хосте
    //Количество попыток скачать ресурс
    uint32 DownloadAttemptsCounter = 3;

    //Количество попыток проверить контрольную сумму
    uint32 VerificationAttemptsCounter = 4;

    //Общее количество ошибок связанное с ресурсом
    uint32 FailCounter = 5;

    // Неструктурированное описание последней ошибки
    string FailReason = 6;

    TCondition Ready = 7;

    TCondition InProgress = 8;

    // Ревизия к которой относится layer
    uint32 Revision = 9;
}

message TStaticResourceStatus {
    string Id = 1;

    EStaticResourceState State = 2;

    //NOTE: нет гарантии монотонно растущих счётчиков, т.к. их значения могут быть удалены на хосте
    //Количество попыток скачать ресурс
    uint32 DownloadAttemptsCounter = 3;

    //Количество попыток проверить контрольную сумму
    uint32 VerificationAttemptsCounter = 4;

    //Общее количество ошибок связанное с ресурсом
    uint32 FailCounter = 5;

    // Неструктурированное описание последней ошибки
    string FailReason = 6;

    TCondition Ready = 7;

    TCondition InProgress = 8;

    // Ревизия к которой относится layer
    uint32 Revision = 9;
}

message TResourceGangStatus {
    repeated TLayerStatus Layers = 1;

    repeated TStaticResourceStatus StaticResources = 2;
}

enum EVolumeState {
    EVolumeState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // ждет пока заимпортятся layers
    EVolumeState_WAITING_FOR_LAYERS = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_layers"];

    //в процессе сборки
    EVolumeState_CREATING = 2 [(NYT.NYson.NProto.enum_value_name) = "creating"];

    //готов
    EVolumeState_READY = 3 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления volume
    EVolumeState_REMOVING = 4 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому volume
    EVolumeState_REMOVED = 5 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Volume находится в не валидном состоянии и значит будет полнотью пересобран
    EVolumeState_INVALID = 6 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

message TVolumeStatus {
    string Id = 1;

    EVolumeState State = 2;

    //Количество неудачных попыток собрать вольюм
    uint32 FailCounter = 3;

    // Неструктурированное описание последней ошибки
    string FailReason = 4;

    TCondition Ready = 5;

    TCondition InProgress = 6;

    // Ревизия к которой относится volume
    uint32 Revision = 7;
}
