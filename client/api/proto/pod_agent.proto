syntax = "proto3";

option python_package = "yp_proto.yp.client.api.proto";

option go_package = "a.yandex-team.ru/yp/go/proto/podagent";

option java_package = "ru.yandex.yp.client.pods";
option java_outer_classname = "Pod";
option java_multiple_files = true;

package NInfra.NPodAgent.API;

import "google/protobuf/timestamp.proto";
import "yt/core/yson/proto/protobuf_interop.proto";

option (NYT.NYson.NProto.derive_underscore_case_names) = true;

// TODO: itype (labels)
// TODO: coredump probabilty

// Конфигурация Пода, передаваемая в Pod-agent.
// NOTE: Сущности верхнего уровня имеют уникальные в рамках Пода идентификаторы (поле Id)
// и могут ссылаться друг на друга по этим идентификаторам (поля *Refs)
// NOTE: Валидация - нет висячих ссылок
// NOTE: Валидация - на каждый Workload ссылается ровно один MutableWorkload, нет ссылок из MutableWorkload на несуществующие Workload
message TPodAgentSpec {
    // Pod revision, server-side монотонно возрастаюшая последовательность
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 1;

    // Идентификатор пода
    string id = 2;

    // Слои и ресурсы, которые необходимо скачать в рамках лимитов @see ResourceGang
    TResourceGang resources = 3;

    // Все вольюмы
    repeated TVolume volumes = 4;

    // Все workload, изменение любого поля приводит к рестарту @see MutableWorkloads
    repeated TWorkload workloads = 5;

    // Все окружения, в которых могут быть запущены Workloads
    repeated TBox boxes = 8;

    // Часть Workload, изменение которой не приведет к полной пересборке Workload
    repeated TMutableWorkload mutable_workloads = 9;
}

// Кэш ресурсы, которые надо скачать на под
// Хеш ресурса считается как hash(Url, Checksum, Place), т.е. он не зависит от Id/Revision/Meta/CheckPeriodMs/..
// Если в спеке пода окажется layer или ресурс, у которого совпал хеш с каким-то ресурсом из кэша,
// то этот ресурс не будет закачиваться заново, а просто подставится из кэша
// NOTE: Для всех TResource с одинаковым хешом выбирается минимальное из времен TVerification::CheckPeriodMs,
// т.е. если в спеку пода придет TResource, который лежит в кэше, но его период верификации меньше
// периода верификации кэш ресурса, этот ресурс начнет верифицироваться с меньшим периодом
// NOTE: Валидация - сущности имеют уникальные в рамках пода идентификаторы (Пара Id, Revision)
message TPodAgentResourceCacheSpec {
    // Кэш слои
    repeated TCacheLayer layers = 1;

    // Кэш ресурсы
    repeated TCacheResource static_resources = 2;
}

// Текущее состояние Пода, возвращаемое из Pod-agent
message TPodAgentStatus {
    // Последняя известная pod revision
    uint32 revision = 1;

    // Идентификатор пода
    string id = 2;

    // Момент отправки сообщения с агента
    uint64 host_timestamp = 3;

    repeated TVolumeStatus volumes = 4;

    TResourceGangStatus resource_gang = 5;

    repeated TWorkloadStatus workloads = 6;

    repeated TBoxStatus boxes = 7;

    // Если хотя бы один из Ready вложенных T*Status имеет Status == EConditionStatus_UNKNOWN,
    // обращается в EConditionStatus_UNKNOWN.
    // Иначе, если хотя бы один из них имеет Status == EConditionStatus_FALSE,
    // обращается в EConditionStatus_FALSE.
    // Иначе обращается в EConditionStatus_TRUE.
    // LastTransitionTime -- максимальное значение Ready.LastTransitionTime среди всех вложеных T*Status
    TCondition ready = 8;

    // Если хотя бы один из InProgress вложенных T*Status имеет Status == EConditionStatus_UNKNOWN,
    // обращается в EConditionStatus_UNKNOWN.
    // Иначе, если хотя бы один из них имеет Status == EConditionStatus_TRUE,
    // обращается в EConditionStatus_TRUE.
    // Иначе обращается в EConditionStatus_FALSE.
    // LastTransitionTime -- максимальное значение InProgress.LastTransitionTime среди всех вложеных T*Status
    TCondition in_progress = 9;

    TResourceGangStatus resource_cache = 10;

    // yp timestamp последнего обновления спецификации пода
    uint64 spec_timestamp = 11;
}

//============================== SPEC ==========================
message TComputeResources {
    reserved 1;

    // Ограничения по CPU, в виртуальных миллиядрах (vcpu).
    // Тем самым, заказав vcpu = 1000, мы получим одно виртуальное ядро.
    uint64 vcpu_guarantee = 2;
    uint64 vcpu_limit = 3;

    // Ограничения по памяти, в байтах
    uint64 memory_guarantee = 4;
    uint64 memory_limit = 5;
    uint64 anonymous_memory_limit = 6;

    // Если true иммигрирует кэш при незначительной ошибке страницы, по умолчанию: false.
    bool recharge_on_pgfault = 7;
}

// Проверки целостности ресурса
message TVerification {
    // Контрольная сумма, формат <схема>:<значение>
    // Поддерживаемые схемы "MD5:", "EMPTY:", "SHA256:" - case sensitive
    string checksum = 1;

    // Периодичность проверки контрольной суммы. Первая проверка выполняется сразу после завершения скачивания.
    // TODO: Добавить валидацию минимального значения периода проверки
    uint64 check_period_ms = 2;
}

message TSandboxResource {
    string task_type = 1;
    string task_id = 2;
    string resource_type = 3;
    string resource_id = 4;
}

message TResourceMeta {
    oneof meta {
        TSandboxResource sandbox_resource = 2;
    }
}

message TFile {
    // Имя файла
    // NOTE: Валидация - не содержит "/"
    string file_name = 1;

    oneof content {
        // Содержимое этой строки будет скопировано в файл
        string raw_data = 2;

        // Cодержимое секрета будет скопировано в файл
        SecretSelector secret_data = 3;
    }
}

message TFiles {
    // NOTE: Валидация - все имена файлов различны
    repeated TFile files = 1;
}

message TResource {
    reserved "place"; reserved 7;

    // Уникальное имя ресурса (в рамках pod'а).
    // Должно состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string id = 1;

    // Не нужно для Pod-agent
    // Мета информация о ресурсе, необходимо для интеграции с CI/CD
    TResourceMeta meta = 2;

    // @see TVerification
    TVerification verification = 3;

    // URL для скачивания, протоколы: http, https, rbtorrent
    // Для записи строчки в файл URL должен быть равен "raw:<строка>",
    // в этом случае будет создан файл с названием raw_file и содержимым <строка>
    // Только для тестов: можно указать путь к файлу на хосте "local:<filepath>"
    // Для передачи секретов можно использовать files
    // Для загрузки больше чем одного raw/secret файла можно использовать files
    oneof download_method {
        string url = 4;
        TFiles files = 9;
    }

    // TODO: not implemented
    oneof storage_ref {
        bool default_storage = 5;
        // Указатель на файловый сторедж
        string file_storage_ref = 6;
    }

    // Virtual disk, где будет расположен ресурс
    // Ресурс будт скачан на porto volume, созданный на этом диске
    // NOTE: Валидация - должен совпадать с virtual_disk_id_ref у volume, box, которые используют этот ресурс
    string virtual_disk_id_ref = 8;
}

message TCacheResource {
    // Ревизия кэш ресурса
    uint32 revision = 1;

    TResource resource = 2;
}

message TLayer {
    reserved "resource", "place"; reserved 2, 6;

    // Уникальное имя слоя (в рамках pod'а).
    // Должно состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string id = 1;

    // Не нужно для Pod-agent
    // Мета информация о ресурсе, необходимо для интеграции с CI/CD
    TResourceMeta meta = 3;

    // Контрольная сумма, формат <схема>:<значение>
    // Поддерживаемые схемы "MD5:", "EMPTY:", "SHA256:" - case sensitive
    string checksum = 4;

    // URL для скачивания, протоколы: http, https, rbtorrent
    // Для записи строчки в файл URL должен быть равен "raw:<строка>"
    // Только для тестов: можно указать путь к файлу на хосте "local:<filepath>"
    string url = 5;

    // Virtual disk, где будет расположен layer
    // Слой будт скачан на porto volume, созданный на этом диске и импортирован в porto
    // Place, в который импортирован данный слой, лежит на этом же диске
    // NOTE: Валидация - должен совпадать с virtual_disk_id_ref у volume, box, которые используют этот слой
    string virtual_disk_id_ref = 7;
}

message TCacheLayer {
    // Ревизия кэш слоя
    uint32 revision = 1;

    TLayer layer = 2;
}

enum EVolumeMountMode {
    EVolumeMountMode_READ_ONLY = 0 [(NYT.NYson.NProto.enum_value_name) = "read_only"];
    EVolumeMountMode_READ_WRITE = 1 [(NYT.NYson.NProto.enum_value_name) = "read_write"];
}

// Позволяет монитровать один вольюм в разные mountPoint
message TMountedVolume {
    // Id volume, который требуется подмонтировать
    string volume_ref = 1;

    // Точка монтирования
    string mount_point = 2;

    // Мод монтирования (read_only/read_write)
    EVolumeMountMode mode = 3;
}

message TMountedStaticResource {
    // Id static_resource, который требуется подмонтировать
    string resource_ref = 1;

    // Точка монтирования
    // Будет создана директория с этим путем, внутри директории будет лежать скаченный ресурс
    string mount_point = 2;
}

message TRootfsVolume {
    reserved "place"; reserved 2, 3, 5, 6;

    // Квота на размер
    // NOTE: Не обрабатывается - porto не умеет во вложенные квоты по диску
    uint64 quota_bytes = 1;

    // Слои, из которых собирается volume
    // Как и в porto, слои идут в порядке top-layer;...;bottom-layer
    // NOTE: Валидация - ids в списке должны быть уникальные
    repeated string layer_refs = 4;
}

message TFileStorage {
    // Квота на размер
    // NOTE: Не обрабатывается - porto не умеет во вложенные квоты по диску
    uint64 quota_bytes = 1;
}

message TGenericVolume {
    reserved "place"; reserved 1, 2, 3, 6;

    // Квота на размер
    // NOTE: не обрабатывается - porto не умеет во вложенные квоты по диску
    uint64 quota_bytes = 5;

    // Слои, из которых собирается volume
    // Как и в porto, слои идут в порядке top-layer;...;bottom-layer
    // NOTE: Валидация - ids в списке должны быть уникальные
    repeated string layer_refs = 4;
}

message TVolume {
    // Уникальное имя volume (в рамках pod'а).
    // Должно состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string id = 1;

    oneof volume {
        // TODO: not implemented
        TFileStorage storage = 3;

        TGenericVolume generic = 4;
    }

    // Virtual disk, где будет расположен volume
    // Volume будет создан в place, находящемся на этом виртуальном диске
    // NOTE: Валидация - должен совпадать с virtual_disk_id_ref у слоев, из которых собирается volume
    string virtual_disk_id_ref = 5;
}

// Ограничения на время исполнения и интервал между запусками хука.
// Все времена в миллисекундах, однако времена, возвращаемые porto,
// имеют точность до секунды.
// Поэтому все значения будут округляться вверх до секунд.
// maxExecutionTimeMs - ограничение на время выполнения.
// Интервал между запусками рассчитывается по формуле
// min(maxRestartPeriodMs, minRestartPeriodMs + restartPeriodScaleMs * (restartPeriodBackoff ^ step))
// step считается с 0 и равен max(0, ConsecutiveFailuresCounter - 1) для workload stop и workload destroy
// и max(0, ConsecutiveSuccessesCounter - 1) для всех остальных хуков: workload readiness, workload liveness, workload init
message TTimeLimit {
    // Если равен 0, то будет интерпретироваться как 5000 для workload readiness/liveness
    // Для остальных контейнеров остается без изменений
    uint64 initial_delay_ms = 1;
    uint64 restart_period_scale_ms = 2;
    uint64 restart_period_back_off = 3;
    uint64 max_restart_period_ms = 4; // Если равен 0, то будет интерпретироваться как 18446744073709551615 (UINT64_MAX)
    uint64 min_restart_period_ms = 5; // Если равен 0, то будет интерпретироваться как 30000
    uint64 max_execution_time_ms = 6; // Если равен 0, то будет интерпретироваться как 1800000
}

message TTimeLimitStatus {
    google.protobuf.Timestamp last_call_time = 1;
    uint32 consecutive_successes_counter = 2;
    uint32 consecutive_failures_counter = 3;
}

// Id секрета из TPodAgentRequest.Secrets
// Alias секрета из TPodAgentRequest.Secrets
// В момент обработки спеки будет добавлена переменная окружения с значением равным value секрета
message SecretSelector {
    string id = 1;
    string alias = 2;
}

message LiteralEnvSelector {
    string value = 1;
}

message TEnvVarValue {
    oneof value {
        SecretSelector secret_env = 2;
        LiteralEnvSelector literal_env = 3;
    }
}

message TEnvVar {
    string name = 1;
    TEnvVarValue value = 2;
}

enum EContainerULimitType {
    // address space
    EContainerULimit_AS = 0 [(NYT.NYson.NProto.enum_value_name) = "as"];

    // core file size
    EContainerULimit_CORE = 1 [(NYT.NYson.NProto.enum_value_name) = "core"];

    // data seg size
    EContainerULimit_DATA = 2 [(NYT.NYson.NProto.enum_value_name) = "data"];

    // max locked memory
    EContainerULimit_MEMLOCK = 3 [(NYT.NYson.NProto.enum_value_name) = "memlock"];

    // stack size
    EContainerULimit_STACK = 4 [(NYT.NYson.NProto.enum_value_name) = "stack"];

    // file size
    EcontainerULimit_FSIZE = 5 [(NYT.NYson.NProto.enum_value_name) = "fsize"];
}

message TUlimitSoft {
    EContainerULimitType name = 1;
    uint64 value = 2;
}

enum EWorkloadTargetState {
    EWorkloadTarget_ACTIVE = 0 [(NYT.NYson.NProto.enum_value_name) = "active"];
    EWorkloadTarget_REMOVED = 1 [(NYT.NYson.NProto.enum_value_name) = "removed"];
}

message TWorkload {
    reserved 2, 4, 10;

    // Уникальное имя workload (в рамках pod'а).
    // Должно состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string id = 1;

    // Указатель на Box, в котором workload будет запущен
    string box_ref = 8;

    // Переменные окружения - прокидываются во все контейнеры ворклода
    repeated TEnvVar env = 5;

    // Soft лимиты окружения - прокидываются во все контейнеры ворклода
    repeated TUlimitSoft ulimit_soft = 14;

    // Набор команд, запускаемых перед стартом основного процесса.
    // Гарантируется, что каждая отработает at least once.
    // Если команда падает - она перезапускается до победного
    repeated TUtilityContainer init = 3;

    // Описание основного процесса
    TUtilityContainer start = 11;

    // @see TReadinessCheck
    TReadinessCheck readiness_check = 6;

    // @see TLivenessCheck
    TLivenessCheck liveness_check = 9;

    // @see TStopPolicy
    TStopPolicy stop_policy = 7;

    // @see TDestroyPolicy
    TDestroyPolicy destroy_policy = 12;

    // Передавать логи stdout и stderr в YT
    // Должно быть выставлено не более одного из: этот флаг и start.stdout_file/stderr_file/stdout_and_stderr_limit
    bool transmit_logs = 13;
}

// Mutable поля Workload
message TMutableWorkload {
    // Ссылка на workload
    string workload_ref = 1;

    EWorkloadTargetState target_state = 2;
}

// При переводе TMutableWorkload.TargetState в состояние REMOVED или обновления ревизии workload или любой его зависимости
// будет вызван stop hook, который должен выполнить gracefully завершение контейнера start
// Если после завершения stop hook контейнер start находится в состоянии dead или stopped, то он будет уничтожен,
// иначе stop hook будет перезапускаться до тех пор, пока контейнер start не перейдет в одно из этих состояний
// Если stop hook был запущен max_tries раз, но так и не перевел start в состоянии dead или stopped, то start будет немедленно убит
// Если stop hook выполняется при помощи контейнера и завершился с НУЛЕВЫМ кодом возврата, но start не в состоянии dead или stopped,
// то start будет немедленно убит
message TStopPolicy {
    reserved 1, 2;

    oneof policy {
        TUtilityContainer container = 4;
        THttpGet http_get = 5;
    }

    // Количестно попыток выполнить gracefully stop перед тем, как убить процесс
    // NOTE: Валидация - должно быть > 0
    uint32 max_tries = 3;
}

// При удалении workload из спеки будет вызван destroy hook,
// который выпонится только после окончания выполнения stop hook и перехода start контейнера в состояние dead.
// В случае если destroy hook завершится ненулевым кодом возврата, он будет перезапущен max_tries раз, пока не завершится успехом
message TDestroyPolicy {
    reserved 1, 2;

    oneof policy {
        TUtilityContainer container = 4;
        THttpGet http_get = 5;
    }

    // Количестно попыток выполнить gracefully destroy перед тем, как полностью удалить start контейнер workload
    // NOTE: Валидация - должно быть > 0
    uint32 max_tries = 3;
}

// Обеспечивает изоляцию по диску и pidns
// Сеть между боксами не изолирована - workload'ы разных боксов могут общаться друг с другом по localhost
message TBox {
    // Уникальное имя box (в рамках pod'а).
    // Должно состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string id = 1;

    TRootfsVolume rootfs = 2;

    // TODO: Валидировать что mount_point не пересекается со static_resource
    // NOTE: Валидация - все mount_point различны
    // NOTE: Валидация - все id volume в списке уникальны
    repeated TMountedVolume volumes = 8;

    // Процессы, запускаемые при подготовке Box после создания вольюмов
    repeated TUtilityContainer init = 9;

    // TODO: Валидировать что mount_point не пересекается с volume
    // NOTE: Валидация - все mount_point различны
    // NOTE: Валидация - все id static_resource в списке различны
    repeated TMountedStaticResource static_resources = 10;

    // Если указано true
    // pod agent создает bind volume из <pod_chroot>/place/berkanavt/supervisor в <box_chroot>/place/berkanavt/supervisor
    // На файловой системе box'а обязательно наличие директории /place/berkanavt/supervisor и следующих симлинков (без них скачивание/раздача работать не будут совсем):
    //   /skynet => /Berkanavt/supervisor/base/active
    //   /usr/local/bin/sky => /skynet/tools/sky
    //   /Berkanavt => /place/berkanavt
    // Эти директории и симлинки можно добавить с помощью небольшого слоя sbr:922226367
    // PS Если вы используете расширенные базовые образы, нужные симлинки в них уже есть https://wiki.yandex-team.ru/runtime-cloud/virtualimages/#rasshirennyjjobraz
    bool bind_skynet = 11;

    // Если в аннотациях пода есть флаг: pod.rbind.yt: true
    // То pod_agent создает bind volume из <pod_chroot>/yt в <box_chroot>/yt
    // На файловой системе box'а обязательно наличие директории /yt
    // Эту директорию можно добавить с помощью небольшого слоя sbr:1014359696

    // Ограничения на meta контейнер Box
    TComputeResources compute_resources = 12;

    // Переменные окружения - прокидываются во все init контейнеры бокса
    repeated TEnvVar env = 13;

    // Virtual disk, где будет расположен box
    // Rootfs volume будет создан в place, находящемся на этом виртуальном диске
    // NOTE: Валидация - должен совпадать с virtual_disk_id_ref у слоев и ресурсов, из которых собирается box
    string virtual_disk_id_ref = 14;
}

// Успешными кодами ответов считаются те, что лежат в полуинтервале [200, 300)
message THttpGet {
    uint32 port = 1;

    // Путь к ручке, например: "/ping"
    // Если путь пустой, то будет интерпретироваться как "/" из-за особенностей http клиента
    string path = 2;

    // Ожидаемый ответ сервера
    oneof answer {
        // В случае несовпадения ответа http запрос считается неуспешным
        string expected_answer = 3;

        // Если выставлено в true, ответ сервера игнорируется (проверяется только код ответа)
        bool any = 5;
    }

    // @see TimeLimit
    TTimeLimit time_limit = 4;
}

// Проверяет только, что connect по данному порту успешно завершился
message TTcpCheck {
    uint32 port = 1;

    // @see TimeLimit
    TTimeLimit time_limit = 2;
}

// В случае возврата 0 контейнером или успешном завершении http/tcp hook - workload переходит в состояние ACTIVE,
// в других случаях SEMI_FAILED
// Нет такого кода возврата status hook, при котором контейнер будет убит
// Это соответствет текущему поведению instaceCTL и qloudinit
//      https://wiki.yandex-team.ru/jandekspoisk/sepe/instancectl/#ortho-tags
//      https://docs.platform.yandex-team.ru/doc/component#status_hook
// Если это поведение поменять сделать миграцию автоматической будет сложнее
// Если пользователь хочет пробпросить кастомный стуктурированный status, то рекомендуемое место для этого
// stdout этого хука
message TReadinessCheck {
    reserved 4;

    oneof check {
        TUtilityContainer container = 2;
        TTcpCheck tcp_check = 3;
        THttpGet http_get = 5;
    }
}

// В случае ненулевого возврата или не успешном завершении http/tcp hook - workload убивается,
// и переходит в состояние DEACTIVATED_BY_LIVENESS
message TLivenessCheck {
    reserved 3;

    oneof check {
        TUtilityContainer container = 1;
        TTcpCheck tcp_check = 2;
        THttpGet http_get = 4;
    }
}

// Наследует env от TWorkload, если принадлежит ему
// Наследует env от TBox, если является init коммандой этого box
message TUtilityContainer {
    reserved 5;

    // Атрибуты контейнера (по сути это сквозной проброс опций Porto)
    // Тут важно разделять интерфейс предоствляемый пользователю и внутренний между YP<->agent
    TComputeResources compute_resources = 2;

    string command_line = 3;

    // @see TTimeLimit
    TTimeLimit time_limit = 4;

    // Параметры обработки корок
    string core_command = 6;

    // Пользователь, владеющий процессами контейнера
    // Если пользователь не указан, то будет выставлен root
    string user = 7;

    // Группа, владеющая процессами контейнера
    // Если группа не указана, то будет выставлен root
    string group = 8;

    // Рабочая директория контейнера
    string cwd = 9;

    // Путь относительно корня бокса до файла для stdout
    // Если файл не указан, то он будет создан внутри porto, а не внутри бокса
    string stdout_file = 10;

    // Путь относительно корня бокса до файла для stderr
    // Если файл не указан, то он будет создан внутри porto, а не внутри бокса
    string stderr_file = 11;

    // Ограничение на размер stdout и stderr
    // Если выставлен 0, то будет использовано стандартное значение porto, например, для 4.18.20 ограничение будет 8388608
    uint32 stdout_and_stderr_limit = 12;
}

// TODO
// Позволяет выставить ограничение сверху на все закачки. Важным моментом является, что сумма лимитов
// ресурсов может быть больше, чем даже лимиты Pod. Поэтому pod-agent должен будет запускать закачки так:
// Снача запускаются закачки для активных workload и параллельно запускаются только те, которые можно разместить
// в рамках лимитов box
message TResourceGang {
    repeated TLayer layers = 2;

    repeated TResource static_resources = 3;
}

// ======================  STATUS ===================

message TBoxStatus {
    string id = 1;

    EBoxState state = 2;

    repeated TContainerStatus inits = 3;

    // Адрес из подсети c id 'boxes_subnet', выделенной на поде (см ip6_subnet_allocations)
    // Пустая строка, если подсеть не выделена
    string ip6_address = 10;

    // Имя porto контейнера (относительно корневого контейнера пода)
    string container_name = 11;

    // Неструктурированное описание последней ошибки
    string fail_reason = 5;

    TCondition ready = 6;

    TCondition in_progress = 7;

    // Ревизия к которой относится box
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 8;

    // Количество неудачных попыток собрать box
    uint32 fail_counter = 9;

    // spec_timestamp до которого обновлен box
    uint64 spec_timestamp = 12;
}

enum EBoxState {
    EBoxState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Ждет пока заимпортится rootfs layers в porto
    EBoxState_WAITING_FOR_ROOTFS_LAYERS = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_rootfs_layers"];

    // В процессе сборки rootfs volume
    EBoxState_CREATING_ROOTFS_VOLUME = 2 [(NYT.NYson.NProto.enum_value_name) = "creating_rootfs_volume"];

    // Ждет пока соберутся MountedVolumes
    EBoxState_WAITING_FOR_VOLUMES = 3 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_volumes"];

    // Приликовывает MountedVolumes к RootfsVolume
    EBoxState_LINKING_VOLUMES = 4 [(NYT.NYson.NProto.enum_value_name) = "linking_volumes"];

    // Запуск Init процессов
    EBoxState_INIT_PROCESSES = 5 [(NYT.NYson.NProto.enum_value_name) = "init_processes"];

    // Вольюмы смонтированы, окружение готово к запуску хуков
    EBoxState_READY = 6 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления box
    EBoxState_REMOVING = 7 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому box
    EBoxState_REMOVED = 8 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Box находится в невалидном состоянии и значит будет полнотью пересобран
    EBoxState_INVALID = 9 [(NYT.NYson.NProto.enum_value_name) = "invalid"];

    // Ждет пока заимпортятся статические ресурсы
    EBoxState_WAITING_FOR_STATIC_RESOURCES = 10 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_static_resources"];

    // В процессе сборки root container
    EBoxState_CREATING_ROOT_CONTAINER = 11 [(NYT.NYson.NProto.enum_value_name) = "creating_root_container"];
}

// Q: Почему нет DEBUG состояния, чтобы поотлаживать упавшую джобу
// A: Дело в том, в pod agent не будет понятия джобы. pod agent запускает только сервисы.
//      одним из сервисов может быть сервис, который выполняет джобы.
enum EWorkloadState {
    EWorkloadState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Соответсвует ожиданию готовности Box
    EWorkloadState_WAITING_FOR_BOX = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_box"];

    // readiness сообщает, что Workload не готов
    EWorkloadState_SEMI_FAILURE = 2 [(NYT.NYson.NProto.enum_value_name) = "semi_failure"];

    // start hook запущен и status еще ни разу не завершился
    EWorkloadState_ACTIVATING = 3 [(NYT.NYson.NProto.enum_value_name) = "activating"];

    // Соответствует запущенному start hook при условии что хотябы единожды status завершился успешно
    EWorkloadState_ACTIVE = 4 [(NYT.NYson.NProto.enum_value_name) = "active"];

    // Соотвестует остановке start hook и работе stop hook
    EWorkloadState_DEACTIVATING = 5 [(NYT.NYson.NProto.enum_value_name) = "deactivating"];

    // Соотвествует процессу удаления workload
    EWorkloadState_REMOVING = 6 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому worload
    EWorkloadState_REMOVED = 7 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Workload находится в не валидном состоянии и значит будет полнотью пересобран
    EWorkloadState_INVALID = 8 [(NYT.NYson.NProto.enum_value_name) = "invalid"];

    // Workload был убит из-за неудачного завершения liveness
    EWorkloadState_DEACTIVATED_BY_LIVENESS = 9 [(NYT.NYson.NProto.enum_value_name) = "deactivated_by_liveness"];

    // Workload выполняет init команды
    EWorkloadState_INIT_PROCESESS = 10 [(NYT.NYson.NProto.enum_value_name) = "init_procesess"];
}

// Описание результата выполнения хука
enum EContainerState {
    EContainerState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Процесс завершился.
    EContainerState_EXITED = 1 [(NYT.NYson.NProto.enum_value_name) = "exited"];

    // Процесс убили из-за превышения памяти
    EContainerState_OUT_OF_MEMORY = 2 [(NYT.NYson.NProto.enum_value_name) = "out_of_memory"];

    // Произошел таймаут выполенния
    EContainerState_TIMEOUT = 3 [(NYT.NYson.NProto.enum_value_name) = "timeout"];

    // Процесс был убит извне (кто-то вызвал kill или destroy)
    EContainerState_KILLED_EXTERNALLY = 4 [(NYT.NYson.NProto.enum_value_name) = "killed_externally"];

    // Произошла системная ошибка (например ошибка от порто или т.п.)
    EContainerState_SYSTEM_FAILURE = 5 [(NYT.NYson.NProto.enum_value_name) = "system_failure"];

    // Процесс запущен и работает
    EContainerState_RUNNING = 6 [(NYT.NYson.NProto.enum_value_name) = "running"];

    // Процесс ожидает истечения InitialDelayMs
    EContainerState_WAITING_INIT = 7 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];

    // Процесс ожидает истечения restart period - @see TTimeLimit
    EContainerState_WAITING_RESTART = 8 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];
}

// Q: Почему нет статистики контейнера
// A: Я считаю, что в данном случае сливать статистику в обратную связь бесполезно, т.к. нет возможности строить графики
//     если статистика реально нужна, то её надо выливать в какой-то из существующих сервисов: YT, solomon, golovan, statface
message TContainerStatus {
    reserved 1, 2, 3, 4, 5, 7, 12, 13, 14;

    message TAttemptFeedback {
        EContainerState state = 1;

        int32 return_code = 2;

        // Последний 4KB stderr
        string stderr = 3;

        // Последние 4KB stdout
        string stdout = 4;

        // Неструктурированное описание последней ошибки связанной c запуском контейнера
        string fail_reason = 5;
    }

    TAttemptFeedback current = 16;
    TAttemptFeedback last = 17;

    uint32 zero_return_code_counter = 6;
    uint32 positive_return_code_counter = 18;
    uint32 oom_counter = 8;
    uint32 timeout_counter = 9;
    uint32 killed_externally_counter = 10;
    uint32 system_failure_counter = 11;

    TTimeLimitStatus time_limit = 15;
}

enum EConditionStatus {
    EConditionStatus_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];
    EConditionStatus_TRUE = 1 [(NYT.NYson.NProto.enum_value_name) = "true"];
    EConditionStatus_FALSE = 2 [(NYT.NYson.NProto.enum_value_name) = "false"];
}

message TCondition {
    // True, False, Unknown
    EConditionStatus status = 10;

    // Одно слово, которое описывает причину перехода в этот статус (например ProcessCrash)
    string reason = 20;

    // Human readable причина перехода в этот статус
    string message = 30;

    // Время последнего обновления
    google.protobuf.Timestamp last_transition_time = 40;
}

message TWorkloadStatus {
    reserved 5, 13;

    string id = 1;

    string box_ref = 17;

    EWorkloadState state = 2;

    repeated TContainerStatus init = 3;

    TContainerStatus start = 4;

    TStopStatus stop_status = 14;

    TDestroyStatus destroy_status = 15;

    TReadinessStatus readiness_status = 6;

    TLivenessStatus liveness_status = 10;

    TCondition ready = 7;

    TCondition in_progress = 8;

    // mutalbe target state
    EWorkloadTargetState target_state = 11;

    // Ревизия к которой относится workload
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 12;

    // spec_timestamp до которого обновлен workload
    uint64 spec_timestamp = 16;
}

enum EHttpGetState {
    EHttpGetState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Ошибка во время выполнения (превышен таймаут, ошибка соединения, ...)
    EHttpGetState_FAILURE = 1 [(NYT.NYson.NProto.enum_value_name) = "failure"];

    // Ответ не равен THttpGet::expected_answer, только для Readiness check и Liveness check
    EHttpGetState_WRONG_ANSWER = 2 [(NYT.NYson.NProto.enum_value_name) = "wrong_answer"];

    // Выполняется
    EHttpGetState_RUNNING = 3 [(NYT.NYson.NProto.enum_value_name) = "running"];

    // Ожидание истечения InitialDelayMs
    EHttpGetState_WAITING_INIT = 4 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];

    // Ожидание истечения restart period - @see TTimeLimit
    EHttpGetState_WAITING_RESTART = 5 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];

    // Http запрос выполнился с 200-299 кодом возврата и ответ соответствует THttpGet::expected_answer
    EHttpGetState_SUCCESS = 6 [(NYT.NYson.NProto.enum_value_name) = "success"];
}

enum ETcpCheckState {
    ETcpCheckState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Connect не завершился успешно
    ETcpCheckState_FAILURE = 1 [(NYT.NYson.NProto.enum_value_name) = "failure"];

    // Выполняется
    ETcpCheckState_RUNNING = 2 [(NYT.NYson.NProto.enum_value_name) = "running"];

    // Ожидание истечения InitialDelayMs
    ETcpCheckState_WAITING_INIT = 3 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];

    // Ожидание истечения restart period - см. TTimeLimit
    ETcpCheckState_WAITING_RESTART = 4 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];

    // Connect завершился успешно
    ETcpCheckState_SUCCESS = 5 [(NYT.NYson.NProto.enum_value_name) = "success"];
}

message TTcpCheckStatus {
    reserved 1, 2, 3, 4, 6;

    message TAttemptFeedback {
        ETcpCheckState state = 1;
        string fail_reason = 2;
    }

    TAttemptFeedback current = 7;
    TAttemptFeedback last = 8;

    TTimeLimitStatus time_limit = 5;
}

message THttpGetStatus {
    reserved 1, 2, 3, 4, 6, 8;

    message TAttemptFeedback {
        EHttpGetState state = 1;
        string fail_reason = 2;
        string inner_fail_reason = 3;
    }

    TAttemptFeedback current = 9;
    TAttemptFeedback last = 10;

    uint32 requests_count = 7;

    TTimeLimitStatus time_limit = 5;
}

message TStopStatus {
    reserved 2;

    oneof status {
        TContainerStatus container_status = 1;
        THttpGetStatus http_get_status = 3;
    }
}

message TDestroyStatus {
    reserved 2;

    oneof status {
        TContainerStatus container_status = 1;
        THttpGetStatus http_get_status = 3;
    }
}

message TReadinessStatus {
    reserved 3;

    oneof status {
        TContainerStatus container_status = 1;
        TTcpCheckStatus tcp_check_status = 2;
        THttpGetStatus http_get_status = 4;
    }
}

message TLivenessStatus {
    reserved 3;

    oneof status {
        TContainerStatus container_status = 1;
        TTcpCheckStatus tcp_check_status = 2;
        THttpGetStatus http_get_status = 4;
    }
}

// Ресурс при скачивании и проверке проиходит через несколько стадий
enum ELayerState {
    ELayerState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // В процессе скачивания
    ELayerState_DOWNLOADING = 1 [(NYT.NYson.NProto.enum_value_name) = "downloading"];

    // Проверка контрольной суммы
    ELayerState_VERIFYING = 2 [(NYT.NYson.NProto.enum_value_name) = "verifying"];

    // Импортируется в porto
    ELayerState_IMPORTING = 3 [(NYT.NYson.NProto.enum_value_name) = "importing"];

    // Готов к использованию
    ELayerState_READY = 4 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления ресурса
    ELayerState_REMOVING = 5 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому ресурсу
    ELayerState_REMOVED = 6 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Layer находится в невалидном состоянии и значит будет полнотью пересобран
    ELayerState_INVALID = 7 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

// Статический ресурс при скачивании и проверке проиходит через несколько стадий
enum EStaticResourceState {
    EStaticResourceState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // В процессе скачивания
    EStaticResourceState_DOWNLOADING = 1 [(NYT.NYson.NProto.enum_value_name) = "downloading"];

    // Проверка контрольной суммы
    EStaticResourceState_VERIFYING = 2 [(NYT.NYson.NProto.enum_value_name) = "verifying"];

    // Соотвествует процессу удаления ресурса
    EStaticResourceState_REMOVING = 3 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвествует удалённому ресурсу
    EStaticResourceState_REMOVED = 4 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Готов к использованию
    EStaticResourceState_READY = 5 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Ресурс находится в невалидном состоянии
    EStaticResourceState_INVALID = 7 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

// TODO: нужно придумать как сделать прогресс скачивания
message TLayerStatus {
    string id = 1;

    ELayerState state = 2;

    // NOTE: нет гарантии монотонно растущих счётчиков, т.к. их значения могут быть удалены на хосте
    // Количество попыток скачать ресурс
    uint32 download_attempts_counter = 3;

    // Количество попыток проверить контрольную сумму
    uint32 verification_attempts_counter = 4;

    // Общее количество ошибок связанное с ресурсом
    uint32 fail_counter = 5;

    // Неструктурированное описание последней ошибки
    string fail_reason = 6;

    TCondition ready = 7;

    TCondition in_progress = 8;

    // Ревизия к которой относится layer
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 9;

    // spec_timestamp до которого обновлен layer
    uint64 spec_timestamp = 10;
}

message TStaticResourceStatus {
    string id = 1;

    EStaticResourceState state = 2;

    // NOTE: нет гарантии монотонно растущих счётчиков, т.к. их значения могут быть удалены на хосте
    // Количество попыток скачать ресурс
    uint32 download_attempts_counter = 3;

    // Количество попыток проверить контрольную сумму
    uint32 verification_attempts_counter = 4;

    // Общее количество ошибок связанное с ресурсом
    uint32 fail_counter = 5;

    // Неструктурированное описание последней ошибки
    string fail_reason = 6;

    TCondition ready = 7;

    TCondition in_progress = 8;

    // Ревизия к которой относится layer
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 9;

    // spec_timestamp до которого обновлен static_resource
    uint64 spec_timestamp = 10;
}

message TResourceGangStatus {
    repeated TLayerStatus layers = 1;

    repeated TStaticResourceStatus static_resources = 2;
}

enum EVolumeState {
    EVolumeState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Ждет пока заимпортятся layers в porto
    EVolumeState_WAITING_FOR_LAYERS = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_layers"];

    // В процессе сборки
    EVolumeState_CREATING = 2 [(NYT.NYson.NProto.enum_value_name) = "creating"];

    // Готов
    EVolumeState_READY = 3 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления volume
    EVolumeState_REMOVING = 4 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому volume
    EVolumeState_REMOVED = 5 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Volume находится в не валидном состоянии и значит будет полнотью пересобран
    EVolumeState_INVALID = 6 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

message TVolumeStatus {
    string id = 1;

    EVolumeState state = 2;

    // Количество неудачных попыток собрать вольюм
    uint32 fail_counter = 3;

    // Неструктурированное описание последней ошибки
    string fail_reason = 4;

    TCondition ready = 5;

    TCondition in_progress = 6;

    // Ревизия к которой относится volume
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 7;

    // spec_timestamp до которого обновлен volume
    uint64 spec_timestamp = 8;
}
