// IMPORTED FROM https://a.yandex-team.ru/arc/trunk/arcadia/infra/pod_agent/libs/service_iface/protos/pod_agent.proto
// PLEASE SEND ALL CHANGES THERE FIRST

syntax = "proto3";

//В данном случае описание интерфейса pod-driver выполняется для случая, когда изоляция осуществляется porto

option java_package = "ru.yandex.yp.client.pods";
option java_outer_classname = "Pod";

package NInfra.NPodAgent.API;

import "google/protobuf/timestamp.proto";
import "yt/core/yson/proto/protobuf_interop.proto";

option (NYT.NYson.NProto.derive_underscore_case_names) = true;

//TODO: добавить секреты
//TODO: itype (labels)
//TODO: propabilty + core dump

// NOTE: На первой итерации хочется выкристаллизовать минималистичный /spec /status интерфейс и по мере проработки use case
// добавлять дополнительные поля.

// Конфигурация Пода, передаваемая в Pod-agent.
// NOTE: сущности верхнего уровня имеют уникальные в рамках Пода идентификаторы (поле Id)
// и могут ссылаться друг на друга по этим идентификаторам (поля *Refs)
// NOTE: Валидация - необходимо проверить, что нет висячих ссылок
// NOTE: Валидация - На каждый Workload ссылается ровно один MutableWorkload, нет ссылок из MutableWorkload на несуществующие Workload
message TPodAgentSpec {
    //pod revision, server-side монотонно возрастаюшая последовательность
    uint32 Revision = 1;

    //идентификатор пода
    string Id = 2;

    //Слои, которые необходимо скачать в рамках лимитов @see ResourceGang
    TResourceGang Resources = 3;

    //Все вольюмы
    repeated TVolume Volumes = 4;

    //Все workload
    repeated TWorkload Workloads = 5;

    //Все окружения, в которых могут быть запущены Workloads
    repeated TBox Boxes = 8;

    //Часть Worklaod, изменение которой не приведет к полной пересборке Workload
    repeated TMutableWorkload MutableWorkloads = 9;
}

// Текущее состояние Пода, возвращаемое из Pod-agent
message TPodAgentStatus {
    //последняя известная pod revision
    uint32 Revision = 1;

    //идентификатор пода
    string Id = 2;

    // Момент отправки сообщения с агента
    uint64 HostTimestamp = 3;

    repeated TVolumeStatus Volumes = 4;

    repeated TLayerStatus Resources = 5;

    repeated TWorkloadStatus Workloads = 6;

    repeated TBoxStatus Boxes = 7;
    // Если хотя бы один из Ready вложенных T*Status имеет Status == EConditionStatus_UNKNOWN,
    // обращается в EConditionStatus_UNKNOWN.
    // Иначе, если хотя бы один из них имеет Status == EConditionStatus_FALSE,
    // обращается в EConditionStatus_FALSE.
    // Иначе обращается в EConditionStatus_TRUE.
    // LastTransitionTime -- максимальное значение Ready.LastTransitionTime среди всех вложеных T*Status
    TCondition Ready = 8;
    // Если хотя бы один из InProgress вложенных T*Status имеет Status == EConditionStatus_UNKNOWN,
    // обращается в EConditionStatus_UNKNOWN.
    // Иначе, если хотя бы один из них имеет Status == EConditionStatus_TRUE,
    // обращается в EConditionStatus_TRUE.
    // Иначе обращается в EConditionStatus_FALSe.
    // LastTransitionTime -- максимальное значение InProgress.LastTransitionTime среди всех вложеных T*Status
    TCondition InProgress = 9;
}

// Спека для получения расширенного debug состояния pod_agent
message TPodAgentDebugSpec {
    repeated string WorkloadIds = 1;
    repeated string ResourceIds = 2;
    repeated string VolumeIds = 3;
    repeated string BoxIds = 4;
}

// Расширенный debug status возвращаемый Pod-agent
message TPodAgentDebugStatus {
    // Состояние behavior tree для workloads в dot формате
    map<string, string> WorkloadTreeDots = 1 [(NYT.NYson.NProto.yson_map) = true];
    // Состояние behavior tree для resources в dot формате
    map<string, string> ResourceTreeDots = 2 [(NYT.NYson.NProto.yson_map) = true];
    // Состояние behavior tree для volumes в dot формате
    map<string, string> VolumeTreeDots = 3 [(NYT.NYson.NProto.yson_map) = true];
    // Состояние behavior tree для boxes в dot формате
    map<string, string> BoxTreeDots = 4 [(NYT.NYson.NProto.yson_map) = true];
}

//============================== SPEC ==========================
message TComputeResources {
    // Ограничения по CPU, в виртуальных миллиядрах (vcpu). Тем самым, заказав vcpu = 1000, мы получим одно виртуальное ядро.
    uint64 VCpuGuarantee = 2;
    uint64 VCpuLimit = 3;

    // Ограничения по памяти, в байтах
    uint64 MemoryGuarantee = 4;
    uint64 MemoryLimit = 5;
    uint64 AnonymousMemoryLimit = 6;

    // Свойства porto-контейнеров, задаваемые непосредственно.
    // Список доступных свойств смотри так: `portoctl --help`
    map<string, string> Properties = 1 [(NYT.NYson.NProto.yson_map) = true];
}

// Проверки целостности ресурса
message TVerification {
    // Контрольная сумма, формат <схема>:<значение> Поддерживаемые схемы "MD5:", "EMPTY:"  "SHA256:" - case sensitive
    string Checksum = 1;

    // Периодичность проверки контрольной суммы. При значении 0 проверка будет выполнена только 1 раз.
    //NOTE: добавить валидацию минимального значения периода проверки
    uint64 CheckPeriodMs = 2;
}

message TSandboxResource {
    string TaskType = 1;
    string TaskId = 2;
    string ResourceType = 3;
    string ResourceId = 4;
}

message TResourceMeta {
    oneof Meta {
        TSandboxResource SandboxResource = 2;
    }
}

message TResource {
    string Id = 1; // Уникальное имя ресурса (в рамках pod'а). Должно состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)

    //не нужно для Pod-agent
    TResourceMeta Meta = 2; // Мета информация о ресурсе, необходимо для интеграции с CI/CD

    //@see Verification
    TVerification Verification = 3;

    // URL для скачивания, протоколы: http, https, rbtorrent
    // Для записи строчки в файл URL должен быть равен "raw:<строка>"
    string Url = 4;

    oneof StorageRef {
        bool DefaultStorage = 5;
        string FileStorageRef = 6; //Указатель на файловый сторедж
    }
}

message TLayer {
    // Уникальный идентификатор (произвольная строка)
    string Id = 1;

    TResource Resource = 2;
}

enum EVolumeMountMode {
    EVolumeMountMode_READ_ONLY = 0 [(NYT.NYson.NProto.enum_value_name) = "read_only"];
    EVolumeMountMode_READ_WRITE = 1 [(NYT.NYson.NProto.enum_value_name) = "read_write"];
}

//Позволяет монитровать один вольюм в разные mountPoint
message TMountedVolume {
    //id Volume который требуется подмонтировать
    string VolumeRef = 1;
    // точка монтирования
    string MountPoint = 2;
    //ro, rw
    EVolumeMountMode Mode = 3;
}

message TRootfsVolume {
    // Квота на размер
    uint64 QuotaBytes = 1;

    // Слои, из которых собирается volume
    // как и в porto, слои идут в порядке top-layer;...;bottom-layer
    //NOTE: Валидация ids в списке должны быть уникальные
    repeated string LayerRefs = 4;
}

message TFileStorage {
    // Квота на размер
    uint64 QuotaBytes = 1;
}

message TGenericVolume {
    // Свойства porto volumes, задаваемые непосредственно.
    // Список доступных свойств смотри так: `portoctl --help`
    map<string, string> Properties = 3 [(NYT.NYson.NProto.yson_map) = true];

    // Слои, из которых собирается volume
    //NOTE: Валидация ids в списке должны быть уникальные
    repeated string LayerRefs = 4;
}

message TVolume {
    string Id = 1; // Уникальный в рамках pod идентификатор Volume. Должен состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)

    oneof Volume {
        TFileStorage Storage = 3;
        TGenericVolume Generic = 4;
    }
}

// Ограничения на время исполнения и интервал между запусками хука.
// Все времена в миллисекундах, однако времена, возвращаемые porto,
// имеют точность до секунды.
// Поэтому все значения будут округляться вверх до секунд.
// maxExecutionTimeMs - ограничение на время выполнения.
// Интервал между запусками рассчитывается по формуле
// min(maxRestartPeriodMs, minRestartPeriodMs + restartPeriodScaleMs * (restartPeriodBackoff ^ step))
// step считается с 0 и равен max(0, ConsecutiveSuccessesCounter - 1)
message TTimeLimit {
    uint64 InitialDelayMs = 1;
    uint64 RestartPeriodScaleMs = 2;
    uint64 RestartPeriodBackOff = 3;
    uint64 MaxRestartPeriodMs = 4;
    uint64 MinRestartPeriodMs = 5;
    uint64 MaxExecutionTimeMs = 6;
}


//Уточню позже
message SecretEnvSelector {
}

message LiteralEnvSelector {
    string Value = 1;
}

message TEnvVarValue {
    oneof Value {
        SecretEnvSelector SecretEnv = 2;
        LiteralEnvSelector LiteralEnv = 3;
    }
}

message TEnvVar {
    string Name = 1;
    TEnvVarValue Value = 2;
}

enum EWorkloadTargetState {
    EWorkloadTarget_ACTIVE = 0 [(NYT.NYson.NProto.enum_value_name) = "active"];
    EWorkloadTarget_REMOVED = 1 [(NYT.NYson.NProto.enum_value_name) = "removed"];
}

//pid-ns как изолируется относительно соседей
message TWorkload {
    // уникальный в рамках pod идентификатор Workload. Должeн состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string Id = 1;

    //Набор команд, запускаемых перед стартом основного процесса.
    //Гарантируется, что каждая отработает at least once.
    //Если команда падает - она перезапускается до победного
    repeated TUtilityContainer Init = 3;

    //Переменные окружения
    repeated TEnvVar Env = 5;

    //В случае возврата 0 - workload переходит в состояние ACTIVE, в других случаях SEMI_FAILED
    //Нет такого кода возврата status hook, при котором контейнер будет убит
    //Это соответствет текущему поведению instaceCTL и qloudinit
    //     https://wiki.yandex-team.ru/jandekspoisk/sepe/instancectl/#ortho-tags
    //     https://docs.platform.yandex-team.ru/doc/component#status_hook
    // Если это поведение поменять сделать миграцию автоматической будет сложнее
    // Если пользователь хочет пробпросить кастомный стуктурированный status, то рекомендуемое место для этого
    // stdout этого хука
    TReadinessCheck ReadinessCheck = 6;

    TStopPolicy StopPolicy = 7;

    //Указатель на Box, в котором надо запускаться
    string BoxRef = 8;

    //В случае ненулевого возврата - workload убивается и переходит в состояние DEACTIVATED_BY_LIVENESS
    TLivenessCheck LivenessCheck = 9;

    // В связи с изменением структуры контейнеров: https://st.yandex-team.ru/ISS-5791
    // Поля ComputeResources и CommandLine заменены на контейнер Start
    // Данный контейнер содержит ограничения для запуска основной команды и саму команду
    TUtilityContainer Start = 11;
}

// Mutable поля Workload
message TMutableWorkload {
    // Ссылка на workload
    string WorkloadRef = 1;

    EWorkloadTargetState TargetState = 2;
}

message TStopPolicy {
    oneof Policy {
        TUtilityContainer Stop = 1;
        THTTPGet HttpStop = 2;
    }

    // Количестно попыток выполнить gracefully stop перед тем, как убить процесс
    // Должно быть > 0
    uint32 MaxTries = 3;
}

message TBox {
    // уникальный в рамках pod идентификатор Box. Должен состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string Id = 1;

    TRootfsVolume Rootfs = 2;

    //NOTE: валидация должна гарантировать, что не может быть двух вольюмов в этом списке, у которых совпадает mountPoint
    //NOTE: валидация уникальности id в списке
    repeated TMountedVolume Volumes = 8;

    // Процессы, запускаемые при подготовке Box после создания вольюмов
    repeated TUtilityContainer Init = 9;
}

message THTTPGet {
    uint32 Port = 1;

    string Path = 2;
    string ExpectedAnswer = 3;

    //@see TimeLimit
    TTimeLimit TimeLimit = 4;
}

message TTcpCheck {
    uint32 Port = 1;

    //@see TimeLimit
    TTimeLimit TimeLimit = 2;
}

message TReadinessCheck {
    oneof Check {
        TUtilityContainer Container = 2;
        TTcpCheck TcpCheck = 3;
        THTTPGet HttpCheck = 4;
    }
}

message TLivenessCheck {
    oneof Check {
        TUtilityContainer Container = 1;
        TTcpCheck TcpCheck = 2;
        THTTPGet HttpCheck = 3;
    }
}

//Наследует Env от TWorkload
message TUtilityContainer {
    //атрибуты контейнера (по сути это сквозной проброс опций Porto)
    //Тут важно разделять интерфейс предоствляемый пользователю и внутренний между YP<->agent
    TComputeResources ComputeResources = 2;

    string CommandLine = 3;

    //@see TimeLimit
    TTimeLimit TimeLimit = 4;
}

//Позволяет выставить ограничение сверху на все закачки. Важным моментом является, что сумма лимитов
//ресурсов может быть больше, чем даже лимиты Pod. Поэтому pod-agent должен будет запускать закачки так:
//Снача запускаются закачки для активных workload и параллельно запускаются только те, которые можно разместить
//в рамках лимитов box
message TResourceGang {
    //Слои, все закачки происходят в рамках вычислительных
    //Идея убрать произвольные ресурсы, а оставить слои в том, чтобы форсить пользователя готовить во вне воспроизводимое
    //окружение для своего сервиса. По сути это аналог деплоя готовых docker образов.
    repeated TLayer Layers = 2;

    repeated TResource Resources = 3;
}

// ======================  STATUS ===================

message TBoxStatus {
    string Id = 1;

    EBoxState State = 2;

    repeated TContainerStatus Inits = 3;

    //Нужно понять удобно ли так
    repeated string VolumeRefs = 4;

    //Неструктурированное описание последней ошибки связанной c запуском контейнера
    string FailReason = 5;

    TCondition Ready = 6;

    TCondition InProgress = 7;

    repeated string RootfsLayerRefs = 8;
}

enum EBoxState {
    EBoxState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Ждет пока заимпортится rootfs
    EBoxState_WAITING_FOR_ROOTFS_LAYERS = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_rootfs_layers"];

    // В процессе сборки rootfs volume
    EBoxState_CREATING_ROOTFS_VOLUME = 2 [(NYT.NYson.NProto.enum_value_name) = "creating_rootfs_volume"];

    // Ждет пока соберутся MountedVolumes
    EBoxState_WAITING_FOR_VOLUMES = 3 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_volumes"];

    // Приликовывает MountedVolumes к RootfsVolume
    EBoxState_LINKING_VOLUMES = 4 [(NYT.NYson.NProto.enum_value_name) = "linking_volumes"];

    // Запуск Init процессов
    EBoxState_INIT_PROCESSES = 5 [(NYT.NYson.NProto.enum_value_name) = "init_processes"];

    // Вольюмы смонтированы, окружение готово к запуску хуков
    EBoxState_READY = 6 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления box
    EBoxState_REMOVING = 7 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому box
    EBoxState_REMOVED = 8 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Box находится в невалидном состоянии и значит будет полнотью пересобран
    EBoxState_INVALID = 9 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

//Состояние workload
//Q: Почему нет DEBUG состояния, чтобы поотлаживать упавшую джобу
//A: Дело в том, в pod agent не будет понятия джобы. pod agent запускает только сервисы.
//     одним из сервисов может быть сервис, который выполняет джобы.
enum EWorkloadState {
    EWorkloadState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Соответсвует ожиданию готовности Box
    EWorkloadState_WAITING_FOR_BOX = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_box"];

    // readiness сообщает, что Workload не готов
    EWorkloadState_SEMI_FAILURE = 2 [(NYT.NYson.NProto.enum_value_name) = "semi_failure"];

    // start hook запущен и status еще ни разу не завершился
    EWorkloadState_ACTIVATING = 3 [(NYT.NYson.NProto.enum_value_name) = "activating"];

    // Соответствует запущенному start hook при условии что хотябы единожды status завершился успешно
    EWorkloadState_ACTIVE = 4 [(NYT.NYson.NProto.enum_value_name) = "active"];

    // Соотвестует остановке start hook и работе stop hook
    EWorkloadState_DEACTIVATING = 5 [(NYT.NYson.NProto.enum_value_name) = "deactivating"];

    // Соотвествует процессу удаления workload
    EWorkloadState_REMOVING = 6 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому worload
    EWorkloadState_REMOVED = 7 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Workload находится в не валидном состоянии и значит будет полнотью пересобран
    EWorkloadState_INVALID = 8 [(NYT.NYson.NProto.enum_value_name) = "invalid"];

    // Workload deactivated by liveness
    EWorkloadState_DEACTIVATED_BY_LIVENESS = 9 [(NYT.NYson.NProto.enum_value_name) = "deactivated_by_liveness"];

    // running init commands
    EWorkloadState_INIT_PROCESESS = 10 [(NYT.NYson.NProto.enum_value_name) = "init_procesess"];
}

// Описание результата выполнения хука
enum EContainerState {
    EContainerState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Процесс завершился.
    EContainerState_EXITED = 1 [(NYT.NYson.NProto.enum_value_name) = "exited"];

    // Процесс убили из-за превышения памяти
    EContainerState_OUT_OF_MEMORY = 2 [(NYT.NYson.NProto.enum_value_name) = "out_of_memory"];

    // Произошел таймаут выполенния
    EContainerState_TIMEOUT = 3 [(NYT.NYson.NProto.enum_value_name) = "timeout"];

    // Процесс был убит извне (кто-то вызвал kill или destroy)
    EContainerState_KILLED_EXTERNALLY = 4 [(NYT.NYson.NProto.enum_value_name) = "killed_externally"];

    // Произошла системная ошибка (например ошибка от порто или т.п.)
    EContainerState_SYSTEM_FAILURE = 5 [(NYT.NYson.NProto.enum_value_name) = "system_failure"];

    EContainerState_RUNNING = 6 [(NYT.NYson.NProto.enum_value_name) = "running"];
    // Процесс ожидает истечения InitialDelayMs
    EContainerState_WAITING_INIT = 7 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];
    // Процесс ожидает истечения restart period - см. TTimeLimit
    EContainerState_WAITING_RESTART = 8 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];
}

//Q: Почему нет статистики контейнера
//A: Я считаю, что в данном случае сливать статистику в обратную связь бесполезно, т.к. нет возможности строить графики
//    если статистика реально нужна, то её надо выливать в какой-то из существующих сервисов: YT, solomon, golovan, statface
message TContainerStatus {
    EContainerState State = 1;

    int32 ReturnCode = 2;

    string Stderr = 3;

    string Stdout = 4;

    //Неструктурированное описание последней ошибки связанной c запуском контейнера
    string FailReason = 5;

    uint32 ZeroReturnCodeCounter = 6;
    uint32 NonZeroReturnCodeCounter = 7;
    uint32 OomCounter = 8;
    uint32 TimeoutCounter = 9;
    uint32 KilledExternallyCounter = 10;
    uint32 SystemFailureCounter = 11;
    uint32 ConsecutiveFailuresCounter = 12;
    uint32 ConsecutiveSuccessesCounter = 13;
}

enum EConditionStatus {
    EConditionStatus_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];
    EConditionStatus_TRUE = 1 [(NYT.NYson.NProto.enum_value_name) = "true"];
    EConditionStatus_FALSE = 2 [(NYT.NYson.NProto.enum_value_name) = "false"];
}

message TCondition {
    EConditionStatus Status = 10; // True, False, Unknown
    string Reason = 20; // One word (e.g. ProcessCrash) for computers and short summary
    string Message = 30; // Some human readable message
    google.protobuf.Timestamp LastTransitionTime = 40;
}

message TWorkloadStatus {

    // уникальный в рамках pod идентификатор Workload
    string Id = 1;

    EWorkloadState State = 2;

    repeated TContainerStatus Init = 3;

    //Добавить валидацию, что указан непустой start
    TContainerStatus Start = 4;

    TContainerStatus Stop = 5;

    TReadinessStatus ReadinessStatus = 6;

    TLivenessStatus LivenessStatus = 10;

    TCondition Ready = 7;

    TCondition InProgress = 8;

    // понять удобно ли
    string BoxRef = 9;

    // mutalbe target state
    EWorkloadTargetState TargetState = 11;
}

enum ECheckResult {
    ECheckResult_PENDING = 0 [(NYT.NYson.NProto.enum_value_name) = "pending"];
    ECheckResult_SUCCESS = 1 [(NYT.NYson.NProto.enum_value_name) = "success"];
}

message TTcpCheckStatus {
    ECheckResult CheckResult = 1;
}

message THttpCheckStatus {
    ECheckResult CheckResult = 1;
}

message TReadinessStatus {
    oneof Status {
        TContainerStatus ContainerStatus = 1;
        TTcpCheckStatus TcpCheckStatus = 2;
        THttpCheckStatus HttpCheckStatus = 3;
    }
}

message TLivenessStatus {
    oneof Status {
        TContainerStatus ContainerStatus = 1;
        TTcpCheckStatus TcpCheckStatus = 2;
        THttpCheckStatus HttpCheckStatus = 3;
    }
}

//Ресурс при скачивании и проверке проиходит через несколько стадий
enum ELayerState {
    ELayerState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    //в процессе скачивания
    ELayerState_DOWNLOADING = 1 [(NYT.NYson.NProto.enum_value_name) = "downloading"];

    //Проверка контрольной суммы
    ELayerState_VERIFYING = 2 [(NYT.NYson.NProto.enum_value_name) = "verifying"];

    //импортируется
    ELayerState_IMPORTING = 3 [(NYT.NYson.NProto.enum_value_name) = "importing"];

    //готов к использованию
    ELayerState_READY = 4 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления ресурса
    ELayerState_REMOVING = 5 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому ресурсу
    ELayerState_REMOVED = 6 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Layer находится в невалидном состоянии и значит будет полнотью пересобран
    ELayerState_INVALID = 7 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

//TODO: нужно придумать как сделать прогресс скачивания
message TLayerStatus {
    string Id = 1;

    ELayerState State = 2;

    //NOTE: нет гарантии монотонно растущих счётчиков, т.к. их значения могут быть удалены на хосте
    //Количество попыток скачать ресурс
    uint32 DownloadAttemptsCounter = 3;

    //Количество попыток проверить контрольную сумму
    uint32 VerificationAttemptsCounter = 4;

    //Общее количество ошибок связанное с ресурсом
    uint32 FailCounter = 5;

    //Неструктурированное описание последней ошибки связанной с ресурсом
    string FailReason = 6;

    TCondition Ready = 7;

    TCondition InProgress = 8;
}

enum EVolumeState {
    EVolumeState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // ждет пока заимпортятся layers
    EVolumeState_WAITING_FOR_LAYERS = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_layers"];

    //в процессе сборки
    EVolumeState_CREATING = 2 [(NYT.NYson.NProto.enum_value_name) = "creating"];

    //готов
    EVolumeState_READY = 3 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления volume
    EVolumeState_REMOVING = 4 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому volume
    EVolumeState_REMOVED = 5 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Volume находится в не валидном состоянии и значит будет полнотью пересобран
    EVolumeState_INVALID = 6 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

message TVolumeStatus {
    string Id = 1;

    EVolumeState State = 2;

    //Количество неудачных попыток собрать вольюм
    uint32 FailCounter = 3;

    //Неструктурированное описание последней ошибки связанной с томом
    string FailReason = 4;

    TCondition Ready = 5;

    TCondition InProgress = 6;

    // понять удобно ли
    repeated string LayerRefs = 7;
}
