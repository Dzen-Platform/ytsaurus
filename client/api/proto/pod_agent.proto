syntax = "proto3";

option python_package = "yp_proto.yp.client.api.proto";

option java_package = "ru.yandex.yp.client.pods";
option java_outer_classname = "Pod";
option java_multiple_files = true;

package NInfra.NPodAgent.API;

import "google/protobuf/timestamp.proto";
import "yt/core/yson/proto/protobuf_interop.proto";

option (NYT.NYson.NProto.derive_underscore_case_names) = true;

//TODO: itype (labels)
//TODO: coredump probabilty

// Конфигурация Пода, передаваемая в Pod-agent.
// NOTE: сущности верхнего уровня имеют уникальные в рамках Пода идентификаторы (поле Id)
// и могут ссылаться друг на друга по этим идентификаторам (поля *Refs)
// NOTE: Валидация - нет висячих ссылок
// NOTE: Валидация - на каждый Workload ссылается ровно один MutableWorkload, нет ссылок из MutableWorkload на несуществующие Workload
message TPodAgentSpec {
    //pod revision, server-side монотонно возрастаюшая последовательность
    uint32 revision = 1;

    //идентификатор пода
    string id = 2;

    //Слои и ресурсы, которые необходимо скачать в рамках лимитов @see ResourceGang
    TResourceGang resources = 3;

    //Все вольюмы
    repeated TVolume volumes = 4;

    //Все workload, изменение любого поля приводит к рестарту @see MutableWorkloads
    repeated TWorkload workloads = 5;

    //Все окружения, в которых могут быть запущены Workloads
    repeated TBox boxes = 8;

    //Часть Workload, изменение которой не приведет к полной пересборке Workload
    repeated TMutableWorkload mutable_workloads = 9;
}

// Кэш ресурсы, которые надо скачать на под
// Хеш ресурса считается как hash(Url, Checksum), т.е. он не зависит от Id/Revision/Meta/CheckPeriodMs/..
// Если в спеке пода окажется layer или ресурс, у которого совпал хеш с каким-то ресурсом из кэша,
// то этот ресурс не будет закачиваться заново, а просто подставится из кэша
// NOTE: Для всех TResource с одинаковым хешом выбирается минимальное из времен TVerification::CheckPeriodMs,
// т.е. если в спеку пода придет TResource, который лежит в кэше, но его период верификации меньше
// периода верификации кэш ресурса, этот ресурс начнет верифицироваться с меньшим периодом
// NOTE: Валидация - сущности имеют уникальные в рамках пода идентификаторы (Пара Id, Revision)
message TPodAgentResourceCacheSpec {
    // Кэш слои
    repeated TCacheLayer layers = 1;

    // Кэш ресурсы
    repeated TCacheResource static_resources = 2;
}

// Текущее состояние Пода, возвращаемое из Pod-agent
message TPodAgentStatus {
    //последняя известная pod revision
    uint32 revision = 1;

    //идентификатор пода
    string id = 2;

    // Момент отправки сообщения с агента
    uint64 host_timestamp = 3;

    repeated TVolumeStatus volumes = 4;

    TResourceGangStatus resource_gang = 5;

    repeated TWorkloadStatus workloads = 6;

    repeated TBoxStatus boxes = 7;
    // Если хотя бы один из Ready вложенных T*Status имеет Status == EConditionStatus_UNKNOWN,
    // обращается в EConditionStatus_UNKNOWN.
    // Иначе, если хотя бы один из них имеет Status == EConditionStatus_FALSE,
    // обращается в EConditionStatus_FALSE.
    // Иначе обращается в EConditionStatus_TRUE.
    // LastTransitionTime -- максимальное значение Ready.LastTransitionTime среди всех вложеных T*Status
    TCondition ready = 8;
    // Если хотя бы один из InProgress вложенных T*Status имеет Status == EConditionStatus_UNKNOWN,
    // обращается в EConditionStatus_UNKNOWN.
    // Иначе, если хотя бы один из них имеет Status == EConditionStatus_TRUE,
    // обращается в EConditionStatus_TRUE.
    // Иначе обращается в EConditionStatus_FALSE.
    // LastTransitionTime -- максимальное значение InProgress.LastTransitionTime среди всех вложеных T*Status
    TCondition in_progress = 9;

    TResourceGangStatus resource_cache = 10;

    // yp timestamp последнего обновления спецификации пода
    uint64 spec_timestamp = 11;
}

//============================== SPEC ==========================
message TComputeResources {
    reserved 1;

    // Ограничения по CPU, в виртуальных миллиядрах (vcpu). Тем самым, заказав vcpu = 1000, мы получим одно виртуальное ядро.
    uint64 vcpu_guarantee = 2;
    uint64 vcpu_limit = 3;

    // Ограничения по памяти, в байтах
    uint64 memory_guarantee = 4;
    uint64 memory_limit = 5;
    uint64 anonymous_memory_limit = 6;

    // Если true иммигрирует кэш при незначительной ошибке страницы, по умолчанию: false.
    bool recharge_on_pgfault = 7;
}

// Проверки целостности ресурса
message TVerification {
    // Контрольная сумма, формат <схема>:<значение> Поддерживаемые схемы "MD5:", "EMPTY:"  "SHA256:" - case sensitive
    string checksum = 1;

    // Периодичность проверки контрольной суммы. Первая проверка выполняется сразу после завершения скачивания.
    //TODO: добавить валидацию минимального значения периода проверки
    uint64 check_period_ms = 2;
}

message TSandboxResource {
    string task_type = 1;
    string task_id = 2;
    string resource_type = 3;
    string resource_id = 4;
}

message TResourceMeta {
    oneof meta {
        TSandboxResource sandbox_resource = 2;
    }
}

message TResource {
    string id = 1; // Уникальное имя ресурса (в рамках pod'а). Должно состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)

    //не нужно для Pod-agent
    TResourceMeta meta = 2; // Мета информация о ресурсе, необходимо для интеграции с CI/CD

    //@see TVerification
    TVerification verification = 3;

    // URL для скачивания, протоколы: http, https, rbtorrent
    // Для записи строчки в файл URL должен быть равен "raw:<строка>"
    // Только для тестов: можно указать путь к файлу на хосте "local:<filepath>"
    string url = 4;

    //TODO: not implemented
    oneof storage_ref {
        bool default_storage = 5;
        string file_storage_ref = 6; //Указатель на файловый сторедж
    }

    // place, где будет расположен ресурс
    // ресурс будт скачан на porto volume, созданный с этим place
    // NOTE: должен совпадать с place у volume, которые используют этот ресурс
    string place = 7;
}

message TCacheResource {
    // Ревизия кэш ресурса
    uint32 revision = 1;

    TResource resource = 2;
}

message TLayer {
    reserved "resource"; reserved 2;

    // Уникальный идентификатор (произвольная строка)
    string id = 1;

    //не нужно для Pod-agent
    TResourceMeta meta = 3; // Мета информация о ресурсе, необходимо для интеграции с CI/CD

    // Контрольная сумма, формат <схема>:<значение> Поддерживаемые схемы "MD5:", "EMPTY:"  "SHA256:" - case sensitive
    string checksum = 4;

    // URL для скачивания, протоколы: http, https, rbtorrent
    // Для записи строчки в файл URL должен быть равен "raw:<строка>"
    // Только для тестов: можно указать путь к файлу на хосте "local:<filepath>"
    string url = 5;

    // place, где будет расположен layer
    // передается as is в porto
    // NOTE: должен совпадать с place у volume, которые используют этот слой
    string place = 6;
}

message TCacheLayer {
    // Ревизия кэш слоя
    uint32 revision = 1;

    TLayer layer = 2;
}

enum EVolumeMountMode {
    EVolumeMountMode_READ_ONLY = 0 [(NYT.NYson.NProto.enum_value_name) = "read_only"];
    EVolumeMountMode_READ_WRITE = 1 [(NYT.NYson.NProto.enum_value_name) = "read_write"];
}

//Позволяет монитровать один вольюм в разные mountPoint
message TMountedVolume {
    //id Volume который требуется подмонтировать
    string volume_ref = 1;
    // точка монтирования
    string mount_point = 2;
    //ro, rw
    EVolumeMountMode mode = 3;
}

message TMountedStaticResource {
    // id Resource который требуется подмонтировать
    string resource_ref = 1;
    // точка монтирования
    string mount_point = 2;
}

message TRootfsVolume {
    reserved 2, 3, 5;

    // Квота на размер
    // NOTE: не обрабатывается - porto не умеет во вложенные квоты по диску
    uint64 quota_bytes = 1;

    // place, где будет расположен volume
    // передается as is в porto
    // NOTE: Валидация должен совпадать с place у слоев, из которых собирается volume
    string place = 6;

    // Слои, из которых собирается volume
    // как и в porto, слои идут в порядке top-layer;...;bottom-layer
    // NOTE: Валидация ids в списке должны быть уникальные
    repeated string layer_refs = 4;
}

message TFileStorage {
    // Квота на размер
    // NOTE: не обрабатывается - porto не умеет во вложенные квоты по диску
    uint64 quota_bytes = 1;
}

message TGenericVolume {
    reserved 1, 2, 3;

    // Квота на размер
    // NOTE: не обрабатывается - porto не умеет во вложенные квоты по диску
    uint64 quota_bytes = 5;

    // place, где будет расположен volume
    // передается as is в porto
    // NOTE: Валидация должен совпадать с place у слоев, из которых собирается volume
    string place = 6;

    // Слои, из которых собирается volume
    // NOTE: Валидация ids в списке должны быть уникальные
    repeated string layer_refs = 4;
}

message TVolume {
    string id = 1; // Уникальный в рамках pod идентификатор Volume. Должен состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)

    oneof volume {
        TFileStorage storage = 3; // TODO: not implemented
        TGenericVolume generic = 4;
    }
}

// Ограничения на время исполнения и интервал между запусками хука.
// Все времена в миллисекундах, однако времена, возвращаемые porto,
// имеют точность до секунды.
// Поэтому все значения будут округляться вверх до секунд.
// maxExecutionTimeMs - ограничение на время выполнения.
// Интервал между запусками рассчитывается по формуле
// min(maxRestartPeriodMs, minRestartPeriodMs + restartPeriodScaleMs * (restartPeriodBackoff ^ step))
// step считается с 0 и равен max(0, ConsecutiveFailuresCounter - 1) для workload stop
// и max(0, ConsecutiveSuccessesCounter - 1) для всех остальных хуков
message TTimeLimit {
    uint64 initial_delay_ms = 1;
    uint64 restart_period_scale_ms = 2;
    uint64 restart_period_back_off = 3;
    uint64 max_restart_period_ms = 4; // treat 0 as 18446744073709551615 (UINT64_MAX)
    uint64 min_restart_period_ms = 5; // treat 0 as 30000
    uint64 max_execution_time_ms = 6; // treat 0 as 1800000
}

message TTimeLimitStatus {
    google.protobuf.Timestamp last_call_time = 1;
    uint32 consecutive_successes_counter = 2;
    uint32 consecutive_failures_counter = 3;
}

// Id секрета из TPodAgentRequest.Secrets
// Alias секрета из TPodAgentRequest.Secrets
// В момент обработки спеки будет добавлена переменная окружения с значением равным value секрета
message SecretEnvSelector {
    string id = 1;

    string alias = 2;
}

message LiteralEnvSelector {
    string value = 1;
}

message TEnvVarValue {
    oneof value {
        SecretEnvSelector secret_env = 2;
        LiteralEnvSelector literal_env = 3;
    }
}

message TEnvVar {
    string name = 1;
    TEnvVarValue value = 2;
}

enum EContainerULimitType {
    // address space
    EContainerULimit_AS = 0 [(NYT.NYson.NProto.enum_value_name) = "as"];

    // core file size
    EContainerULimit_CORE = 1 [(NYT.NYson.NProto.enum_value_name) = "core"];

    // data seg size
    EContainerULimit_DATA = 2 [(NYT.NYson.NProto.enum_value_name) = "data"];

    // max locked memory
    EContainerULimit_MEMLOCK = 3 [(NYT.NYson.NProto.enum_value_name) = "memlock"];

    // stack size
    EContainerULimit_STACK = 4 [(NYT.NYson.NProto.enum_value_name) = "stack"];

    // file size
    EcontainerULimit_FSIZE = 5 [(NYT.NYson.NProto.enum_value_name) = "fsize"];
}

message TUlimitSoft {
    EContainerULimitType name = 1;
    uint64 value = 2;
}

enum EWorkloadTargetState {
    EWorkloadTarget_ACTIVE = 0 [(NYT.NYson.NProto.enum_value_name) = "active"];
    EWorkloadTarget_REMOVED = 1 [(NYT.NYson.NProto.enum_value_name) = "removed"];
}

message TWorkload {
    reserved 2,4,10;

    // уникальный в рамках pod идентификатор Workload. Должeн состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string id = 1;

    //Указатель на Box, в котором надо запускаться
    string box_ref = 8;

    //Переменные окружения - прокидываются во все контейнеры ворклода
    repeated TEnvVar env = 5;

    //Soft лимиты окружения - прокидываются во все контейнеры ворклода
    repeated TUlimitSoft ulimit_soft = 14;

    //Набор команд, запускаемых перед стартом основного процесса.
    //Гарантируется, что каждая отработает at least once.
    //Если команда падает - она перезапускается до победного
    repeated TUtilityContainer init = 3;

    // Описание основного процесса
    TUtilityContainer start = 11;

    //В случае возврата 0 - workload переходит в состояние ACTIVE, в других случаях SEMI_FAILED
    //Нет такого кода возврата status hook, при котором контейнер будет убит
    //Это соответствет текущему поведению instaceCTL и qloudinit
    //     https://wiki.yandex-team.ru/jandekspoisk/sepe/instancectl/#ortho-tags
    //     https://docs.platform.yandex-team.ru/doc/component#status_hook
    // Если это поведение поменять сделать миграцию автоматической будет сложнее
    // Если пользователь хочет пробпросить кастомный стуктурированный status, то рекомендуемое место для этого
    // stdout этого хука
    TReadinessCheck readiness_check = 6;

    //В случае ненулевого возврата - workload убивается и переходит в состояние DEACTIVATED_BY_LIVENESS
    TLivenessCheck liveness_check = 9;

    TStopPolicy stop_policy = 7;

    TDestroyPolicy destroy_policy = 12;

    //передавать/не передавать логи в yt при помощи push client
    //описание: https://wiki.yandex-team.ru/users/aneporada/push-agent-config/
    bool transmit_logs = 13;
}

// Mutable поля Workload
message TMutableWorkload {
    // Ссылка на workload
    string workload_ref = 1;

    EWorkloadTargetState target_state = 2;
}

// При переводе TMutableWorkload.TargetState в состояние REMOVED или обновления ревизии workload или любой его зависимости
// будет вызван stop hook, который должен выполнить gracefully завершение контейнера start
// Если после завершения stop hook контейнер start находится в состоянии dead или stopped, то он будет уничтожен,
// иначе stop hook будет перезапускаться до тех пор, пока контейнер start не перейдет в одно из этих состояний
// Если stop hook был запущен MaxTries раз, но так и не перевел start в состоянии dead или stopped, то start будет немедленно убит
// Если stop hook выполняется при помощи контейнера и завершился с НУЛЕВЫМ кодом возврата, но start не в состоянии dead или stopped,
// то start будет немедленно убит
message TStopPolicy {
    reserved 1, 2;

    oneof policy {
        TUtilityContainer container = 4;
        THttpGet http_get = 5;
    }

    // Количестно попыток выполнить gracefully stop перед тем, как убить процесс
    // Должно быть > 0
    uint32 max_tries = 3;
}

// При удалении workload из спеки
// будет вызван destroy hook, который выпонится только после окончания выполнения stop hook и перехода start контейнера в состояние dead.
// в случае если destroy hook завершится ненулевым кодом возврата, он будет перезапущен MaxTries раз
// пока не завершится успехом
message TDestroyPolicy {
    reserved 1, 2;

    oneof policy {
        TUtilityContainer container = 4;
        THttpGet http_get = 5;
    }

    // Количестно попыток выполнить gracefully destroy перед тем, как убить процесс
    // Должно быть > 0
    uint32 max_tries = 3;
}

// Обеспечивает изоляцию по диску и pidns
// Сеть между боксами не изолирована - workloadы разных боксов могут общаться друг с другом по localhost
message TBox {
    // уникальный в рамках pod идентификатор Box. Должен состоять только из символов, разрешенных в имени porto контейнера. (a..z, A..Z, 0..9, _-@:.)
    string id = 1;

    TRootfsVolume rootfs = 2;

    // Ограничения на meta контейнер Box
    TComputeResources compute_resources = 12;

    // Переменные окружения - прокидываются во все init контейнеры бокса
    repeated TEnvVar env = 13;

    // если указано true
    // pod agent создает bind volume из <pod_chroot>/place/berkanavt/supervisor в <box_chroot>/place/berkanavt/supervisor
    // На файловой системе box'а обязательно наличие директории /place/berkanavt/supervisor и следующих симлинков (без них скачивание/раздача работать не будут совсем):
    //   /skynet => /Berkanavt/supervisor/base/active
    //   /usr/local/bin/sky => /skynet/tools/sky
    //   /Berkanavt => /place/berkanavt
    // Эти директории и симлинки можно добавить с помощью небольшого слоя sbr:922226367
    bool bind_skynet = 11;

    //TODO: валидация должна гарантировать, что не может быть двух вольюмов в этом списке, у которых совпадает mountPoint
    //TODO: валидация уникальности id в списке
    repeated TMountedVolume volumes = 8;

    // Процессы, запускаемые при подготовке Box после создания вольюмов
    repeated TUtilityContainer init = 9;

    //TODO: валидация должна гарантировать, что не может быть двух ресурсов в этом списке, у которых совпадает mountPoint
    //TODO: валидация уникальности id в списке
    repeated TMountedStaticResource static_resources = 10;
}

// Успешными кодами ответов считаются те, что лежат в полуинтервале [200, 300)
message THttpGet {
    uint32 port = 1;

    // Путь к ручке, например: "/ping"
    // treat empty string as "/"
    string path = 2;
    // Только для Readiness check и Liveness check
    string expected_answer = 3;

    //@see TimeLimit
    TTimeLimit time_limit = 4;
}

// проверяет только, что connect по данному порту успешно завершился
message TTcpCheck {
    uint32 port = 1;

    //@see TimeLimit
    TTimeLimit time_limit = 2;
}

message TReadinessCheck {
    reserved 4;

    oneof check {
        TUtilityContainer container = 2;
        TTcpCheck tcp_check = 3;
        THttpGet http_get = 5;
    }
}

message TLivenessCheck {
    reserved 3;

    oneof check {
        TUtilityContainer container = 1;
        TTcpCheck tcp_check = 2;
        THttpGet http_get = 4;
    }
}

//Наследует Env от TWorkload
message TUtilityContainer {
    reserved 5;
    //атрибуты контейнера (по сути это сквозной проброс опций Porto)
    //Тут важно разделять интерфейс предоствляемый пользователю и внутренний между YP<->agent
    TComputeResources compute_resources = 2;

    string command_line = 3;

    //@see TimeLimit
    TTimeLimit time_limit = 4;

    // параметры обработки корок
    string core_command = 6;

    // user of container processes
    // treat empty string as root
    string user = 7;

    // group of container processes
    // treat empty string as root
    string group = 8;
}

//Позволяет выставить ограничение сверху на все закачки. Важным моментом является, что сумма лимитов
//ресурсов может быть больше, чем даже лимиты Pod. Поэтому pod-agent должен будет запускать закачки так:
//Снача запускаются закачки для активных workload и параллельно запускаются только те, которые можно разместить
//в рамках лимитов box
message TResourceGang {
    //Идея убрать произвольные ресурсы, а оставить слои в том, чтобы форсить пользователя готовить во вне воспроизводимое
    //окружение для своего сервиса. По сути это аналог деплоя готовых docker образов.
    repeated TLayer layers = 2;

    repeated TResource static_resources = 3;
}

// ======================  STATUS ===================

message TBoxStatus {
    string id = 1;

    EBoxState state = 2;

    repeated TContainerStatus inits = 3;

    // Адрес из подсети c id 'boxes_subnet', выделенной на поде (см ip6_subnet_allocations)
    // Пустая строка, если подсеть не выделена
    string ip6_address = 10;

    // Имя porto контейнера (относительно корневого контейнера пода)
    string container_name = 11;

    // Неструктурированное описание последней ошибки
    string fail_reason = 5;

    TCondition ready = 6;

    TCondition in_progress = 7;

    // Ревизия к которой относится box
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 8;

    // Количество неудачных попыток собрать box
    uint32 fail_counter = 9;

    // spec_timestamp до которого обновлен box
    uint64 spec_timestamp = 12;
}

enum EBoxState {
    EBoxState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Ждет пока заимпортится rootfs
    EBoxState_WAITING_FOR_ROOTFS_LAYERS = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_rootfs_layers"];

    // В процессе сборки rootfs volume
    EBoxState_CREATING_ROOTFS_VOLUME = 2 [(NYT.NYson.NProto.enum_value_name) = "creating_rootfs_volume"];

    // Ждет пока соберутся MountedVolumes
    EBoxState_WAITING_FOR_VOLUMES = 3 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_volumes"];

    // Приликовывает MountedVolumes к RootfsVolume
    EBoxState_LINKING_VOLUMES = 4 [(NYT.NYson.NProto.enum_value_name) = "linking_volumes"];

    // Запуск Init процессов
    EBoxState_INIT_PROCESSES = 5 [(NYT.NYson.NProto.enum_value_name) = "init_processes"];

    // Вольюмы смонтированы, окружение готово к запуску хуков
    EBoxState_READY = 6 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления box
    EBoxState_REMOVING = 7 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому box
    EBoxState_REMOVED = 8 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Box находится в невалидном состоянии и значит будет полнотью пересобран
    EBoxState_INVALID = 9 [(NYT.NYson.NProto.enum_value_name) = "invalid"];

    // Ждет пока заимпортятся статические ресурсы
    EBoxState_WAITING_FOR_STATIC_RESOURCES = 10 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_static_resources"];
}

//Q: Почему нет DEBUG состояния, чтобы поотлаживать упавшую джобу
//A: Дело в том, в pod agent не будет понятия джобы. pod agent запускает только сервисы.
//     одним из сервисов может быть сервис, который выполняет джобы.
enum EWorkloadState {
    EWorkloadState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Соответсвует ожиданию готовности Box
    EWorkloadState_WAITING_FOR_BOX = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_box"];

    // readiness сообщает, что Workload не готов
    EWorkloadState_SEMI_FAILURE = 2 [(NYT.NYson.NProto.enum_value_name) = "semi_failure"];

    // start hook запущен и status еще ни разу не завершился
    EWorkloadState_ACTIVATING = 3 [(NYT.NYson.NProto.enum_value_name) = "activating"];

    // Соответствует запущенному start hook при условии что хотябы единожды status завершился успешно
    EWorkloadState_ACTIVE = 4 [(NYT.NYson.NProto.enum_value_name) = "active"];

    // Соотвестует остановке start hook и работе stop hook
    EWorkloadState_DEACTIVATING = 5 [(NYT.NYson.NProto.enum_value_name) = "deactivating"];

    // Соотвествует процессу удаления workload
    EWorkloadState_REMOVING = 6 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому worload
    EWorkloadState_REMOVED = 7 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Workload находится в не валидном состоянии и значит будет полнотью пересобран
    EWorkloadState_INVALID = 8 [(NYT.NYson.NProto.enum_value_name) = "invalid"];

    // Workload deactivated by liveness
    EWorkloadState_DEACTIVATED_BY_LIVENESS = 9 [(NYT.NYson.NProto.enum_value_name) = "deactivated_by_liveness"];

    // running init commands
    EWorkloadState_INIT_PROCESESS = 10 [(NYT.NYson.NProto.enum_value_name) = "init_procesess"];
}

// Описание результата выполнения хука
enum EContainerState {
    EContainerState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Процесс завершился.
    EContainerState_EXITED = 1 [(NYT.NYson.NProto.enum_value_name) = "exited"];

    // Процесс убили из-за превышения памяти
    EContainerState_OUT_OF_MEMORY = 2 [(NYT.NYson.NProto.enum_value_name) = "out_of_memory"];

    // Произошел таймаут выполенния
    EContainerState_TIMEOUT = 3 [(NYT.NYson.NProto.enum_value_name) = "timeout"];

    // Процесс был убит извне (кто-то вызвал kill или destroy)
    EContainerState_KILLED_EXTERNALLY = 4 [(NYT.NYson.NProto.enum_value_name) = "killed_externally"];

    // Произошла системная ошибка (например ошибка от порто или т.п.)
    EContainerState_SYSTEM_FAILURE = 5 [(NYT.NYson.NProto.enum_value_name) = "system_failure"];

    EContainerState_RUNNING = 6 [(NYT.NYson.NProto.enum_value_name) = "running"];
    // Процесс ожидает истечения InitialDelayMs
    EContainerState_WAITING_INIT = 7 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];
    // Процесс ожидает истечения restart period - см. TTimeLimit
    EContainerState_WAITING_RESTART = 8 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];
}

//Q: Почему нет статистики контейнера
//A: Я считаю, что в данном случае сливать статистику в обратную связь бесполезно, т.к. нет возможности строить графики
//    если статистика реально нужна, то её надо выливать в какой-то из существующих сервисов: YT, solomon, golovan, statface
message TContainerStatus {
    reserved 1, 2, 3, 4, 5, 7, 12, 13, 14;

    message TAttemptFeedback {
        EContainerState state = 1;

        int32 return_code = 2;

        // Последний 4KB stderr
        string stderr = 3;

        // Последние 4KB stdout
        string stdout = 4;

        //Неструктурированное описание последней ошибки связанной c запуском контейнера
        string fail_reason = 5;
    }

    TAttemptFeedback current = 16;
    TAttemptFeedback last = 17;

    uint32 zero_return_code_counter = 6;
    uint32 positive_return_code_counter = 18;
    uint32 oom_counter = 8;
    uint32 timeout_counter = 9;
    uint32 killed_externally_counter = 10;
    uint32 system_failure_counter = 11;

    TTimeLimitStatus time_limit = 15;
}

enum EConditionStatus {
    EConditionStatus_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];
    EConditionStatus_TRUE = 1 [(NYT.NYson.NProto.enum_value_name) = "true"];
    EConditionStatus_FALSE = 2 [(NYT.NYson.NProto.enum_value_name) = "false"];
}

message TCondition {
    EConditionStatus status = 10; // True, False, Unknown
    string reason = 20; // One word (e.g. ProcessCrash) for computers and short summary
    string message = 30; // Some human readable message
    google.protobuf.Timestamp last_transition_time = 40;
}

message TWorkloadStatus {
    reserved 5, 13;

    // уникальный в рамках pod идентификатор Workload
    string id = 1;

    EWorkloadState state = 2;

    repeated TContainerStatus init = 3;

    //Добавить валидацию, что указан непустой start
    TContainerStatus start = 4;

    TStopStatus stop_status = 14;

    TDestroyStatus destroy_status = 15;

    TReadinessStatus readiness_status = 6;

    TLivenessStatus liveness_status = 10;

    TCondition ready = 7;

    TCondition in_progress = 8;

    // mutalbe target state
    EWorkloadTargetState target_state = 11;

    // Ревизия к которой относится workload
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 12;

    // spec_timestamp до которого обновлен workload
    uint64 spec_timestamp = 16;
}

enum EHttpGetState {
    EHttpGetState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Ошибка во время выполнения(превышен таймаут, ошибка соединения, ...)
    EHttpGetState_FAILURE = 1 [(NYT.NYson.NProto.enum_value_name) = "failure"];
    // Ответ не равен THttpGet::ExpectedAnswer, только для Readiness check и Liveness check
    EHttpGetState_WRONG_ANSWER = 2 [(NYT.NYson.NProto.enum_value_name) = "wrong_answer"];

    EHttpGetState_RUNNING = 3 [(NYT.NYson.NProto.enum_value_name) = "running"];
    // Ожидание истечения InitialDelayMs
    EHttpGetState_WAITING_INIT = 4 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];
    // Ожидание истечения restart period - см. TTimeLimit
    EHttpGetState_WAITING_RESTART = 5 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];
}

enum ETcpCheckState {
    ETcpCheckState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // Connect не завершился успешно
    ETcpCheckState_FAILURE = 1 [(NYT.NYson.NProto.enum_value_name) = "failure"];

    ETcpCheckState_RUNNING = 2 [(NYT.NYson.NProto.enum_value_name) = "running"];
    // Ожидание истечения InitialDelayMs
    ETcpCheckState_WAITING_INIT = 3 [(NYT.NYson.NProto.enum_value_name) = "waiting_init"];
    // Ожидание истечения restart period - см. TTimeLimit
    ETcpCheckState_WAITING_RESTART = 4 [(NYT.NYson.NProto.enum_value_name) = "waiting_restart"];
}

message TTcpCheckStatus {
    reserved 1, 2, 3, 4, 6;

    message TAttemptFeedback {
        ETcpCheckState state = 1;
        string fail_reason = 2;
    }

    TAttemptFeedback current = 7;
    TAttemptFeedback last = 8;

    TTimeLimitStatus time_limit = 5;
}

message THttpGetStatus {
    reserved 1, 2, 3, 4, 6, 8;

    message TAttemptFeedback {
        EHttpGetState state = 1;
        string fail_reason = 2;
        string inner_fail_reason = 3;
    }

    TAttemptFeedback current = 9;
    TAttemptFeedback last = 10;

    uint32 requests_count = 7;

    TTimeLimitStatus time_limit = 5;
}

message TStopStatus {
    reserved 2;

    oneof status {
        TContainerStatus container_status = 1;
        THttpGetStatus http_get_status = 3;
    }
}

message TDestroyStatus {
    reserved 2;

    oneof status {
        TContainerStatus container_status = 1;
        THttpGetStatus http_get_status = 3;
    }
}

message TReadinessStatus {
    reserved 3;

    oneof status {
        TContainerStatus container_status = 1;
        TTcpCheckStatus tcp_check_status = 2;
        THttpGetStatus http_get_status = 4;
    }
}

message TLivenessStatus {
    reserved 3;

    oneof status {
        TContainerStatus container_status = 1;
        TTcpCheckStatus tcp_check_status = 2;
        THttpGetStatus http_get_status = 4;
    }
}

//Ресурс при скачивании и проверке проиходит через несколько стадий
enum ELayerState {
    ELayerState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    //в процессе скачивания
    ELayerState_DOWNLOADING = 1 [(NYT.NYson.NProto.enum_value_name) = "downloading"];

    //Проверка контрольной суммы
    ELayerState_VERIFYING = 2 [(NYT.NYson.NProto.enum_value_name) = "verifying"];

    //импортируется
    ELayerState_IMPORTING = 3 [(NYT.NYson.NProto.enum_value_name) = "importing"];

    //готов к использованию
    ELayerState_READY = 4 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления ресурса
    ELayerState_REMOVING = 5 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому ресурсу
    ELayerState_REMOVED = 6 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Layer находится в невалидном состоянии и значит будет полнотью пересобран
    ELayerState_INVALID = 7 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

//Статический ресурс при скачивании и проверке проиходит через несколько стадий
enum EStaticResourceState {
    EStaticResourceState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    //в процессе скачивания
    EStaticResourceState_DOWNLOADING = 1 [(NYT.NYson.NProto.enum_value_name) = "downloading"];

    //Проверка контрольной суммы
    EStaticResourceState_VERIFYING = 2 [(NYT.NYson.NProto.enum_value_name) = "verifying"];

    // Соотвествует процессу удаления ресурса
    EStaticResourceState_REMOVING = 3 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвествует удалённому ресурсу
    EStaticResourceState_REMOVED = 4 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    //готов к использованию
    EStaticResourceState_READY = 5 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Ресурс находится в невалидном состоянии
    EStaticResourceState_INVALID = 7 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

//TODO: нужно придумать как сделать прогресс скачивания
message TLayerStatus {
    string id = 1;

    ELayerState state = 2;

    //NOTE: нет гарантии монотонно растущих счётчиков, т.к. их значения могут быть удалены на хосте
    //Количество попыток скачать ресурс
    uint32 download_attempts_counter = 3;

    //Количество попыток проверить контрольную сумму
    uint32 verification_attempts_counter = 4;

    //Общее количество ошибок связанное с ресурсом
    uint32 fail_counter = 5;

    // Неструктурированное описание последней ошибки
    string fail_reason = 6;

    TCondition ready = 7;

    TCondition in_progress = 8;

    // Ревизия к которой относится layer
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 9;

    // spec_timestamp до которого обновлен layer
    uint64 spec_timestamp = 10;
}

message TStaticResourceStatus {
    string id = 1;

    EStaticResourceState state = 2;

    //NOTE: нет гарантии монотонно растущих счётчиков, т.к. их значения могут быть удалены на хосте
    //Количество попыток скачать ресурс
    uint32 download_attempts_counter = 3;

    //Количество попыток проверить контрольную сумму
    uint32 verification_attempts_counter = 4;

    //Общее количество ошибок связанное с ресурсом
    uint32 fail_counter = 5;

    // Неструктурированное описание последней ошибки
    string fail_reason = 6;

    TCondition ready = 7;

    TCondition in_progress = 8;

    // Ревизия к которой относится layer
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 9;

    // spec_timestamp до которого обновлен static_resource
    uint64 spec_timestamp = 10;
}

message TResourceGangStatus {
    repeated TLayerStatus layers = 1;

    repeated TStaticResourceStatus static_resources = 2;
}

enum EVolumeState {
    EVolumeState_UNKNOWN = 0 [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    // ждет пока заимпортятся layers
    EVolumeState_WAITING_FOR_LAYERS = 1 [(NYT.NYson.NProto.enum_value_name) = "waiting_for_layers"];

    //в процессе сборки
    EVolumeState_CREATING = 2 [(NYT.NYson.NProto.enum_value_name) = "creating"];

    //готов
    EVolumeState_READY = 3 [(NYT.NYson.NProto.enum_value_name) = "ready"];

    // Соотвествует процессу удаления volume
    EVolumeState_REMOVING = 4 [(NYT.NYson.NProto.enum_value_name) = "removing"];

    // Соотвестует удалённому volume
    EVolumeState_REMOVED = 5 [(NYT.NYson.NProto.enum_value_name) = "removed"];

    // Volume находится в не валидном состоянии и значит будет полнотью пересобран
    EVolumeState_INVALID = 6 [(NYT.NYson.NProto.enum_value_name) = "invalid"];
}

message TVolumeStatus {
    string id = 1;

    EVolumeState state = 2;

    //Количество неудачных попыток собрать вольюм
    uint32 fail_counter = 3;

    // Неструктурированное описание последней ошибки
    string fail_reason = 4;

    TCondition ready = 5;

    TCondition in_progress = 6;

    // Ревизия к которой относится volume
    // Скоро будет удалена в пользу spec_timestamp: DEPLOY-417
    uint32 revision = 7;

    // spec_timestamp до которого обновлен volume
    uint64 spec_timestamp = 8;
}
