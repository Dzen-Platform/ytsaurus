package NYP.NClient.NApi.NProto;

import "google/protobuf/timestamp.proto";

import "yt/core/yson/proto/protobuf_interop.proto";

import "yp/client/api/proto/data_model.proto";
import "yp/client/api/proto/autogen.proto";
import "yp/client/api/proto/enums.proto";

import "google/protobuf/duration.proto";

option python_package = "yp_proto.yp.client.api.proto";

option java_package = "ru.yandex.yp.client.api";
option java_outer_classname = "Object";

option go_package = "a.yandex-team.ru/yp/go/proto/ypapi";

////////////////////////////////////////////////////////////////////////////////

// Describes the desired format of TPayload.
enum EPayloadFormat
{
    // Indicates a legacy client that is not aware of formats.
    PF_NONE = 0;
    PF_YSON = 1;
    PF_PROTOBUF = 2;
}

// Represents a polymorphic payload.
message TPayload
{
    oneof value {
        bool null = 1;
        bytes yson = 2 [(NYT.NYson.NProto.yson_string) = true];
        bytes protobuf = 3;
    }
}

////////////////////////////////////////////////////////////////////////////////

message TAttributeSelector
{
    // YPaths of requested attributes.
    repeated string paths = 1;
}

message TAttributeList
{
    // COMPAT(babenko): deprecated; use value_payloads instead.
    // Values are in YSON; nulls are encoded as empty strings.
    // Value order coincides with that of TAttributeSelector.paths.
    repeated bytes values = 1 [(NYT.NYson.NProto.yson_string) = true];

    // Value order coincides with that of TAttributeSelector.paths.
    // Empty if TGetObjectOptions.fetch_values is false.
    repeated TPayload value_payloads = 2;

    // Timestamp order coincides with that of TAttributeSelector.paths.
    // Empty if TGetObjectOptions.fetch_timestamps is false.
    repeated uint64 timestamps = 3;
}

message TObjectFilter
{
    // Textual query string (YP dialect).
    required string query = 1;
}

message TSelectLimit
{
    // Maximum number of results to fetch.
    required int64 value = 1;
}

message TSelectOffset
{
    // Number of leading results to skip.
    required int64 value = 1;
}

message TEvent
{
    // The timestamp of the event.
    required uint64 timestamp = 1;

    // Event type.
    required EEventType event_type = 2;

    // Object id.
    required string object_id = 3;
}

message TSetUpdate
{
    // YPath pointing to the attribute to set.
    required string path = 1;

    // COMPAT(babenko): deprecated; use value_payload instead.
    // Attribute value; in YSON.
    optional bytes value = 2 [(NYT.NYson.NProto.yson_string) = true];

    // Attribute value.
    optional TPayload value_payload = 4;

    // If true then missing intermediate
    optional bool recursive = 3;
}

message TRemoveUpdate
{
    // YPath pointing to the attribute to remove.
    required string path = 1;
}

message TAttributeTimestampPrerequisite
{
    // YPath pointing to the attribute to check.
    required string path = 1;

    // For the prerequisite to succeed, the actual timestamp must not exceed this one.
    required uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGenerateTimestamp
{ }

message TRspGenerateTimestamp
{
    // A new (unique) timestamp.
    required uint64 timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqStartTransaction
{ }

message TRspStartTransaction
{
    // Transaction id.
    required string transaction_id = 1;

    // Start timestamp of the transaction.
    required uint64 start_timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqCommitTransaction
{
    // Transaction id.
    required string transaction_id = 1;
}

message TRspCommitTransaction
{
    // Commit timestamp of the transaction.
    required uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqAbortTransaction
{
    // Transaction id.
    required string transaction_id = 1;
}

message TRspAbortTransaction
{ }

////////////////////////////////////////////////////////////////////////////////

message TReqCreateObject
{
    // Transaction id.
    // If missing, just creates the object w/o any transaction.
    optional string transaction_id = 1;

    // Type of the object to create.
    required EObjectType object_type = 2;

    // COMPAT(babenko): deprecated; use attributes_payload instead.
    // Object attributes; in YSON.
    optional bytes attributes = 3 [(NYT.NYson.NProto.yson_string) = true];

    // Object attributes.
    optional TPayload attributes_payload = 4;
}

message TRspCreateObject
{
    // Object id.
    required string object_id = 1;

    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqCreateObjects
{
    // Transaction id.
    // If missing, just creates the objects w/o any transaction.
    optional string transaction_id = 1;

    message TSubrequest
    {
        // Type of the object to create.
        required EObjectType object_type = 1;

        // COMPAT(babenko): deprecated; use attributes_payload instead.
        // Object attributes; in YSON.
        optional bytes attributes = 2 [(NYT.NYson.NProto.yson_string) = true];

        // Object attributes.
        optional TPayload attributes_payload = 3;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 2;
}

message TRspCreateObjects
{
    message TSubresponse
    {
        // Object id.
        required string object_id = 1;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqRemoveObject
{
    // Transaction id.
    // If missing, just removes the object w/o any transaction.
    optional string transaction_id = 1;

    // Id of the object to remove.
    required string object_id = 2;

    // Type of the object to remove.
    required EObjectType object_type = 3;
}

message TRspRemoveObject
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqRemoveObjects
{
    // Transaction id.
    // If missing, just removes the objects w/o any transaction.
    optional string transaction_id = 1;

    message TSubrequest
    {
        // Type of the object to remove.
        required EObjectType object_type = 1;

        // Id of the object to remove.
        required string object_id = 2;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 2;
}

message TRspRemoveObjects
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqUpdateObject
{
    // Transaction id.
    // If missing, just updates the object w/o any transaction.
    optional string transaction_id = 1;

    // Id of the object to update.
    required string object_id = 2;

    // Type of the object to update.
    required EObjectType object_type = 5;

    // Describes set-like updates.
    repeated TSetUpdate set_updates = 3;

    // Describes remove-like updates.
    repeated TRemoveUpdate remove_updates = 4;

    // Prerequisities to check.
    repeated TAttributeTimestampPrerequisite attribute_timestamp_prerequisites = 6;
}

message TRspUpdateObject
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqUpdateObjects
{
    // Transaction id.
    // If missing, just updates the objects w/o any transaction.
    optional string transaction_id = 1;

    message TSubrequest
    {
        // Type of the object to update.
        required EObjectType object_type = 1;

        // Id of the object to update.
        required string object_id = 2;

        // Describes set-like updates.
        repeated TSetUpdate set_updates = 3;

        // Describes remove-like updates.
        repeated TRemoveUpdate remove_updates = 4;

         // Prerequisities to check.
         repeated TAttributeTimestampPrerequisite attribute_timestamp_prerequisites = 5;
   }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 2;
}

message TRspUpdateObjects
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TGetObjectOptions
{
    // If false, GetObject(s) fails with an error on nonexistent object(s).
    // If true, silently returns null TAttributeList for nonexistent objects.
    optional bool ignore_nonexistent = 1;

    // If true then TAttributeList.value_payloads are filled.
    optional bool fetch_values = 2 [default = true];

    // If true then TAttributeList.timestamps are filled.
    optional bool fetch_timestamps = 3 [default = false];
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetObject
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Id of the object to get.
    required string object_id = 2;

    // Type of the object to get.
    required EObjectType object_type = 4;

    // Describes which attributes are to fetched.
    // TRspGetObject.result.attributes will contain exactly this number of attributes.
    required TAttributeSelector selector = 3;

    // Format to use in response.
    optional EPayloadFormat format = 5;

    // Request options.
    optional TGetObjectOptions options = 6;
}

message TRspGetObject
{
    // The requested attributes.
    optional TAttributeList result = 1;

    // If TReqGetObject.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TRspGetObject.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetObjects
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Type of objects to get.
    required EObjectType object_type = 2;

    message TSubrequest
    {
        // Id of the object to get.
        required string object_id = 1;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 3;

    // Describes which attributes to fetch.
    // TRspGetObjects.results.attributes will contain exactly this number of attributes.
    required TAttributeSelector selector = 4;

    // Format to use in response.
    optional EPayloadFormat format = 5;

    // Request options.
    optional TGetObjectOptions options = 6;
}

message TRspGetObjects
{
    message TSubresponse
    {
        // The requested attributes.
        optional TAttributeList result = 1;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // If TReqGetObject.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TRspGetObjects.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TSelectObjectsOptions
{
    // If true then TAttributeList.value_payloads are filled.
    optional bool fetch_values = 1 [default = true];

    // If true then TAttributeList.timestamps are filled.
    optional bool fetch_timestamps = 2 [default = false];

    // Number of leading results to skip.
    optional int32 offset = 3;

    // Maximum number of results to fetch.
    optional int32 limit = 4;

    // Continuation token indicates the next record to be fetched. Opaque for the client.
    optional string continuation_token = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TReqSelectObjects
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Type of objects to select.
    required EObjectType object_type = 2;

    // Provides means for filtering certain objects.
    optional TObjectFilter filter = 3;

    // Describes which attributes to fetch.
    // TRspSelectObjects.results.attributes will contain exactly this number of attributes.
    required TAttributeSelector selector = 4;

    // Enables limiting the number of results.
    // COMPAT(babenko): deprecated; use options instead.
    optional TSelectLimit limit = 5;

    // Enables skipping a number of leading results.
    // COMPAT(babenko): deprecated; use options instead.
    optional TSelectOffset offset = 6;

    // Format to use in response.
    optional EPayloadFormat format = 7;

    // Request options.
    optional TSelectObjectsOptions options = 8;
}

message TRspSelectObjects
{
    // The result set: each element of this list corresponds to a single
    // matching object.
    repeated TAttributeList results = 1;

    // If TReqSelectObjects.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqSelectObjects.timestamp.
    optional uint64 timestamp = 2;

    // Continuation token should be sent in subsequent requests to fetch the next batch
    // of objects. Opaque for the client.
    optional string continuation_token = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TAggregateExpressions
{
    repeated string expressions = 1;
}

message TGroupByExpressions
{
    repeated string expressions = 1;
}

message TReqAggregateObjects
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Type of objects to select.
    required EObjectType object_type = 2;

    // Provides means for filtering certain objects.
    optional TObjectFilter filter = 3;

    // Group by expression.
    optional TGroupByExpressions group_by_expressions = 4;

    // Aggregate expressions.
    optional TAggregateExpressions aggregate_expressions = 5;
}

message TRspAggregateObjects
{
    // The result set: each element of this list corresponds to a single group of objects and its aggregation.
    // List is ordered as follows:
    //     1) group-by keys ordered according to group_by_expressions;
    //     2) aggregated values ordered according to aggregate_expressions.
    repeated TAttributeList results = 1;

    // If TReqAggregateObjects.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqAggregateObjects.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqCheckObjectPermissions
{
    message TSubrequest
    {
        // Id of the object to check.
        required string object_id = 1;

        // Type of the object to check.
        required EObjectType object_type = 2;

        // Id of subject accessing the object (either user or group).
        required string subject_id = 3;

        // Permission to check.
        required EAccessControlPermission permission = 4;

        // Attribute path to check.
        optional string attribute_path = 5;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 1;

    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 2;
}

message TRspCheckObjectPermissions
{
    message TSubresponse
    {
        // Was request allowed or declined?
        required EAccessControlAction action = 1;

        // The object whose ACL contains the matching ACE. Can be null.
        optional string object_id = 2;

        // The type of object referred by object_id. Can be null.
        optional EObjectType object_type = 3;

        //! Subject to which the decision applies. Can be null.
        optional string subject_id = 4;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // If TReqCheckObjectPermissions.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqCheckObjectPermissions.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetObjectAccessAllowedFor
{
    message TSubrequest
    {
        // Id of the object to check.
        required string object_id = 1;

        // Type of the object to check.
        required EObjectType object_type = 2;

        // Permission to check.
        required EAccessControlPermission permission = 4;

        // Attribute path to check.
        optional string attribute_path = 5;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 1;

    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 2;
}

message TRspGetObjectAccessAllowedFor
{
    message TSubresponse
    {
        // Ids of users that are granted access.
        repeated string user_ids = 1;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // If TReqGetObjectAccessAllowedFor.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqGetObjectAccessAllowedFor.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetUserAccessAllowedTo
{
    message TSubrequest
    {
        // Id of the user to check.
        required string user_id = 1;

        // Type of the object to check.
        required EObjectType object_type = 2;

        // Permission to check.
        required EAccessControlPermission permission = 3;

        // Attribute path to check.
        optional string attribute_path = 6;
        
        // Provides means for filtering certain objects.
        optional TObjectFilter filter = 7;

        // Continuation token indicates the next record to be fetched. Opaque for the client.
        optional string continuation_token = 4;

        // Maximum number of results to fetch.
        optional int32 limit = 5;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 1;
}

message TRspGetUserAccessAllowedTo
{
    message TSubresponse
    {
        // Ids of objects to which user is granted permission.
        repeated string object_ids = 1;

        // Continuation token should be sent in subsequent requests to fetch the next batch
        // of objects. Opaque for the client.
        optional string continuation_token = 2;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqWatchObjects
{
    // Only fetches events with timestamp <= given timestamp.
    optional uint64 timestamp = 1;

    // Only fetches events with timestamp > start_timestamp.
    optional uint64 start_timestamp = 2;

    // Token to continue object selection. Fetches events after previous replied events.
    // Either start_timestamp or continuation_token should be specified in request.
    optional string continuation_token = 3;

    // Type of objects to watch.
    required EObjectType object_type = 4;

    // Enables limiting the number of results.
    optional int64 event_count_limit = 5;

    // If some events are already available, WatchObjects call just returns them.
    // Otherwise it waits up to time_limit if given.
    optional google.protobuf.Duration time_limit = 6;
}

message TRspWatchObjects
{
    // Events read so far.
    repeated TEvent events = 1;

    // If TReqWatchObjects.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TRspWatchObjects.timestamp.
    required uint64 timestamp = 2;

    // Token to continue object selection. Selection is finished, if token is empty.
    required string continuation_token = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TTimeInterval
{
    // Time selector of form "begin <= time < end".
    // If some of the fields are not set the corresponding inequality is vacuous.

    // Left endpoint of the time interval. Endpoint is included.
    optional google.protobuf.Timestamp begin = 1;

    // Right endpoint of the time interval. Endpoint is not included.
    optional google.protobuf.Timestamp end = 2;
}

message TSelectObjectHistoryOptions
{
    // Uuid of the object. If set history will be selected for
    // object with given object_id and given uuid.
    optional string uuid = 1;

    // Maximum number of results to fetch.
    optional int32 limit = 2;

    // Continuation token - should be sent in subsequent requests to fetch the next batch
    // of history events. Opaque for the client.
    optional string continuation_token = 3;

    // Time interval to select.
    optional TTimeInterval interval = 4;

    // If true, then order history by descending time.
    optional bool descending_time_order = 5;
}

message TReqSelectObjectHistory
{
    // Type of the object to fetch the history for.
    required EObjectType object_type = 1;

    // Id of the object to fetch the history for.
    required string object_id = 2;

    // Describes which attributes are to be fetched.
    // TRspSelectObjectHistory.events.results will contain exactly this number of attributes.
    required TAttributeSelector selector = 3;

    // Format to use in response.
    // Format must be supported in the moment of the query.
    optional EPayloadFormat format = 4;

    // Object history selection query options.
    optional TSelectObjectHistoryOptions options = 5;
}

message TRspSelectObjectHistory
{
    message TEvent
    {
        // Time of the event.
        required google.protobuf.Timestamp time = 1;

        // Type of the event.
        required EEventType event_type = 2;

        // User that has performed the change.
        required string user = 3;

        // Event attributes (cf. TReqSelectObjectHistory.selector).
        optional TAttributeList results = 4;

        // List of attributes that were stored for this event.
        repeated string history_enabled_attributes = 5;
    }

    // Selected events.
    repeated TEvent events = 1;

    // Continuation token.
    optional string continuation_token = 2;
}

////////////////////////////////////////////////////////////////////////////////

service ObjectService
{
    // Generates a fresh monotoically increasing timestamp.
    rpc GenerateTimestamp (TReqGenerateTimestamp) returns (TRspGenerateTimestamp);

    // Starts a new transaction.
    // Transaction ids are opaque strings.
    // Transaction changes are transient (until commit); transactions are maintained by individual masters.
    // Clients must be choosing masters in a sticky way; cf. GetMasters.
    rpc StartTransaction (TReqStartTransaction) returns (TRspStartTransaction);

    // Commits an existing transaction.
    rpc CommitTransaction (TReqCommitTransaction) returns (TRspCommitTransaction);

    // Aborts an existing transaction.
    rpc AbortTransaction (TReqAbortTransaction) returns (TRspAbortTransaction);

    // Creates a new object.
    rpc CreateObject (TReqCreateObject) returns (TRspCreateObject);

    // Creates new objects.
    rpc CreateObjects (TReqCreateObjects) returns (TRspCreateObjects);

    // Removes an existing object.
    rpc RemoveObject (TReqRemoveObject) returns (TRspRemoveObject);

    // Removes existing objects.
    rpc RemoveObjects (TReqRemoveObjects) returns (TRspRemoveObjects);

    // Updates an existing object.
    rpc UpdateObject (TReqUpdateObject) returns (TRspUpdateObject);

    // Updates existing objects.
    rpc UpdateObjects (TReqUpdateObjects) returns (TRspUpdateObjects);

    // Fetches object attributes by object id.
    rpc GetObject (TReqGetObject) returns (TRspGetObject);

    // Fetches objects attributes by object ids.
    rpc GetObjects (TReqGetObjects) returns (TRspGetObjects);

    // Executes a query and fetches attributes for relevant objects.
    rpc SelectObjects (TReqSelectObjects) returns (TRspSelectObjects);

    // Executes a group-by query and aggregates attributes for relevant objects.
    rpc AggregateObjects (TReqAggregateObjects) returns (TRspAggregateObjects);

    // Runs permission checks for given objects, permissions, and users.
    rpc CheckObjectPermissions (TReqCheckObjectPermissions) returns (TRspCheckObjectPermissions);

    // Given objects and permissions, computes the set of users that are granted the specified permission.
    rpc GetObjectAccessAllowedFor (TReqGetObjectAccessAllowedFor) returns (TRspGetObjectAccessAllowedFor);

    // Computes the set of objects of a given type to which given users are granted given permissions.
    rpc GetUserAccessAllowedTo (TReqGetUserAccessAllowedTo) returns (TRspGetUserAccessAllowedTo);

    // Reads updates from event queue.
    rpc WatchObjects (TReqWatchObjects) returns (TRspWatchObjects);

    // Executes a query and fetches attributes for relevant objects.
    rpc SelectObjectHistory (TReqSelectObjectHistory) returns (TRspSelectObjectHistory);
}

////////////////////////////////////////////////////////////////////////////////
