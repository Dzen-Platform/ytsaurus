package NYP.NClient.NApi.NProto;

// COMPAT(babenko): will be dropped after switching to pod agent.
import "yp/client/api/proto/cluster_api.proto";
import "yp/client/api/proto/pod_agent.proto";
import "yp/client/api/proto/dynamic_attributes.proto";
import "yp/client/api/proto/conditions.proto";
import "yp/client/api/proto/enums.proto";

import "yt/core/yson/proto/protobuf_interop.proto";
import "yt/core/ytree/proto/attributes.proto";
import "yt/core/misc/proto/error.proto";

import "google/protobuf/descriptor.proto";

option java_package = "ru.yandex.yp.client.api";
option java_outer_classname = "DataModel";

////////////////////////////////////////////////////////////////////////////////

message TObjectTypeOption
{
    required string camel_case_name = 1;
    required string snake_case_name = 2;
    required int32 type_value = 3;
}

extend google.protobuf.FileOptions
{
    repeated TObjectTypeOption object_type = 30000;
}

extend google.protobuf.FieldOptions
{
    repeated bool etc = 30000;
}

extend google.protobuf.MessageOptions
{
    optional string etc_type_name = 30000;
}

////////////////////////////////////////////////////////////////////////////////

enum EEventType
{
    ET_OBJECT_CREATED = 0
    [(NYT.NYson.NProto.enum_value_name) = "object_created"];

    ET_OBJECT_REMOVED = 1
    [(NYT.NYson.NProto.enum_value_name) = "object_removed"];

    ET_OBJECT_UPDATED = 2
    [(NYT.NYson.NProto.enum_value_name) = "object_updated"];
}

////////////////////////////////////////////////////////////////////////////////

enum EAccessControlAction
{
    ACA_ALLOW = 1
    [(NYT.NYson.NProto.enum_value_name) = "allow"];

    ACA_DENY = 2
    [(NYT.NYson.NProto.enum_value_name) = "deny"];
}

enum EAccessControlPermission
{
    ACP_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ACP_READ = 1
    [(NYT.NYson.NProto.enum_value_name) = "read"];

    ACP_READ_SECRETS = 8
    [(NYT.NYson.NProto.enum_value_name) = "read_secrets"];

    ACA_WRITE = 2
    [(NYT.NYson.NProto.enum_value_name) = "write"];

    ACA_CREATE = 3
    [(NYT.NYson.NProto.enum_value_name) = "create"];

    ACA_SSH_ACCESS = 4
    [(NYT.NYson.NProto.enum_value_name) = "ssh_access"];

    ACA_ROOT_SSH_ACCESS = 5
    [(NYT.NYson.NProto.enum_value_name) = "root_ssh_access"];

    ACA_USE = 6
    [(NYT.NYson.NProto.enum_value_name) = "use"];

    ACA_GET_QYP_VM_STATUS = 7
    [(NYT.NYson.NProto.enum_value_name) = "get_qyp_vm_status"];
}

message TAccessControlEntry
{
    // Determines the access control action to take upon a match.
    required EAccessControlAction action = 1;

    // List of permissions this entry applies to.
    repeated EAccessControlPermission permissions = 2;

    // List of subjects (users and groups) this entry applies to.
    repeated string subjects = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TAntiaffinityConstraint
{
    // Topology zone key.
    // Node zones are specified via /node/labels/topology/key=value labels.
    // and are filled on node's import.
    // Supported zone keys are: node, rack, dc.
    required string key = 1;

    // Maximum number of pods that can be placed in the same zone.
    required int64 max_pods = 2;

    // Describes the pods this constraint applies to.
    // TODO(babenko): this is not currently implemented
    optional string pod_filter = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TPerSegmentResourceTotals
{
    message TMemoryTotals
    {
        // In bytes.
        optional int64 capacity = 1;
    }

    message TCpuTotals
    {
        // In VCPU units.
        optional int64 capacity = 1;
    }

    message TDiskTotals
    {
        // In bytes.
        optional int64 capacity = 1;

        // In bytes per second.
        optional int64 bandwidth = 2;
    }

    message TInternetAddressTotals
    {
        optional int64 capacity = 1;
    }

    optional TMemoryTotals memory = 1;
    optional TCpuTotals cpu = 2;
    map<string, TDiskTotals> disk_per_storage_class = 3 [(NYT.NYson.NProto.yson_map) = true];
    optional TInternetAddressTotals internet_address = 4;
}

message TResourceTotals
{
    map<string, TPerSegmentResourceTotals> per_segment = 1 [(NYT.NYson.NProto.yson_map) = true];
}

////////////////////////////////////////////////////////////////////////////////

// We generate a bunch of TXXXMeta messages that "inherit" from TXXXMetaBase (if any).
// Their shared fields are as follows.
/*
message TXXXMeta
{
    // Object id; unique within its type.
    // Object is typically provided by the user upon object construction and can be reused.
    // Once assigned, object id cannot be changed.
    string id = 1;

    // Univerally unique id; assigned by YP master and is never reused.
    // Helpful to track object identity.
    string uuid = 12;

    // Optional descriptive name that is displayed in e.g. error messages or UI.
    // In contrast to id, YP master does not guarantee uniqueness of names.
    // Names can be changed at any time.
    // Not all object types support custom names; attempting to set this attribute for those lacking support
    // raises an error.
    string name = 13;

    // Type of the object.
    EObjectType type = 2;

    // The instant of time the object was constructed.
    uint64 creation_time = 3;

    // If true, the object inherits all ACEs from appropriate "parent".
    // For schemas this is assumed to be always false.
    bool inherit_acl = 10;

    // The list of ACEs comprising object's ACL.
    repeated TAccessControlEntry acl = 11;
}
*/

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Node"
    snake_case_name: "node"
    type_value: 0
};

enum EHfsmState
{
    HS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    HS_INITIAL = 100
    [(NYT.NYson.NProto.enum_value_name) = "initial"];

    HS_UP = 200
    [(NYT.NYson.NProto.enum_value_name) = "up"];

    HS_DOWN = 300
    [(NYT.NYson.NProto.enum_value_name) = "down"];

    HS_SUSPECTED = 400
    [(NYT.NYson.NProto.enum_value_name) = "suspected"];

    HS_PREPARE_MAINTENANCE = 500
    [(NYT.NYson.NProto.enum_value_name) = "prepare_maintenance"];

    HS_MAINTENANCE = 600
    [(NYT.NYson.NProto.enum_value_name) = "maintenance"];

    HS_PROBATION = 700
    [(NYT.NYson.NProto.enum_value_name) = "probation"];
}

enum ENodeMaintenanceState
{
    NMS_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    NMS_REQUESTED = 100
    [(NYT.NYson.NProto.enum_value_name) = "requested"];

    NMS_ACKNOWLEDGED = 200
    [(NYT.NYson.NProto.enum_value_name) = "acknowledged"];

    NMS_IN_PROGRESS = 300
    [(NYT.NYson.NProto.enum_value_name) = "in_progress"];
}

message TNodeSpec
{
    message TIP6Subnet
    {
        // IP6 /64-subnet, in textual form.
        required string subnet = 1;

        // E.g. backbone or fastbone.
        required string vlan_id = 2;
    }
    // MTN subnets.
    repeated TIP6Subnet ip6_subnets = 1;

    message TIP6Address
    {
        // IP6 address, in textual form.
        required string address = 1;

        // E.g. backbone or fastbone.
        required string vlan_id = 2;
    }
    // Host (dom0) IP6 addresses.
    repeated TIP6Address ip6_addresses = 2;

    // Used to construct /pod/status/transient_fqdn.
    // Typically this is the first part of the node's FQDN, i.e.
    // "sas1-3329" for "sas1-3329.search.yandex.net".
    optional string short_name = 3;

    message THfsm
    {
        // Setting this to false prevents automatic HFSM status updates.
        optional bool enable_sync = 2;
    }
    // HFSM controls.
    optional THfsm hfsm = 5;

    // NOC module in "physical" network topology.
    optional string network_module_id = 6;

    // If true then YP Master instructs node agents to drop all unknown pods.
    optional bool force_remove_unknown_pods = 7;
}

message TNodeStatus
{
    // Current epoch used for master-agent communication.
    optional string epoch_id = 1;

    // Timestamp of the last agent heartbeat.
    optional uint64 last_seen_time = 2;

    // Used for properly sequencing master-agent communication.
    optional uint64 heartbeat_sequence_number = 3;

    // Address of GPRC service at agent used for out-of-band notifications.
    optional string agent_address = 4;

    // Version of the agent running at this node (as reported during the last handshake).
    optional string agent_version = 8 [(NYP.NClient.NApi.NProto.etc) = true];

    message THfsm
    {
        // Current HFSM state.
        optional EHfsmState state = 1;

        // Timestamp of last change.
        optional uint64 last_updated = 2;

        // Comment for the last change.
        optional string message = 3;
    }
    // HFSM info.
    optional THfsm hfsm = 5 [(NYP.NClient.NApi.NProto.etc) = true];

    message TMaintenance
    {
        // Current maintenance state.
        optional ENodeMaintenanceState state = 1;

        // Timestamp of last change.
        optional uint64 last_updated = 2;

        // Comment for the last change.
        optional string message = 3;
    }
    // Maintenance workflow.
    optional TMaintenance maintenance = 6 [(NYP.NClient.NApi.NProto.etc) = true];

    // Contains ids of pods that are reported to be present at the node
    // but are neither known to exist nor were recently removed.
    repeated string unknown_pod_ids = 7 [(NYP.NClient.NApi.NProto.etc) = true];
}

message TNodeControl
{
    message TUpdateHfsmState
    {
        // New HFSM state.
        optional EHfsmState state = 1;

        // Comment for changing HFSM state.
        optional string message = 2;
    }

    // Enables updating HFSM state.
    optional TUpdateHfsmState update_hfsm_state = 1;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Schema"
    snake_case_name: "schema"
    type_value: 256
};

message TSchemaSpec
{ }

message TSchemaStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Resource"
    snake_case_name: "resource"
    type_value: 3
};

enum EDiskVolumePolicy
{
    DVP_QUOTA = 0
    [(NYT.NYson.NProto.enum_value_name) = "quota"];

    DVP_EXCLUSIVE = 1
    [(NYT.NYson.NProto.enum_value_name) = "exclusive"];
}

message TResourceMetaBase
{
    optional string node_id = 4;
    optional EResourceKind kind = 5;
}

message TResourceSpec
{
    message TCpuSpec
    {
        // In VCPU units.
        required uint64 total_capacity = 1;
        // Calibrated compute power of a single "physical" CPU core.
        // Typically "physical" CPU cores are, in fact, HT threads.
        optional double cpu_to_vcpu_factor = 2 [default = 1.0];
    }

    message TMemorySpec
    {
        // In bytes.
        required uint64 total_capacity = 1;
    }

    message TDiskSpec
    {
        reserved 9, 10;
        // E.g. ssd, hdd etc.
        required string storage_class = 1;
        // In bytes.
        required uint64 total_capacity = 2;
        // Each volume occupies a virtual "slot".
        // This prevents assigning too many volumes to a single physical disk.
        optional uint64 total_volume_slots = 3;
        // E.g. /dev/* path.
        optional string device = 4;
        // List of supported allocation policies.
        repeated EDiskVolumePolicy supported_policies = 5;
        // Total provided bandwidth in bytes per second.
        optional uint64 total_bandwidth = 6;
        // Total provided read bandwidth is estimated
        // using total_bandwidth and the following factor.
        optional double read_bandwidth_factor = 7;
        // Total provided write bandwidth is estimated
        // using total_bandwidth and the following factor.
        optional double write_bandwidth_factor = 8;
        // Total provided read operations per second is estimated
        // using total_bandwidth and the following divisor.
        optional double read_operation_rate_divisor = 11;
        // Total provided write operations per second is estimated
        // using total_bandwidth and the following divisor.
        optional double write_operation_rate_divisor = 12;
    }

    oneof concrete_spec
    {
        TCpuSpec cpu = 3;
        TMemorySpec memory = 4;
        TDiskSpec disk = 5;
    }
}

message TResourceStatus
{
    message TCpuAllocation
    {
        required uint64 capacity = 1;
    }

    message TMemoryAllocation
    {
        required uint64 capacity = 1;
    }

    message TDiskAllocation
    {
        required uint64 capacity = 1;
        required bool exclusive = 2;
        required string volume_id = 3;
        optional uint64 bandwidth = 4;
    }

    message TAllocation
    {
        optional string pod_id = 1;
        optional string pod_uuid = 5;

        oneof concrete_allocation
        {
            TCpuAllocation cpu = 2;
            TMemoryAllocation memory = 3;
            TDiskAllocation disk = 4;
        }
    }
    repeated TAllocation scheduled_allocations = 1;
    repeated TAllocation actual_allocations = 2;

    message TCpuStatistics
    {
        // In VCPU units.
        required uint64 capacity = 1;
    }

    message TMemoryStatistics
    {
        // In bytes.
        required uint64 capacity = 1;
    }

    message TDiskStatistics
    {
        reserved 1;

        // In bytes.
        required uint64 capacity = 2;

        // In bytes per second.
        optional uint64 bandwidth = 3;
    }

    message TAllocationStatistics
    {
        oneof concrete_statisticss
        {
            TCpuStatistics cpu = 1;
            TMemoryStatistics memory = 2;
            TDiskStatistics disk = 3;
        }
    }

    // Indicates free (unused) resource capacity.
    // "free" and "used" (see below) are calculated taking both scheduled and actual resource
    // allocations into account thus effectively simulating the scheduler's behaviour.
    optional TAllocationStatistics free = 3;
    // Indicated used capacity.
    optional TAllocationStatistics used = 4;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Pod"
    snake_case_name: "pod"
    type_value: 1
};

enum EPodCurrentState
{
    PCS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    PCS_START_PENDING = 100
    [(NYT.NYson.NProto.enum_value_name) = "start_pending"];

    PCS_STARTED = 200
    [(NYT.NYson.NProto.enum_value_name) = "started"];

    PCS_STOP_PENDING = 300
    [(NYT.NYson.NProto.enum_value_name) = "stop_pending"];

    PCS_STOPPED = 400
    [(NYT.NYson.NProto.enum_value_name) = "stopped"];

    // Pod could not be started (for example, the received spec was invalid).
    PCS_START_FAILED = 500
    [(NYT.NYson.NProto.enum_value_name) = "start_failed"];
}

enum EPodTargetState
{
    PTS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    PTS_REMOVED = 1
    [(NYT.NYson.NProto.enum_value_name) = "removed"];

    PTS_ACTIVE = 100
    [(NYT.NYson.NProto.enum_value_name) = "active"];
}

message TPodMetaBase
{
    optional string pod_set_id = 4;
}

message TPodDynamicResourceSpec
{
    reserved 4;
    reserved "url";

    // Resource identifier.
    optional string id = 1;
    
    // Desired revision of the resource.
    optional uint64 revision = 2;

    message TStorageOptions
    {
        // Name of the box to download resource into.
        optional string box_ref = 1;

        // Filesystem path where the application should see the resource.
        optional string destination = 2;

        // Filesystem path where resource versions should be downloaded.
        optional string storage_dir = 3;

        // HTTP GET handle to notify.
        // HTTP response codes from range 200-299 are considered to be success.
        message THttpAction
        {
            // Url to call.
            optional string url = 1;

            // Expected HTTP response body.
            optional string expected_answer = 2;
        }

        // Shell command to exec to notify.
        message TExecAction
        {
            // Shell command to execute.
            optional string command_line = 1;

            // Stdout to accept, if empty, stdout is ignored.
            optional string expected_answer = 2;
        }

        oneof Action
        {
            THttpAction http_action = 4;
            TExecAction exec_action = 5;
        }

        message TVerification
        {
            // Checksum in the form: <scheme>:<value> Supported schemes are "MD5:", "EMPTY:", "SHA256:", all case sensitive.
            optional string checksum = 1;

            // Period of checksum check. First check is done right after download.
            optional uint64 check_period_ms = 2;
        }

        // Rule how to check the resource.
        optional TVerification verification = 6;

        // How many copies including actual one should be kept. It's not recommended to use less than 2 (default).
        // If you set 1, your resource will be fully removed before downloading new revision.
        optional uint64 cached_revisions_count = 7;

        // Allow resource to be deduplicated via hardlinks if present.
        // Supported only for rbtorrent URLs.
        // Use only if you know what you are doing! Hardlinked data can be corrupted
        // by other users of the resource on the same host.
        optional bool allow_deduplication = 8;
    }

    optional TStorageOptions storage_options = 3;

    // URLs where to download the resource from
    // supported protocols: http, https, rbtorrent, raw
    // (for raw resources use "raw:data").
    // URLs are tried in order until successful download.
    repeated string urls = 5;
}

message TPodSpec
{
    // Raw ISS payload to be delivered to agent.
    // COMPAT(babenko): will be deprecated after switching to pod agent.
    optional bytes iss_payload = 1;

    // Structured ISS spec.
    // COMPAT(babenko): will be deprecated after switching to pod agent.
    optional NYP.NClient.NApi.NClusterApiProto.HostConfiguration iss = 9;


    message TPodAgentDeploymentMeta
    {
        // URL to download pod agent binary from.
        // This might be unified with TLayer now, but they may diverge later, so leave it here.
        optional string url = 1;

        // <scheme>:<hex value>. Supported schemes are "MD5" and "EMPTY".
        optional string checksum = 2;

        // Arguments to be passed to pod agent via command line.
        map<string, string> configuration = 3 [(NYT.NYson.NProto.yson_map) = true];

        message TLayer
        {
            // URL to download layer from.
            optional string url = 1;

            // <scheme>:<hex value>. Supported schemes are "MD5" and "EMPTY".
            optional string checksum = 2;
        }

        // List of layers to construct pod chroot fs from, from top to bottom (same order as used by porto).
        repeated TLayer layers = 5;
    }

    message TPodAgentPayload
    {
        optional NInfra.NPodAgent.API.TPodAgentSpec spec = 1;
        optional TPodAgentDeploymentMeta meta = 2;
    }

    // Pod agent deployment and its workload specs.
    // COMPAT(babenko): Either this or iss_payload/iss should be present.
    optional TPodAgentPayload pod_agent_payload = 14;

    // Node id this pod must be assigned to.
    // XXX(babenko): WILL BE REMOVED SOON. DON'T USE.
    optional string node_id = 2;

    message TResourceRequests
    {
        optional uint64 vcpu_guarantee = 1;
        optional uint64 vcpu_limit = 2;

        optional uint64 memory_guarantee = 3;
        optional uint64 memory_limit = 4;
        optional uint64 anonymous_memory_limit = 5;
        optional uint64 dirty_memory_limit = 6;
    };
    // CPU and memory resources to allocate and configure for this pod upon assignment.
    optional TResourceRequests resource_requests = 3 [(NYP.NClient.NApi.NProto.etc) = true];

    message TIP6AddressRequest
    {
        // Id of network_project.
        required string network_id = 1;

        // Will be matched against /node/spec/ip6_subnets/*/vlan_id.
        required string vlan_id = 2;

        // These labels get propagated to /pod/status/ip6_address_allocations/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;

        // If true, this address is published to DNS.
        optional bool enable_dns = 5;

        // If non-empty, full DNS name is prepended with this string (plus dot).
        optional string dns_prefix = 6;

        // If true, internet tunnels is configured (InternetAddress is allocated and assigned to pod).
        optional bool enable_internet = 7;

        // If given, virtual service tunnels are configured.
        repeated string virtual_service_ids = 8;
    }
    // IP6 addresses to allocate for this pod upon assignment.
    repeated TIP6AddressRequest ip6_address_requests = 5 [(NYP.NClient.NApi.NProto.etc) = true];

    message TIP6SubnetRequest
    {
        // Id of network_project.
        // If omitted, no network configuration is actually being applied at nodes;
        // however the IP6 address nonce is still being reserved.
        optional string network_id = 3;

        // Will be matched against /node/spec/ip6_subnets/*/vlan_id.
        required string vlan_id = 1;

        // These labels get propagated to /node/status/ip6_subnet_allocations/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 2;
    }
    // IP6 subnets to allocate for this pod upon assignment.
    repeated TIP6SubnetRequest ip6_subnet_requests = 6 [(NYP.NClient.NApi.NProto.etc) = true];

    message TDiskVolumeRequest
    {
        // Pod-wise unique id.
        required string id = 1;

        // These labels get propagated to /pod/status/disk_volume_allocations/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 2;

        // E.g. ssd, hdd.
        required string storage_class = 3;

        message TQuotaPolicy
        {
            // Guaranteed volume capacity.
            required uint64 capacity = 1;

            // Guaranteed volume bandwidth in bytes per second.
            optional uint64 bandwidth_guarantee = 2;

            // Volume bandwidth limit in bytes per second.
            optional uint64 bandwidth_limit = 3;
        }

        message TExclusivePolicy
        {
            // Minimum capacity the disk must have.
            // The client, however, will be charged for the whole disk capacity.
            required uint64 min_capacity = 1;

            // Minimum bandwidth in bytes per second the disk must provide.
            // The client, however, will be charged for the whole disk bandwidth.
            optional uint64 min_bandwidth = 2;
        }

        oneof concrete_policy
        {
            TQuotaPolicy quota_policy = 6;
            TExclusivePolicy exclusive_policy = 7;
        }
    }
    // Disk volumes to allocate for this pod upon assignment.
    repeated TDiskVolumeRequest disk_volume_requests = 13 [(NYP.NClient.NApi.NProto.etc) = true];

    // If false then YP will not be scheduling this pod.
    optional bool enable_scheduling = 7;

    // If given, controls which nodes are eligible for this pod.
    // Filter is a query language predicate; it can only refer to node labels, not other attributes.
    optional string node_filter = 8 [(NYP.NClient.NApi.NProto.etc) = true];

    message THostDevice
    {
        // E.g. /dev/kvm
        required string path = 1;

        // E.g. "r", "rw"
        required string mode = 2;
    }
    // Host devices to configure.
    // https://wiki.yandex-team.ru/porto/propertiesanddata/#resursy
    repeated THostDevice host_devices = 10 [(NYP.NClient.NApi.NProto.etc) = true];

    message TSysctlProperty
    {
        required string name = 1;
        required string value = 2;
    }
    // Sysctl properties to configure.
    repeated TSysctlProperty sysctl_properties = 11 [(NYP.NClient.NApi.NProto.etc) = true];

    message TVirtualServiceOptions
    {
        optional uint32 ip4_mtu = 2;
        optional uint32 ip6_mtu = 3;
        optional string decapsulator_anycast_address = 4;
    }
    optional TVirtualServiceOptions virtual_service_options = 12 [(NYP.NClient.NApi.NProto.etc) = true];

    // Determines the kind of "hostname" Porto property: either
    // "persistent" or "transient" pod FQDN can be used.
    optional EPodHostNameKind host_name_kind = 15 [(NYP.NClient.NApi.NProto.etc) = true];

    message TSecret
    {
        required string secret_id = 1;
        required string secret_version = 2;
        required string delegation_token = 3;
    }

    // Defines secrets to be delivered to the pod.
    map<string, TSecret> secrets = 16 [(NYT.NYson.NProto.yson_map) = true];

    // If given, overrides the podset's account.
    optional string account_id = 17;

    message TDynamicAttributes
    {
        // List of pod label keys to be delivered to the pod.
        repeated string labels = 1;

        // List of pod annotation keys to be delivered to the pod.
        repeated string annotations = 2;
    }

    // Provides means to deliver certain parts of pod's metadata to the node.
    optional TDynamicAttributes dynamic_attributes = 18;

    // Dynamic resources for the pod.
    repeated TPodDynamicResourceSpec dynamic_resources = 19;

    message TPodAgentResourceCache
    {
        optional NInfra.NPodAgent.API.TPodAgentResourceCacheSpec spec = 1;
    }

    // Resource cache for the pod
    optional TPodAgentResourceCache resource_cache = 20;

    // Defines the behavior policy when OOM occurs on one of the containers.
    // "oom_is_fatal: false" will be set if the OOMP_KILL_PROCESS parameter is passed.
    // "oom_is_fatal: true" will be set if the OOMP_REBUILD_POD parameter is passed.
    // Nothing will be set for "oom_is_fatal" property otherwise.
    optional EPodOutOfMemoryPolicy out_of_memory_policy = 21;
}

enum EEvictionState
{
    ES_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ES_REQUESTED = 100
    [(NYT.NYson.NProto.enum_value_name) = "requested"];

    ES_ACKNOWLEDGED = 200
    [(NYT.NYson.NProto.enum_value_name) = "acknowledged"];
}

enum EEvictionReason
{
    ER_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ER_HFSM = 100
    [(NYT.NYson.NProto.enum_value_name) = "hfsm"];

    ER_SCHEDULER = 200
    [(NYT.NYson.NProto.enum_value_name) = "scheduler"];
}

enum ESchedulingState
{
    SS_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    SS_DISABLED = 100
    [(NYT.NYson.NProto.enum_value_name) = "disabled"];

    SS_PENDING = 200
    [(NYT.NYson.NProto.enum_value_name) = "pending"];

    SS_ASSIGNED = 300
    [(NYT.NYson.NProto.enum_value_name) = "assigned"];
}

message TPodDynamicResourceStatus
{
    // Resource identifier.
    optional string id = 1;

    // Current resource revision in pod.
    optional uint64 revision = 2;

    // Resource is currently active.
    optional TCondition ready = 3;

    // Resource is currently being deployed.
    optional TCondition in_progress = 4;

    // Resource deploy failed with error.
    optional TCondition error = 5;
}

message TPodStatus
{
    // Node where this pod currently belongs to.
    optional string node_id = 1;

    message TAgent
    {
        option (NYP.NClient.NApi.NProto.etc_type_name) = "TPodAgentStatusEtc";

        // ISS pod state.
        optional EPodCurrentState state = 1;

        // Raw ISS payload received from agent.
        // COMPAT(babenko): will be deprecated after switching to pod agent.
        optional bytes iss_payload = 3;

        // Structured ISS status.
        // COMPAT(babenko): will be deprecated after switching to pod agent.
        optional NYP.NClient.NApi.NClusterApiProto.HostCurrentState iss = 4;

        message TPodAgentPayload
        {
            optional NInfra.NPodAgent.API.TPodAgentStatus status = 1;
        }

        // Pod agent status.
        // COMPAT(babenko): Either this or iss_payload/iss should be present.
        optional TPodAgentPayload pod_agent_payload = 5;

        // Error in pod execution passed from agent via heartbeat.
        optional NYT.NProto.TError execution_error = 6 [(NYP.NClient.NApi.NProto.etc) = true];

        // Error occurred while installing this pod to the node.
        optional NYT.NProto.TError install_error = 9 [(NYP.NClient.NApi.NProto.etc) = true];

        // Contains the spec timestamps for which install_error was observed.
        optional uint64 failed_install_attempt_spec_timestamp = 10 [(NYP.NClient.NApi.NProto.etc) = true];

        // Errors in pod spec validation passed from agent via heartbeat.
        repeated string validation_failures = 8 [(NYP.NClient.NApi.NProto.etc) = true];

        // The instant the last heartbeat from agent containing the status of this pod was received.
        optional uint64 last_heartbeat_time = 7 [(NYP.NClient.NApi.NProto.etc) = true];
    }
    optional TAgent agent = 2;

    message TResourceAllocation
    {
        optional string resource_id = 1;
    }
    repeated TResourceAllocation scheduled_resource_allocations = 4 [(NYP.NClient.NApi.NProto.etc) = true];

    message TIP6AddressAllocation
    {
        // IP6 address assigned by YP, in textual form.
        optional string address = 1;

        // Copied from /pod/spec/ip6_addresses/*/vlan_id.
        optional string vlan_id = 2;

        // Copied from /pod/spec/ip6_subnet_requests/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;

        // Persistent DNS name assigned to this address (if any) of the form:
        // [<dns_prefix>.]<pod-id>.<suffix>
        // This FQDN never changes.
        optional string persistent_fqdn = 5;

        // Transient DNS name assigned to this address (if any) of the form:
        // [<dns_prefix>.]<node-short-name>-<generation-number>.<pod-id>.<suffix>
        // This FQDN changes each time pod gets reassigned to another node.
        optional string transient_fqdn = 6;

        message TInternetAddress
        {
            required string id = 1;
            required string ip4_address = 2;
        }

        // Internet address assigned to this allocation.
        optional TInternetAddress internet_address = 7;

        message TVirtualService
        {
            // IP6 address, in textual form.
            repeated string ip6_addresses = 1;
            // IP4 address, in textual form.
            repeated string ip4_addresses = 2;
        }

        // Virtual services assigned to this allocation.
        repeated TVirtualService virtual_services = 8;
    }
    repeated TIP6AddressAllocation ip6_address_allocations = 5 [(NYP.NClient.NApi.NProto.etc) = true];

    message TIP6SubnetAllocation
    {
        // IP6 /112-subnet assigned by YP, in textual form.
        optional string subnet = 1;

        // Copied from /pod/spec/ip6_addresses/*/vlan_id.
        optional string vlan_id = 2;

        // Copied from /node/spec/ip6_address_requests/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;
    }
    repeated TIP6SubnetAllocation ip6_subnet_allocations = 6 [(NYP.NClient.NApi.NProto.etc) = true];

    message TDiskVolumeAllocation
    {
        // Copied from /pod/spec/disk_volume_requests/*/id.
        optional string id = 1;

        // Copied from /pod/spec/disk_volume_requests/*/labels.
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;

        // Total volume capacity in bytes.
        optional uint64 capacity = 4;

        // Id of disk resource where this volume will reside.
        optional string resource_id = 5;

        // Globally-unique volume id.
        // This is generated each time a "new" volume is assigned to the pod.
        // "New" volumes are recognized based on /pod/spec/disk_volume_allocations/*/id.
        optional string volume_id = 6;

        // Copied from /resource/spec/disk/device.
        optional string device = 7;

        // Guaranteed volume read bandwidth in bytes per second.
        optional uint64 read_bandwidth_guarantee = 8;

        // Volume read bandwidth limit in bytes per second.
        optional uint64 read_bandwidth_limit = 9;

        // Guaranteed volume write bandwidth in bytes per second.
        optional uint64 write_bandwidth_guarantee = 10;

        // Volume write bandwidth limit in bytes per second.
        optional uint64 write_bandwidth_limit = 11;

        // Guaranteed volume read operation rate in operations per second.
        optional uint64 read_operation_rate_guarantee = 12;

        // Volume read operation rate limit in operations per second.
        optional uint64 read_operation_rate_limit = 13;

        // Guaranteed volume write operation rate in operations per second.
        optional uint64 write_operation_rate_guarantee = 14;

        // Volume write operation rate limit in operations per second.
        optional uint64 write_operation_rate_limit = 15;
    }
    repeated TDiskVolumeAllocation disk_volume_allocations = 14 [(NYP.NClient.NApi.NProto.etc) = true];

    message TDns
    {
        // Persistent FQDN of the form:
        // <pod-id>.<suffix>
        // This FQDN never changes.
        optional string persistent_fqdn = 7;

        // Transient FQDN of the form:
        // <node-short-name>-<generation-number>.<pod-id>.<suffix>
        // This FQDN changes each time pod gets reassigned to another node.
        optional string transient_fqdn = 8;
    }
    optional TDns dns = 7 [(NYP.NClient.NApi.NProto.etc) = true];

    message TEviction
    {
        optional EEvictionState state = 1;
        optional EEvictionReason reason = 2;
        optional uint64 last_updated = 3;
        optional string message = 4;
    }
    optional TEviction eviction = 8 [(NYP.NClient.NApi.NProto.etc) = true];

    message TScheduling
    {
        optional ESchedulingState state = 1;
        optional string node_id = 2;
        optional uint64 last_updated = 3;
        optional string message = 4;
        optional NYT.NProto.TError error = 5;
    }
    optional TScheduling scheduling = 9 [(NYP.NClient.NApi.NProto.etc) = true];

    // Increased each time the pod is being assigned to another node.
    optional uint64 generation_number = 10;

    // Timestamp of the last spec update.
    optional uint64 master_spec_timestamp = 11;

    // Timestamp of the spec as reported by agent.
    optional uint64 agent_spec_timestamp = 12;

    // Materialized view of dynamic attributes to be pushed to agent.
    optional NYP.NClient.NApi.NProto.TDynamicAttributes pod_dynamic_attributes = 13;

    // List of dynamic resources currently present in pod.
    repeated TPodDynamicResourceStatus dynamic_resources = 15;
}

message TPodControl
{
    message TAcknowledgeEviction
    {
        // Comment for the acknowledgement.
        optional string message = 1;
    }

    // Acknowledges eviction of a pod.
    // Pod must have /status/eviction/state == "requested" prior to this call and
    // the latter changes it to "acknowledged".
    optional TAcknowledgeEviction acknowledge_eviction = 1;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "PodSet"
    snake_case_name: "pod_set"
    type_value: 2
};

message TPodSetSpec
{
    // Limits placing pods of this pod set to the same topology zone (e.g. node, rack, DC).
    repeated TAntiaffinityConstraint antiaffinity_constraints = 1;

    // Specifies a node segment where all pods of this pod set must be scheduled to.
    optional string node_segment_id = 2;

    // Account that must be charged for this podset.
    optional string account_id = 3;
}

message TPodSetStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Endpoint"
    snake_case_name: "endpoint"
    type_value: 5
};

message TEndpointMetaBase
{
    optional string endpoint_set_id = 4;
}

message TEndpointSpec
{
    optional string protocol = 1;
    optional string fqdn = 2;
    optional string ip4_address = 3;
    optional string ip6_address = 4;
    optional int32 port = 5;
}

message TEndpointStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "EndpointSet"
    snake_case_name: "endpoint_set"
    type_value: 6
};

message TEndpointSetSpec
{
    // If given, for each pod matching this filter, an endpoint will be created.
    optional string pod_filter = 1;

    // If given, this value will be propagated to /endpoint/spec/protocol of each created endpoint.
    optional string protocol = 2;

    // If given, this value will be propagated to /endpoint/spec/port of each created endpoint.
    optional int32 port = 3;
}

message TEndpointSetStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "NetworkProject"
    snake_case_name: "network_project"
    type_value: 4
};

message TNetworkProjectSpec
{
    // "Project id" part of IPv6 addresses.
    required uint32 project_id = 1;
}

message TNetworkProjectStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "NodeSegment"
    snake_case_name: "node_segment"
    type_value: 7
};

message TNodeSegmentSpec
{
    required string node_filter = 1;
}

message TNodeSegmentStatus
{
    // Aggregates for all nodes belonging to this segment, regardless of their HFSM state.
    optional TPerSegmentResourceTotals total_resources = 1;
    // Aggregates for all nodes belonging to this segment and having "up" HFSM state.
    optional TPerSegmentResourceTotals schedulable_resources = 2;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "VirtualService"
    snake_case_name: "virtual_service"
    type_value: 8
};

message TVirtualServiceSpec
{
    // IP6 address, in textual form.
    repeated string ip6_addresses = 1;
    // IP4 address, in textual form.
    repeated string ip4_addresses = 2;
}

message TVirtualServiceStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "User"
    snake_case_name: "user"
    type_value: 9
};

message TUserSpec
{
    // If true, user is forbidden from accessing the cluster.
    optional bool banned = 1;
}

message TUserStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Group"
    snake_case_name: "group"
    type_value: 10
};

message TGroupSpec
{
    // List of subjects (users and groups) that are members of this group.
    repeated string members = 1;
}

message TGroupStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "InternetAddress"
    snake_case_name: "internet_address"
    type_value: 11
};

message TInternetAddressSpec
{
    required string ip4_address = 1;
    required string network_module_id = 2;
}

message TInternetAddressStatus
{
    optional string pod_id = 1;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "DnsRecordSet"
    snake_case_name: "dns_record_set"
    type_value: 14
};

message TDnsRecordSetSpec
{
    message TResourceRecord
    {
        optional uint64 ttl = 1;
        optional string class = 2;

        enum EType
        {
            A = 1
            [(NYT.NYson.NProto.enum_value_name) = "A"];

            PTR = 12
            [(NYT.NYson.NProto.enum_value_name) = "PTR"];

            AAAA = 28
            [(NYT.NYson.NProto.enum_value_name) = "AAAA"];
        }
        optional EType type = 3;
        optional string data = 4;
    }

    repeated TResourceRecord records = 1;
}

message TDnsRecordSetStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Account"
    snake_case_name: "account"
    type_value: 12
};

message TAccountSpec
{
    optional string parent_id = 1;
    optional TResourceTotals resource_limits = 2 [(NYP.NClient.NApi.NProto.etc) = true];
}

message TAccountStatus
{
    optional TResourceTotals resource_usage = 1;
    optional TResourceTotals immediate_resource_usage = 2;
}

////////////////////////////////////////////////////////////////////////////////
