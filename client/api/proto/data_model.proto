package NYP.NClient.NApi.NProto;

// COMPAT(babenko): will be dropped after switching to pod agent.
import "yp/client/api/proto/cluster_api.proto";
import "yp/client/api/proto/pod_agent.proto";
import "yp/client/api/proto/object_type.proto";

import "yt/core/yson/proto/protobuf_interop.proto";
import "yt/core/ytree/proto/attributes.proto";
import "yt/core/misc/proto/error.proto";

option java_package = "ru.yandex.yp.client.api";
option java_outer_classname = "DataModel";

////////////////////////////////////////////////////////////////////////////////

enum EEventType
{
    ET_OBJECT_CREATED = 0
    [(NYT.NYson.NProto.enum_value_name) = "object_created"];

    ET_OBJECT_REMOVED = 1
    [(NYT.NYson.NProto.enum_value_name) = "object_removed"];

    ET_OBJECT_UPDATED = 2
    [(NYT.NYson.NProto.enum_value_name) = "object_updated"];
}

////////////////////////////////////////////////////////////////////////////////

enum EAccessControlAction
{
    ACA_ALLOW = 1
    [(NYT.NYson.NProto.enum_value_name) = "allow"];

    ACA_DENY = 2
    [(NYT.NYson.NProto.enum_value_name) = "deny"];
}

enum EAccessControlPermission
{
    ACP_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ACP_READ = 1
    [(NYT.NYson.NProto.enum_value_name) = "read"];

    ACP_READ_SECRETS = 8
    [(NYT.NYson.NProto.enum_value_name) = "read_secrets"];

    ACA_WRITE = 2
    [(NYT.NYson.NProto.enum_value_name) = "write"];

    ACA_CREATE = 3
    [(NYT.NYson.NProto.enum_value_name) = "create"];

    ACA_SSH_ACCESS = 4
    [(NYT.NYson.NProto.enum_value_name) = "ssh_access"];

    ACA_ROOT_SSH_ACCESS = 5
    [(NYT.NYson.NProto.enum_value_name) = "root_ssh_access"];

    ACA_USE = 6
    [(NYT.NYson.NProto.enum_value_name) = "use"];

    ACA_GET_QYP_VM_STATUS = 7
    [(NYT.NYson.NProto.enum_value_name) = "get_qyp_vm_status"];
}

message TAccessControlEntry
{
    // Determines the access control action to take upon a match.
    required EAccessControlAction action = 1;

    // List of permissions this entry applies to.
    repeated EAccessControlPermission permissions = 2;

    // List of subjects (users and groups) this entry applies to.
    repeated string subjects = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TAntiaffinityConstraint
{
    // Topology zone key.
    // Node zones are specified via /node/labels/topology/key=value labels.
    // and are filled on node's import.
    // Supported zone keys are: node, rack, dc.
    required string key = 1;

    // Maximum number of pods that can be placed in the same zone.
    required int64 max_pods = 2;

    // Describes the pods this constraint applies to.
    // TODO(babenko): this is not currently implemented
    optional string pod_filter = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TPerSegmentResourceTotals
{
    message TMemoryTotals
    {
        // In bytes.
        optional int64 capacity = 1;
    }

    message TCpuTotals
    {
        // In VCPU units.
        optional int64 capacity = 1;
    }

    message TDiskTotals
    {
        // In bytes.
        optional int64 capacity = 1;
    }

    message TInternetAddressTotals
    {
        optional int64 capacity = 1;
    }

    optional TMemoryTotals memory = 1;
    optional TMemoryTotals cpu = 2;
    map<string, TDiskTotals> disk_per_storage_class = 3 [(NYT.NYson.NProto.yson_map) = true];
    optional TInternetAddressTotals internet_address = 4;
}

message TResourceTotals
{
    map<string, TPerSegmentResourceTotals> per_segment = 1 [(NYT.NYson.NProto.yson_map) = true];
}

////////////////////////////////////////////////////////////////////////////////

// Most TXXXMeta messages are same (up to minor changes); here we only document
// TSchemaMeta; these descriptions apply to all meta fields with matching names.
message TSchemaMeta
{
    // Object id; unique within its type.
    // Object is typically provided by the user upon object construction and can be reused.
    // Once assigned, object id cannot be changed.
    optional string id = 1;

    // Univerally unique id; assigned by YP master and is never reused.
    // Helpful to track object identity.
    optional string uuid = 12;

    // Optional descriptive name that is displayed in e.g. error messages or UI.
    // In contrast to id, YP master does not guarantee uniqueness of names.
    // Names can be changed at any time.
    // Not all object types support custom names; attempting to set this attribute for those lacking support
    // raises an error.
    optional string name = 13;

    // Type of the object.
    optional EObjectType type = 2;

    // The instant of time the object was constructed.
    optional uint64 creation_time = 3;

    // If true, the object inherits all ACEs from appropriate "parent".
    // For schemas this is assumed to be always false.
    optional bool inherit_acl = 10;

    // The list of ACEs comprising object's ACL.
    repeated TAccessControlEntry acl = 11;
}

message TSchemaSpec
{ }

message TSchemaStatus
{ }

message TSchema
{
    optional TSchemaMeta meta = 1;
    optional TSchemaSpec spec = 2;
    optional TSchemaStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

enum EResourceKind
{
    RK_UNDEFINED = -1
    [(NYT.NYson.NProto.enum_value_name) = "undefined"];

    RK_CPU = 0
    [(NYT.NYson.NProto.enum_value_name) = "cpu"];

    RK_MEMORY = 1
    [(NYT.NYson.NProto.enum_value_name) = "memory"];

    RK_DISK = 2
    [(NYT.NYson.NProto.enum_value_name) = "disk"];
}

enum EDiskVolumePolicy
{
    DVP_QUOTA = 0
    [(NYT.NYson.NProto.enum_value_name) = "quota"];

    DVP_EXCLUSIVE = 1
    [(NYT.NYson.NProto.enum_value_name) = "exclusive"];
}

message TResourceMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    required string node_id = 4;
    required EResourceKind kind = 5;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TResourceSpec
{
    message TCpuSpec
    {
        // In VCPU units.
        required uint64 total_capacity = 1;
        // Calibrated compute power of a single "physical" CPU core.
        // Typically "physical" CPU cores are, in fact, HT threads.
        optional double cpu_to_vcpu_factor = 2 [default = 1.0];
    }

    message TMemorySpec
    {
        // In bytes.
        required uint64 total_capacity = 1;
    }

    message TDiskSpec
    {
        // E.g. ssd, hdd etc.
        required string storage_class = 1;
        // In bytes.
        required uint64 total_capacity = 2;
        // Each volume occupies a virtual "slot".
        // This prevents assigning too many volumes to a single physical disk.
        optional uint64 total_volume_slots = 3;
        // E.g. /dev/* path.
        optional string device = 4;
        // List of supported allocation policies.
        repeated EDiskVolumePolicy supported_policies = 5;
    }

    oneof concrete_spec
    {
        TCpuSpec cpu = 3;
        TMemorySpec memory = 4;
        TDiskSpec disk = 5;
    }
}

message TResourceStatus
{
    message TCpuAllocation
    {
        required uint64 capacity = 1;
    }

    message TMemoryAllocation
    {
        required uint64 capacity = 1;
    }

    message TDiskAllocation
    {
        required uint64 capacity = 1;
        required bool exclusive = 2;
        required string volume_id = 3;
    }

    message TAllocation
    {
        optional string pod_id = 1;

        oneof concrete_allocation
        {
            TCpuAllocation cpu = 2;
            TMemoryAllocation memory = 3;
            TDiskAllocation disk = 4;
        }
    }
    repeated TAllocation scheduled_allocations = 1;
    repeated TAllocation actual_allocations = 2;
}

message TResource
{
    optional TResourceMeta meta = 1;
    optional TResourceSpec spec = 2;
    optional TResourceStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

enum EHfsmState
{
    HS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    HS_INITIAL = 100
    [(NYT.NYson.NProto.enum_value_name) = "initial"];

    HS_UP = 200
    [(NYT.NYson.NProto.enum_value_name) = "up"];

    HS_DOWN = 300
    [(NYT.NYson.NProto.enum_value_name) = "down"];

    HS_SUSPECTED = 400
    [(NYT.NYson.NProto.enum_value_name) = "suspected"];

    HS_PREPARE_MAINTENANCE = 500
    [(NYT.NYson.NProto.enum_value_name) = "prepare_maintenance"];

    HS_MAINTENANCE = 600
    [(NYT.NYson.NProto.enum_value_name) = "maintenance"];

    HS_PROBATION = 700
    [(NYT.NYson.NProto.enum_value_name) = "probation"];
}

enum ENodeMaintenanceState
{
    NMS_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    NMS_REQUESTED = 100
    [(NYT.NYson.NProto.enum_value_name) = "requested"];

    NMS_ACKNOWLEDGED = 200
    [(NYT.NYson.NProto.enum_value_name) = "acknowledged"];

    NMS_IN_PROGRESS = 300
    [(NYT.NYson.NProto.enum_value_name) = "in_progress"];
}

message TNodeMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TNodeSpec
{
    message TIP6Subnet
    {
        // IP6 /64-subnet, in textual form.
        required string subnet = 1;

        // E.g. backbone or fastbone.
        required string vlan_id = 2;
    }
    // MTN subnets.
    repeated TIP6Subnet ip6_subnets = 1;

    message TIP6Address
    {
        // IP6 address, in textual form.
        required string address = 1;

        // E.g. backbone or fastbone.
        required string vlan_id = 2;
    }
    // Host (dom0) IP6 addresses.
    repeated TIP6Address ip6_addresses = 2;

    // Used to construct /pod/status/transient_fqdn.
    // Typically this is the first part of the node's FQDN, i.e.
    // "sas1-3329" for "sas1-3329.search.yandex.net".
    optional string short_name = 3;

    message THfsm
    {
        // Setting this to false prevents automatic HFSM status updates.
        optional bool enable_sync = 2;
    }
    // HFSM controls.
    optional THfsm hfsm = 5;

    // NOC module in "physical" network topology.
    optional string network_module_id = 6;

    // If true then YP Master instructs node agents to drop all unknown pods.
    optional bool force_remove_unknown_pods = 7;
}

message TNodeStatus
{
    // Current epoch used for master-agent communication.
    optional string epoch_id = 1;

    // Timestamp of the last agent heartbeat.
    optional uint64 last_seen_time = 2;

    // Used for properly sequencing master-agent communication.
    optional uint64 heartbeat_sequence_number = 3;

    // Address of GPRC service at agent used for out-of-band notifications.
    optional string agent_address = 4;

    // Version of the agent running at this node (as reported during the last handshake).
    optional string agent_version = 8;

    message THfsm
    {
        // Current HFSM state.
        optional EHfsmState state = 1;

        // Timestamp of last change.
        optional uint64 last_updated = 2;

        // Comment for the last change.
        optional string message = 3;
    }
    // HFSM info.
    optional THfsm hfsm = 5;

    message TMaintenance
    {
        // Current maintenance state.
        optional ENodeMaintenanceState state = 1;

        // Timestamp of last change.
        optional uint64 last_updated = 2;

        // Comment for the last change.
        optional string message = 3;
    }
    // Maintenance workflow.
    optional TMaintenance maintenance = 6;

    // Contains ids of pods that are reported to be present at the node
    // but are neither known to exist nor were recently removed.
    repeated string unknown_pod_ids = 7;
}

message TNodeControl
{
    message TUpdateHfsmState
    {
        // New HFSM state.
        optional EHfsmState state = 1;

        // Comment for changing HFSM state.
        optional string message = 2;
    }

    // Enables updating HFSM state.
    optional TUpdateHfsmState update_hfsm_state = 1;
}

message TNode
{
    optional TNodeMeta meta = 1;
    optional TNodeSpec spec = 2;
    optional TNodeStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
    optional TNodeControl control = 6;
}

////////////////////////////////////////////////////////////////////////////////

enum EPodCurrentState
{
    PCS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    PCS_START_PENDING = 100
    [(NYT.NYson.NProto.enum_value_name) = "start_pending"];

    PCS_STARTED = 200
    [(NYT.NYson.NProto.enum_value_name) = "started"];

    PCS_STOP_PENDING = 300
    [(NYT.NYson.NProto.enum_value_name) = "stop_pending"];

    PCS_STOPPED = 400
    [(NYT.NYson.NProto.enum_value_name) = "stopped"];

    // Pod could not be started (for example, the received spec was invalid).
    PCS_START_FAILED = 500
    [(NYT.NYson.NProto.enum_value_name) = "start_failed"];
}

enum EPodTargetState
{
    PTS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    PTS_REMOVED = 1
    [(NYT.NYson.NProto.enum_value_name) = "removed"];

    PTS_ACTIVE = 100
    [(NYT.NYson.NProto.enum_value_name) = "active"];
}

message TPodMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    required string pod_set_id = 4;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

enum EPodHostNameKind
{
    PHNK_TRANSIENT = 0
    [(NYT.NYson.NProto.enum_value_name) = "transient"];

    PHNK_PERSISTENT = 1
    [(NYT.NYson.NProto.enum_value_name) = "persistent"];
}

message TPodSpec
{
    // Raw ISS payload to be delivered to agent.
    // COMPAT(babenko): will be deprecated after switching to pod agent.
    optional bytes iss_payload = 1;

    // Structured ISS spec.
    // COMPAT(babenko): will be deprecated after switching to pod agent.
    optional NYP.NClient.NApi.NClusterApiProto.HostConfiguration iss = 9;


    message TPodAgentDeploymentMeta
    {
        // URL to download pod agent binary from.
        // This might be unified with TLayer now, but they may diverge later, so leave it here.
        optional string url = 1;

        // <scheme>:<hex value>. Supported schemes are "MD5" and "EMPTY".
        optional string checksum = 2;

        // Arguments to be passed to pod agent via command line.
        map<string, string> configuration = 3 [(NYT.NYson.NProto.yson_map) = true];

        message TLayer
        {
            // URL to download layer from.
            optional string url = 1;

            // <scheme>:<hex value>. Supported schemes are "MD5" and "EMPTY".
            optional string checksum = 2;
        }

        // List of layers to construct pod chroot fs from, from top to bottom (same order as used by porto).
        repeated TLayer layers = 5;
    }

    message TPodAgentPayload
    {
        optional NInfra.NPodAgent.API.TPodAgentSpec spec = 1;
        optional TPodAgentDeploymentMeta meta = 2;
    }

    // Pod agent deployment and its workload specs.
    // COMPAT(babenko): Either this or iss_payload/iss should be present.
    optional TPodAgentPayload pod_agent_payload = 14;

    // Node id this pod must be assigned to.
    // XXX(babenko): WILL BE REMOVED SOON. DON'T USE.
    optional string node_id = 2;

    message TResourceRequests
    {
        optional uint64 vcpu_guarantee = 1;
        optional uint64 vcpu_limit = 2;

        optional uint64 memory_guarantee = 3;
        optional uint64 memory_limit = 4;
        optional uint64 anonymous_memory_limit = 5;
        optional uint64 dirty_memory_limit = 6;
    };
    // CPU and memory resources to allocate and configure for this pod upon assignment.
    optional TResourceRequests resource_requests = 3;

    message TIP6AddressRequest
    {
        // Id of network_project.
        // Could be omitted if manual_address is given.
        optional string network_id = 1;

        // Will be matched against /node/spec/ip6_subnets/*/vlan_id.
        required string vlan_id = 2;

        // These labels get propagated to /pod/status/ip6_address_allocations/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;

        // If given, specifies the exact IP6 address to use thus disabling IP Broker.
        // This feature will only be used for migration and will be deprecated afterwards.
        optional string manual_address = 4;

        // If true, this address is published to DNS.
        optional bool enable_dns = 5;

        // If non-empty, full DNS name is prepended with this string (plus dot).
        optional string dns_prefix = 6;

        // If true, internet tunnels is configured (InternetAddress is allocated and assigned to pod).
        optional bool enable_internet = 7;

        // If given, virtual service tunnels are configured.
        repeated string virtual_service_ids = 8;
    }
    // IP6 addresses to allocate for this pod upon assignment.
    repeated TIP6AddressRequest ip6_address_requests = 5;

    message TIP6SubnetRequest
    {
        // Will be matched against /node/spec/ip6_subnets/*/vlan_id.
        required string vlan_id = 1;

        // These labels get propagated to /node/status/ip6_subnet_allocations/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 2;
    }
    // IP6 subnets to allocate for this pod upon assignment.
    repeated TIP6SubnetRequest ip6_subnet_requests = 6;

    message TDiskVolumeRequest
    {
        // Pod-wise unique id.
        required string id = 1;

        // These labels get propagated to /pod/status/disk_volume_allocations/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 2;

        // E.g. ssd, hdd.
        required string storage_class = 3;

        message TQuotaPolicy
        {
            // Quota limit for this volume.
            required uint64 capacity = 1;
        }

        message TExclusivePolicy
        {
            // Minimum capacity the disk must have.
            // The client, however, will be charged for the whole disk capacity.
            required uint64 min_capacity = 1;
        }

        oneof concrete_policy
        {
            TQuotaPolicy quota_policy = 6;
            TExclusivePolicy exclusive_policy = 7;
        }
    }
    // Disk volumes to allocate for this pod upon assignment.
    repeated TDiskVolumeRequest disk_volume_requests = 13;

    // If false then YP will not be scheduling this pod.
    optional bool enable_scheduling = 7;

    // If given, controls which nodes are eligible for this pod.
    // Filter is a query language predicate; it can only refer to node labels, not other attributes.
    optional string node_filter = 8;

    message THostDevice
    {
        // E.g. /dev/kvm
        required string path = 1;

        // E.g. "r", "rw"
        required string mode = 2;
    }
    // Host devices to configure.
    // https://wiki.yandex-team.ru/porto/propertiesanddata/#resursy
    repeated THostDevice host_devices = 10;

    message TSysctlProperty
    {
        required string name = 1;
        required string value = 2;
    }
    // Sysctl properties to configure.
    repeated TSysctlProperty sysctl_properties = 11;

    message TVirtualServiceOptions
    {
        optional uint32 ip4_mtu = 2;
        optional uint32 ip6_mtu = 3;
        optional string decapsulator_anycast_address = 4;
    }
    optional TVirtualServiceOptions virtual_service_options = 12;

    // Determines the kind of "hostname" Porto property: either
    // "persistent" or "transient" pod FQDN can be used.
    optional EPodHostNameKind host_name_kind = 15;

    message TSecret
    {
        required string secret_id = 1;
        required string secret_version = 2;
        required string delegation_token = 3;
    }

    // Defines secrets to be delivered to the pod.
    map<string, TSecret> secrets = 16 [(NYT.NYson.NProto.yson_map) = true];
}

enum EEvictionState
{
    ES_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ES_REQUESTED = 100
    [(NYT.NYson.NProto.enum_value_name) = "requested"];

    ES_ACKNOWLEDGED = 200
    [(NYT.NYson.NProto.enum_value_name) = "acknowledged"];
}

enum EEvictionReason
{
    ER_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ER_HFSM = 100
    [(NYT.NYson.NProto.enum_value_name) = "hfsm"];

    ER_SCHEDULER = 200
    [(NYT.NYson.NProto.enum_value_name) = "scheduler"];
}

enum ESchedulingState
{
    SS_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    SS_DISABLED = 100
    [(NYT.NYson.NProto.enum_value_name) = "disabled"];

    SS_PENDING = 200
    [(NYT.NYson.NProto.enum_value_name) = "pending"];

    SS_ASSIGNED = 300
    [(NYT.NYson.NProto.enum_value_name) = "assigned"];
}

message TPodStatus
{
    // Node where this pod currently belongs to.
    optional string node_id = 1;

    message TAgent
    {
        // ISS pod state.
        optional EPodCurrentState state = 1;

        // Raw ISS payload received from agent.
        // COMPAT(babenko): will be deprecated after switching to pod agent.
        optional bytes iss_payload = 3;

        // Structured ISS status.
        // COMPAT(babenko): will be deprecated after switching to pod agent.
        optional NYP.NClient.NApi.NClusterApiProto.HostCurrentState iss = 4;

        message TPodAgentPayload
        {
            optional NInfra.NPodAgent.API.TPodAgentStatus status = 1;
        }

        // Pod agent status.
        // COMPAT(babenko): Either this or iss_payload/iss should be present.
        optional TPodAgentPayload pod_agent_payload = 5;

        // Error in pod execution passed from agent via heartbeat.
        optional NYT.NProto.TError execution_error = 6;

        // Error occurred while installing this pod to the node.
        optional NYT.NProto.TError install_error = 9;

        // Contains the spec timestamps for which install_error was observed.
        optional uint64 failed_install_attempt_spec_timestamp = 10;

        // Errors in pod spec validation passed from agent via heartbeat.
        repeated string validation_failures = 8;

        // The instant the last heartbeat from agent containing the status of this pod was received.
        optional uint64 last_heartbeat_time = 7;
    }
    optional TAgent agent = 2;

    message TResourceAllocation
    {
        optional string resource_id = 1;
    }
    repeated TResourceAllocation scheduled_resource_allocations = 4;

    message TIP6AddressAllocation
    {
        // IP6 address assigned by YP, in textual form.
        optional string address = 1;

        // Copied from /pod/spec/ip6_addresses/*/vlan_id.
        optional string vlan_id = 2;

        // Copied from /pod/spec/ip6_subnet_requests/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;

        // True if the the address was manually specified via /pod/spec/ip6_address_allocations/*/manual_address.
        optional bool manual = 4;

        // Persistent DNS name assigned to this address (if any) of the form:
        // [<dns_prefix>.]<pod-id>.<suffix>
        // This FQDN never changes.
        optional string persistent_fqdn = 5;

        // Transient DNS name assigned to this address (if any) of the form:
        // [<dns_prefix>.]<node-short-name>-<generation-number>.<pod-id>.<suffix>
        // This FQDN changes each time pod gets reassigned to another node.
        optional string transient_fqdn = 6;

        message TInternetAddress
        {
            required string id = 1;
            required string ip4_address = 2;
        }

        // Internet address assigned to this allocation.
        optional TInternetAddress internet_address = 7;

        message TVirtualService
        {
            // IP6 address, in textual form.
            repeated string ip6_addresses = 1;
            // IP4 address, in textual form.
            repeated string ip4_addresses = 2;
        }

        // Virtual services assigned to this allocation.
        repeated TVirtualService virtual_services = 8;
    }
    repeated TIP6AddressAllocation ip6_address_allocations = 5;

    message TIP6SubnetAllocation
    {
        // IP6 /112-subnet assigned by YP, in textual form.
        optional string subnet = 1;

        // Copied from /pod/spec/ip6_addresses/*/vlan_id.
        optional string vlan_id = 2;

        // Copied from /node/spec/ip6_address_requests/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;
    }
    repeated TIP6SubnetAllocation ip6_subnet_allocations = 6;

    message TDiskVolumeAllocation
    {
        // Copied from /pod/spec/disk_volume_requests/*/id.
        optional string id = 1;

        // Copied from /pod/spec/ip6_subnet_requests/*/labels.
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;

        // Total volume capacity.
        optional uint64 capacity = 4;

        // Id of disk resource where this volume will reside.
        optional string resource_id = 5;

        // Globally-unique volume id.
        // This is generated each time a "new" volume is assigned to the pod.
        // "New" volumes are recognized based on /pod/spec/disk_volume_allocations/*/id.
        optional string volume_id = 6;

        // Copied from /resource/spec/disk/device.
        optional string device = 7;
    }
    repeated TDiskVolumeAllocation disk_volume_allocations = 14;

    message TDns
    {
        // Persistent FQDN of the form:
        // <pod-id>.<suffix>
        // This FQDN never changes.
        optional string persistent_fqdn = 7;

        // Transient FQDN of the form:
        // <node-short-name>-<generation-number>.<pod-id>.<suffix>
        // This FQDN changes each time pod gets reassigned to another node.
        optional string transient_fqdn = 8;
    }
    optional TDns dns = 7;

    message TEviction
    {
        optional EEvictionState state = 1;
        optional EEvictionReason reason = 2;
        optional uint64 last_updated = 3;
        optional string message = 4;
    }
    optional TEviction eviction = 8;

    message TScheduling
    {
        optional ESchedulingState state = 1;
        optional string node_id = 2;
        optional uint64 last_updated = 3;
        optional string message = 4;
        optional NYT.NProto.TError error = 5;
    }
    optional TScheduling scheduling = 9;

    // Increased each time the pod is being assigned to another node.
    optional uint64 generation_number = 10;

    // Timestamp of the last spec update.
    optional uint64 master_spec_timestamp = 11;

    // Timestamp of the spec as reported by agent.
    optional uint64 agent_spec_timestamp = 12;
}

message TPodControl
{
    message TAcknowledgeEviction
    {
        // Comment for the acknowledgement.
        optional string message = 1;
    }

    // Acknowledges eviction of a pod.
    // Pod must have /status/eviction/state == "requested" prior to this call and
    // the latter changes it to "acknowledged".
    optional TAcknowledgeEviction acknowledge_eviction = 1;
}

message TPod
{
    optional TPodMeta meta = 1;
    optional TPodSpec spec = 2;
    optional TPodStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TPodSetMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TPodSetSpec
{
    // Limits placing pods of this pod set to the same topology zone (e.g. node, rack, DC).
    repeated TAntiaffinityConstraint antiaffinity_constraints = 1;

    // Specifies a node segment where all pods of this pod set must be scheduled to.
    optional string node_segment_id = 2;

    // Account that must be charged for this podset.
    optional string account_id = 3;
}

message TPodSetStatus
{ }

message TPodSet
{
    optional TPodSetMeta meta = 1;
    optional TPodSetSpec spec = 2;
    optional TPodSetStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TEndpointMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    required string endpoint_set_id = 4;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TEndpointSpec
{
    optional string protocol = 1;
    optional string fqdn = 2;
    optional string ip4_address = 3;
    optional string ip6_address = 4;
    optional int32 port = 5;
}

message TEndpointStatus
{ }

message TEndpoint
{
    optional TEndpointMeta meta = 1;
    optional TEndpointSpec spec = 2;
    optional TEndpointStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TEndpointSetMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TEndpointSetSpec
{
    // If given, for each pod matching this filter, an endpoint will be created.
    optional string pod_filter = 1;

    // If given, this value will be propagated to /endpoint/spec/protocol of each created endpoint.
    optional string protocol = 2;

    // If given, this value will be propagated to /endpoint/spec/port of each created endpoint.
    optional int32 port = 3;
}

message TEndpointSetStatus
{ }

message TEndpointSet
{
    optional TEndpointSetMeta meta = 1;
    optional TEndpointSetSpec spec = 2;
    optional TEndpointSetStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TNetworkProjectMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TNetworkProjectSpec
{
    // "Project id" part of IPv6 addresses.
    required uint32 project_id = 1;
}

message TNetworkProjectStatus
{ }

message TNetworkProject
{
    optional TNetworkProjectMeta meta = 1;
    optional TNetworkProjectSpec spec = 2;
    optional TNetworkProjectStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TNodeSegmentMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TNodeSegmentSpec
{
    required string node_filter = 1;
}

message TNodeSegmentStatus
{
    // Aggregates for all nodes belonging to this segment, regardless of their HFSM state.
    optional TPerSegmentResourceTotals total_resources = 1;
    // Aggregates for all nodes belonging to this segment and having "up" HFSM state.
    optional TPerSegmentResourceTotals schedulable_resources = 2;
}

message TNodeSegment
{
    optional TNodeSegmentMeta meta = 1;
    optional TNodeSegmentSpec spec = 2;
    optional TNodeSegmentStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TVirtualServiceMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TVirtualServiceSpec
{
    // IP6 address, in textual form.
    repeated string ip6_addresses = 1;
    // IP4 address, in textual form.
    repeated string ip4_addresses = 2;
}

message TVirtualServiceStatus
{ }

message TVirtualService
{
    optional TVirtualServiceMeta meta = 1;
    optional TVirtualServiceSpec spec = 2;
    optional TVirtualServiceStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TUserMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TUserSpec
{
    // If true, user is forbidden from accessing the cluster.
    optional bool banned = 1;
}

message TUserStatus
{ }

message TUser
{
    optional TUserMeta meta = 1;
    optional TUserSpec spec = 2;
    optional TUserStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TGroupMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TGroupSpec
{
    // List of subjects (users and groups) that are members of this group.
    repeated string members = 1;
}

message TGroupStatus
{ }

message TGroup
{
    optional TGroupMeta meta = 1;
    optional TGroupSpec spec = 2;
    optional TGroupStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TInternetAddressMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TInternetAddressSpec
{
    required string ip4_address = 1;
    required string network_module_id = 2;
}

message TInternetAddressStatus
{
    optional string pod_id = 1;
}

message TInternetAddress
{
    optional TInternetAddressMeta meta = 1;
    optional TInternetAddressSpec spec = 2;
    optional TInternetAddressStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TDnsRecordSetMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TDnsRecordSetSpec
{
    message TResourceRecord 
    {
        optional uint64 ttl = 1;
        optional string class = 2;

        enum EType
        {
            A = 1
            [(NYT.NYson.NProto.enum_value_name) = "A"];

            PTR = 12
            [(NYT.NYson.NProto.enum_value_name) = "PTR"];

            AAAA = 28
            [(NYT.NYson.NProto.enum_value_name) = "AAAA"];
        }
        optional EType type = 3;
        optional string data = 4;
    }

    repeated TResourceRecord records = 1;
}

message TDnsRecordSetStatus
{}

message TDnsRecordSet
{
    optional TDnsRecordSetMeta meta = 1;
    optional TDnsRecordSetSpec spec = 2;
    optional TDnsRecordSetStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TAccountMeta
{
    optional string id = 1;
    optional string uuid = 12;
    optional string name = 13;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TAccountSpec
{
    optional string parent_id = 1;
    optional TResourceTotals resource_limits = 2;
}

message TAccountStatus
{
    optional TResourceTotals resource_usage = 1;
    optional TResourceTotals immediate_resource_usage = 2;
}

message TAccount
{
    optional TAccountMeta meta = 1;
    optional TAccountSpec spec = 2;
    optional TAccountStatus status = 3;
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYT.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////
