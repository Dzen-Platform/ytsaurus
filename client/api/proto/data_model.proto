package NYP.NClient.NApi.NProto;

// COMPAT(babenko): will be dropped after switching to pod agent.
import "yp/client/api/proto/cluster_api.proto";
import "yp/client/api/proto/pod_agent.proto";
import "yp/client/api/proto/dynamic_attributes.proto";
import "yp/client/api/proto/conditions.proto";
import "yp/client/api/proto/enums.proto";
import "yp/client/api/proto/host_infra.proto";

import "yt/core/yson/proto/protobuf_interop.proto";
import "yt/core/ytree/proto/attributes.proto";
import "yt/core/misc/proto/error.proto";

import "google/protobuf/any.proto";
import "google/protobuf/descriptor.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

option python_package = "yp_proto.yp.client.api.proto";

option java_package = "ru.yandex.yp.client.api";
option java_outer_classname = "DataModel";

option go_package = "a.yandex-team.ru/yp/go/proto/ypapi";

////////////////////////////////////////////////////////////////////////////////

message TObjectTypeOption
{
    required string camel_case_name = 1;
    required string snake_case_name = 2;
    required int32 type_value = 3;
    optional string human_readable_name = 4;
}

extend google.protobuf.FileOptions
{
    repeated TObjectTypeOption object_type = 30000;
}

extend google.protobuf.FieldOptions
{
    repeated bool etc = 30000;
}

extend google.protobuf.MessageOptions
{
    optional string etc_type_name = 30000;
}

////////////////////////////////////////////////////////////////////////////////

enum EAccessControlAction
{
    ACA_ALLOW = 1
    [(NYT.NYson.NProto.enum_value_name) = "allow"];

    ACA_DENY = 2
    [(NYT.NYson.NProto.enum_value_name) = "deny"];
}

enum EAccessControlPermission
{
    ACP_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ACP_READ = 1
    [(NYT.NYson.NProto.enum_value_name) = "read"];

    ACP_READ_SECRETS = 8
    [(NYT.NYson.NProto.enum_value_name) = "read_secrets"];

    ACA_WRITE = 2
    [(NYT.NYson.NProto.enum_value_name) = "write"];

    ACA_CREATE = 3
    [(NYT.NYson.NProto.enum_value_name) = "create"];

    ACA_SSH_ACCESS = 4
    [(NYT.NYson.NProto.enum_value_name) = "ssh_access"];

    ACA_ROOT_SSH_ACCESS = 5
    [(NYT.NYson.NProto.enum_value_name) = "root_ssh_access"];

    ACA_USE = 6
    [(NYT.NYson.NProto.enum_value_name) = "use"];

    ACA_GET_QYP_VM_STATUS = 7
    [(NYT.NYson.NProto.enum_value_name) = "get_qyp_vm_status"];
}

message TAccessControlEntry
{
    // Determines the access control action to take upon a match.
    required EAccessControlAction action = 1;

    // List of permissions this entry applies to.
    repeated EAccessControlPermission permissions = 2;

    // List of subjects (users and groups) this entry applies to.
    repeated string subjects = 3;

    // List of attribute paths this entry applies to.
    // If this list is not specified or empty, this entry is applied to the root attribute path.
    repeated string attributes = 4;
}

////////////////////////////////////////////////////////////////////////////////

message TAntiaffinityConstraint
{
    reserved 3;
    reserved "pod_filter";

    // Topology zone key.
    // Node zones are specified via /node/labels/topology/key=value labels.
    // and are filled on node's import.
    // Supported zone keys are: node, rack, dc.
    required string key = 1;

    // Maximum number of pods that can be placed in the same zone.
    required int64 max_pods = 2;

    // If given, the constraint is independently applied to each group of pods with equal
    // group id at which this path points.
    //
    // Path must be of the form /labels/<key>, where <key> represents a single path token.
    // Otherwise scheduling will fail for the pod set with appropriate error.
    //
    // A pod is not required to have specified group id. If group id is missing,
    // the pod will not be affected by the constraint.
    //
    // If pod group id is specified, it must be of the string type.
    // Otherwise scheduling will fail for the pod with appropriate error.
    //
    // Example: pod_group_id_path = "/labels/antiaffinity_group_id" and /pod/labels/antiaffinity_group_id = "42".
    optional string pod_group_id_path = 4;
}

////////////////////////////////////////////////////////////////////////////////

message TPerSegmentResourceTotals
{
    message TMemoryTotals
    {
        // In bytes.
        optional int64 capacity = 1;
    }

    message TCpuTotals
    {
        // In VCPU units.
        optional int64 capacity = 1;
    }

    message TNetworkTotals
    {
        // In bytes per second.
        optional int64 bandwidth = 1;
    }

    message TDiskTotals
    {
        // In bytes.
        optional int64 capacity = 1;

        // In bytes per second.
        optional int64 bandwidth = 2;
    }

    message TGpuTotals
    {
        // In GPUs.
        optional int64 capacity = 1;
    }

    message TInternetAddressTotals
    {
        optional int64 capacity = 1;
    }

    optional TMemoryTotals memory = 1;
    optional TCpuTotals cpu = 2;
    map<string, TDiskTotals> disk_per_storage_class = 3
    [(NYT.NYson.NProto.yson_map) = true];
    optional TInternetAddressTotals internet_address = 4;
    map<string, TGpuTotals> gpu_per_model = 5
    [(NYT.NYson.NProto.yson_map) = true];
    optional TNetworkTotals network = 6;
}

message TResourceTotals
{
    map<string, TPerSegmentResourceTotals> per_segment = 1
    [(NYT.NYson.NProto.yson_map) = true];
}

////////////////////////////////////////////////////////////////////////////////

// We generate a bunch of TXXXMeta messages that "inherit" from TXXXMetaBase (if any).
// Their shared fields are as follows.
/*
message TXXXMeta
{
    // Object id; unique within its type.
    // Object is typically provided by the user upon object construction and can be reused.
    // Once assigned, object id cannot be changed.
    string id = 1;

    // Universally unique id; assigned by YP master and is never reused.
    // Helpful to track object identity.
    string uuid = 12;

    // Optional descriptive name that is displayed in e.g. error messages or UI.
    // In contrast to id, YP master does not guarantee uniqueness of names.
    // Names can be changed at any time.
    // Not all object types support custom names; attempting to set this attribute for those lacking support
    // raises an error.
    string name = 13;

    // Type of the object.
    EObjectType type = 2;

    // The instant of time the object was constructed.
    uint64 creation_time = 3;

    // If true, the object inherits all ACEs from appropriate "parent".
    // For schemas this is assumed to be always false.
    bool inherit_acl = 10;

    // The list of ACEs comprising object's ACL.
    repeated TAccessControlEntry acl = 11;
}
*/

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Node"
    snake_case_name: "node"
    type_value: 0
};

enum EHfsmState
{
    HS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    HS_INITIAL = 100
    [(NYT.NYson.NProto.enum_value_name) = "initial"];

    HS_UP = 200
    [(NYT.NYson.NProto.enum_value_name) = "up"];

    HS_DOWN = 300
    [(NYT.NYson.NProto.enum_value_name) = "down"];

    // COMPAT(bidzilya): deprecated, use /node/status/alerts instead.
    HS_SUSPECTED = 400
    [(NYT.NYson.NProto.enum_value_name) = "suspected"];

    HS_PREPARE_MAINTENANCE = 500
    [(NYT.NYson.NProto.enum_value_name) = "prepare_maintenance"];

    HS_MAINTENANCE = 600
    [(NYT.NYson.NProto.enum_value_name) = "maintenance"];

    HS_PROBATION = 700
    [(NYT.NYson.NProto.enum_value_name) = "probation"];
}

enum ENodeMaintenanceState
{
    NMS_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    NMS_REQUESTED = 100
    [(NYT.NYson.NProto.enum_value_name) = "requested"];

    NMS_ACKNOWLEDGED = 200
    [(NYT.NYson.NProto.enum_value_name) = "acknowledged"];

    NMS_IN_PROGRESS = 300
    [(NYT.NYson.NProto.enum_value_name) = "in_progress"];
}

enum EPodMaintenanceState
{
    PMS_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    PMS_REQUESTED = 100
    [(NYT.NYson.NProto.enum_value_name) = "requested"];

    PMS_ACKNOWLEDGED = 200
    [(NYT.NYson.NProto.enum_value_name) = "acknowledged"];

    PMS_IN_PROGRESS = 300
    [(NYT.NYson.NProto.enum_value_name) = "in_progress"];
}

message TNodeSpec
{
    message TIP6Subnet
    {
        // IP6 /64-subnet, in textual form.
        required string subnet = 1;

        // E.g. backbone or fastbone.
        required string vlan_id = 2;
    }
    // MTN subnets.
    repeated TIP6Subnet ip6_subnets = 1;

    message TIP6Address
    {
        // IP6 address, in textual form.
        required string address = 1;

        // E.g. backbone or fastbone.
        required string vlan_id = 2;
    }
    // Host (dom0) IP6 addresses.
    repeated TIP6Address ip6_addresses = 2;

    // Used to construct /pod/status/transient_fqdn.
    // Typically this is the first part of the node's FQDN, i.e.
    // "sas1-3329" for "sas1-3329.search.yandex.net".
    optional string short_name = 3;

    message THfsm
    {
        // Setting this to false prevents automatic HFSM status updates.
        optional bool enable_sync = 2;
    }
    // HFSM controls.
    optional THfsm hfsm = 5;

    // NOC module in "physical" network topology.
    optional string network_module_id = 6;

    // If true then YP Master instructs node agents to drop all unknown pods.
    optional bool force_remove_unknown_pods = 7;

    // If true then YP Master instructs node agents to drop all unknown persistent volumes.
    optional bool force_remove_unknown_persistent_volumes = 9;

    // Currently this is an opaque data; cf. YP-809.
    optional google.protobuf.Any host_manager = 8;
}

enum EMaintenanceKind
{
    MK_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    MK_POWER_OFF = 1
    [(NYT.NYson.NProto.enum_value_name) = "power-off"];

    MK_REBOOT = 2
    [(NYT.NYson.NProto.enum_value_name) = "reboot"];

    MK_PROFILE = 3
    [(NYT.NYson.NProto.enum_value_name) = "profile"];

    MK_REDEPLOY = 4
    [(NYT.NYson.NProto.enum_value_name) = "redeploy"];

    MK_REPAIR_LINK = 5
    [(NYT.NYson.NProto.enum_value_name) = "repair-link"];

    MK_CHANGE_DISK = 6
    [(NYT.NYson.NProto.enum_value_name) = "change-disk"];

    MK_TEMPORARY_UNREACHABLE = 7
    [(NYT.NYson.NProto.enum_value_name) = "temporary-unreachable"];
}

enum EMaintenancePriority
{
    MP_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    MP_HIGH = 1
    [(NYT.NYson.NProto.enum_value_name) = "high"];

    MP_NORMAL = 2
    [(NYT.NYson.NProto.enum_value_name) = "normal"];
}

message TMaintenanceInfo
{
    reserved 3;

    // Randomly generated globally unique identifier.
    optional string uuid = 1;

    // User-defined identifier.
    // Will be randomly generated if not provided.
    optional string id = 2;

    // Identifies maintenance type. Can be considered as urgency on the project's terms.
    optional EMaintenanceKind kind = 9;

    // Node set identifier, e.g. "switch-iva5-s32", which allows to group maintenances.
    optional string node_set_id = 4;

    // Human-readable description.
    optional string message = 5;

    // Indicates whether this maintenance can corrupt data.
    optional bool disruptive = 6;

    // Estimated duration.
    optional google.protobuf.Duration estimated_duration = 7;

    // Dynamically typed description.
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 8;

    // Priority.
    optional EMaintenancePriority priority = 10;
}

message TNodeAlert
{
    // Arbitrary type. It is supposed to be used for grouping and selection.
    // For example, "agent-heartbeat-timeout".
    optional string type = 1;

    // Globally-unique identifier generated by the master.
    optional string uuid = 2;

    // Creation time.
    optional google.protobuf.Timestamp creation_time = 3;

    // Human-readable description.
    optional string description = 4;

    // Dynamically typed description.
    optional NYT.NYTree.NProto.TAttributeDictionary labels = 5;
}

message TNodeStatus
{
    // Current epoch used for master-agent communication.
    optional string epoch_id = 1;

    // Timestamp of the last agent heartbeat.
    optional uint64 last_seen_time = 2;

    // Timestamp of the last agent handshake.
    optional uint64 last_handshake_time = 10
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Master address of the last agent handshake.
    optional string last_handshake_master_address = 11
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Used for properly sequencing master-agent communication.
    optional uint64 heartbeat_sequence_number = 3;

    // Address of GPRC service at agent used for out-of-band notifications.
    optional string agent_address = 4;

    // Version of the agent running at this node (as reported during the last handshake).
    optional string agent_version = 8
    [(NYP.NClient.NApi.NProto.etc) = true];

    message THfsm
    {
        // Current HFSM state.
        optional EHfsmState state = 1;

        // Timestamp of last change.
        optional uint64 last_updated = 2;

        // Comment for the last change.
        optional string message = 3;
    }
    // HFSM info.
    optional THfsm hfsm = 5
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TMaintenance
    {
        // Current maintenance state.
        optional ENodeMaintenanceState state = 1;

        // Timestamp of the last change.
        optional uint64 last_updated = 2;

        // Comment for the last change.
        optional string message = 3;

        // Describes the maintenance.
        optional TMaintenanceInfo info = 4;
    }
    // Maintenance workflow.
    optional TMaintenance maintenance = 6
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Each alert indicates that node in some unxpected state.
    // For example, it has no heartbeats for more than N minutes.
    // Scheduler will not assign pod on node with an active alert.
    repeated TNodeAlert alerts = 12
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Contains ids of pods that are reported to be present at the node
    // but are neither known to exist nor were recently removed.
    repeated string unknown_pod_ids = 7
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Contains ids of persistent volumes that are reported to be present at the disks
    // attached to the node but are neither known to exist nor were recently removed.
    repeated string unknown_persistent_volume_ids = 13
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Currently this is an opaque data; cf. YP-809.
    optional google.protobuf.Any host_manager = 9;

    // Ids of pods assigned to this node.
    repeated string pod_ids = 14;
}

message TNodeControl
{
    message TUpdateHfsmState
    {
        // New HFSM state.
        optional EHfsmState state = 1;

        // Comment for changing HFSM state.
        optional string message = 2;

        // Optional maintenance information.
        // Can be passed only if state is equal to HS_PREPARE_MAINTENANCE.
        optional TMaintenanceInfo maintenance_info = 3;
    }
    // Enables updating HFSM state.
    optional TUpdateHfsmState update_hfsm_state = 1;

    message TAddAlert
    {
        // Type of the alert to add (see TNodeAlert).
        optional string type = 1;

        // Human-readable description of the alert to add (see TNodeAlert).
        optional string description = 2;
    }
    // Adds node alert.
    optional TAddAlert add_alert = 3;

    message TRemoveAlert
    {
        // UUID of the alert to remove (see TNodeAlert).
        optional string uuid = 1;

        // Comment for debug purposes.
        optional string message = 2;
    }
    // Removes node alert.
    optional TRemoveAlert remove_alert = 2;

    message TAttachPersistentDisk
    {
        // Id of disk to attach.
        required string disk_id = 1;
    }
    // Attaches disk to node. For debug use only.
    optional TAttachPersistentDisk attach_persistent_disk = 4;

    message TDetachPersistentDisk
    {
        // Id of disk to detach.
        required string disk_id = 1;
    }
    // Detaches disk from node. For debug use only.
    optional TDetachPersistentDisk detach_persistent_disk = 5;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Schema"
    snake_case_name: "schema"
    type_value: 256
};

message TSchemaSpec
{ }

message TSchemaStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Resource"
    snake_case_name: "resource"
    type_value: 3
};

enum EDiskVolumePolicy
{
    DVP_QUOTA = 0
    [(NYT.NYson.NProto.enum_value_name) = "quota"];

    DVP_EXCLUSIVE = 1
    [(NYT.NYson.NProto.enum_value_name) = "exclusive"];
}

message TResourceMetaBase
{
    optional string node_id = 4;
    optional EResourceKind kind = 5;
}

message TResourceSpec
{
    message TCpuSpec
    {
        // In VCPU units.
        required uint64 total_capacity = 1;
        // Calibrated compute power of a single "physical" CPU core.
        // Typically "physical" CPU cores are, in fact, HT threads.
        optional double cpu_to_vcpu_factor = 2 [default = 1.0];
    }

    message TMemorySpec
    {
        // In bytes.
        required uint64 total_capacity = 1;
    }

    message TNetworkSpec
    {
        // In bytes per second.
        required uint64 total_bandwidth = 1;
    }

    // Cf. TPersistentDiskSpec.TManagedPolicy.
    message TDiskSpec
    {
        reserved 9, 10;
        // E.g. ssd, hdd etc.
        required string storage_class = 1;
        // In bytes.
        required uint64 total_capacity = 2;
        // Each volume occupies a virtual "slot".
        // This prevents assigning too many volumes to a single physical disk.
        optional uint64 total_volume_slots = 3;
        // E.g. /dev/* path.
        optional string device = 4;
        // List of supported allocation policies.
        repeated EDiskVolumePolicy supported_policies = 5;
        // Total provided bandwidth in bytes per second.
        optional uint64 total_bandwidth = 6;
        // Total provided read bandwidth is estimated
        // using total_bandwidth and the following factor.
        optional double read_bandwidth_factor = 7;
        // Total provided write bandwidth is estimated
        // using total_bandwidth and the following factor.
        optional double write_bandwidth_factor = 8;
        // Total provided read operations per second is estimated
        // using total_bandwidth and the following divisor.
        optional double read_operation_rate_divisor = 11;
        // Total provided write operations per second is estimated
        // using total_bandwidth and the following divisor.
        optional double write_operation_rate_divisor = 12;
    }

    message TSlotSpec
    {
        required uint64 total_capacity = 1;
    }

    message TGpuSpec
    {
        // Got from driver api.
        required string uuid = 1;
        // E.g. v100, k100 etc.
        required string model = 2;
        // In bytes.
        required uint64 total_memory = 3;
    }

    oneof concrete_spec
    {
        TCpuSpec cpu = 3;
        TMemorySpec memory = 4;
        TDiskSpec disk = 5;
        TSlotSpec slot = 6;
        TGpuSpec gpu = 7;
        TNetworkSpec network = 8;
    }
}

message TResourceStatus
{
    message TCpuAllocation
    {
        required uint64 capacity = 1;
    }

    message TMemoryAllocation
    {
        required uint64 capacity = 1;
    }

    message TNetworkAllocation
    {
        required uint64 bandwidth = 1;
    }

    message TDiskAllocation
    {
        required uint64 capacity = 1;
        required bool exclusive = 2;
        required string volume_id = 3;
        optional uint64 bandwidth = 4;
    }

    message TSlotAllocation
    {
        required uint64 capacity = 1;
    }

    message TGpuAllocation
    {
        // Copied from /pod/status/gpu_allocations/*/id
        required string allocation_id = 1;
        required uint64 capacity = 2;
    }

    message TAllocation
    {
        optional string pod_id = 1;
        optional string pod_uuid = 5;

        oneof concrete_allocation
        {
            TCpuAllocation cpu = 2;
            TMemoryAllocation memory = 3;
            TDiskAllocation disk = 4;
            TSlotAllocation slot = 6;
            TGpuAllocation gpu = 7;
            TNetworkAllocation network = 8;
        }
    }
    repeated TAllocation scheduled_allocations = 1;
    repeated TAllocation actual_allocations = 2;

    message TCpuStatistics
    {
        // In VCPU units.
        required uint64 capacity = 1;
    }

    message TMemoryStatistics
    {
        // In bytes.
        required uint64 capacity = 1;
    }

    message TNetworkStatistics
    {
        // In bytes per second.
        required uint64 bandwidth = 1;
    }

    message TDiskStatistics
    {
        reserved 1;

        // In bytes.
        required uint64 capacity = 2;

        // In bytes per second.
        optional uint64 bandwidth = 3;
    }

    message TSlotStatistics
    {
        required uint64 capacity = 1;
    }

    message TGpuStatistics
    {
        // In GPUs.
        required uint64 capacity = 1;
    }

    message TAllocationStatistics
    {
        oneof concrete_statisticss
        {
            TCpuStatistics cpu = 1;
            TMemoryStatistics memory = 2;
            TDiskStatistics disk = 3;
            TSlotStatistics slot = 4;
            TGpuStatistics gpu = 5;
            TNetworkStatistics network = 6;
        }
    }

    // Indicates free (unused) resource capacity.
    // "free" and "used" (see below) are calculated taking both scheduled and actual resource
    // allocations into account thus effectively simulating the scheduler's behaviour.
    optional TAllocationStatistics free = 3;
    // Indicated used capacity.
    optional TAllocationStatistics used = 4;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Pod"
    snake_case_name: "pod"
    type_value: 1
};

enum EPodCurrentState
{
    PCS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    PCS_START_PENDING = 100
    [(NYT.NYson.NProto.enum_value_name) = "start_pending"];

    PCS_STARTED = 200
    [(NYT.NYson.NProto.enum_value_name) = "started"];

    PCS_STOP_PENDING = 300
    [(NYT.NYson.NProto.enum_value_name) = "stop_pending"];

    PCS_STOPPED = 400
    [(NYT.NYson.NProto.enum_value_name) = "stopped"];

    // Pod could not be started (for example, the received spec was invalid).
    PCS_START_FAILED = 500
    [(NYT.NYson.NProto.enum_value_name) = "start_failed"];
}

enum EPodTargetState
{
    PTS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    PTS_REMOVED = 1
    [(NYT.NYson.NProto.enum_value_name) = "removed"];

    PTS_ACTIVE = 100
    [(NYT.NYson.NProto.enum_value_name) = "active"];
}

message TPodMetaBase
{
    optional string pod_set_id = 4;
}

message TPodDynamicResourceSpec
{
    reserved 4;
    reserved "url";

    // Resource identifier.
    optional string id = 1;

    // Desired revision of the resource.
    optional uint64 revision = 2;

    // Short label describing resource deploy group.
    optional string mark = 6;

    message TStorageOptions
    {
        // Name of the box to download resource into.
        optional string box_ref = 1;

        // Filesystem path where the application should see the resource.
        optional string destination = 2;

        // Filesystem path where resource versions should be downloaded.
        optional string storage_dir = 3;

        // HTTP GET handle to notify.
        // HTTP response codes from range 200-299 are considered to be success.
        message THttpAction
        {
            // Url to call.
            optional string url = 1;

            // Expected HTTP response body.
            optional string expected_answer = 2;
        }

        // Shell command to exec to notify.
        message TExecAction
        {
            // Shell command to execute.
            optional string command_line = 1;

            // Stdout to accept, if empty, stdout is ignored.
            optional string expected_answer = 2;
        }

        oneof Action
        {
            THttpAction http_action = 4;
            TExecAction exec_action = 5;
        }

        message TVerification
        {
            // Checksum in the form: <scheme>:<value> Supported schemes are "MD5:", "EMPTY:", "SHA256:", all case sensitive.
            optional string checksum = 1;

            // Period of checksum check. First check is done right after download.
            optional uint64 check_period_ms = 2;
        }

        // Rule how to check the resource.
        optional TVerification verification = 6;

        // How many copies including actual one should be kept. It's not recommended to use less than 2 (default).
        // If you set 1, your resource will be fully removed before downloading new revision.
        optional uint64 cached_revisions_count = 7;

        // Allow resource to be deduplicated via hardlinks if present.
        // Supported only for rbtorrent URLs.
        // Use only if you know what you are doing! Hardlinked data can be corrupted
        // by other users of the resource on the same host.
        optional bool allow_deduplication = 8;

        // Download speed limit in MBits per second.
        // Supported only for rbtorrent URLs.
        optional uint64 max_download_speed = 9;
    }

    optional TStorageOptions storage_options = 3;

    // URLs where to download the resource from
    // supported protocols: http, https, rbtorrent, raw
    // (for raw resources use "raw:data").
    // URLs are tried in order until successful download.
    repeated string urls = 5;
}

message TPodSpec
{
    // Raw ISS payload to be delivered to agent.
    // COMPAT(babenko): will be deprecated after switching to pod agent.
    optional bytes iss_payload = 1 [deprecated = true];

    // Structured ISS spec.
    // COMPAT(babenko): will be deprecated after switching to pod agent.
    optional NYP.NClient.NApi.NClusterApiProto.HostConfiguration iss = 9;


    message TPodAgentDeploymentMeta
    {
        // URL to download pod agent binary from.
        // This might be unified with TLayer now, but they may diverge later, so leave it here.
        optional string url = 1;

        // <scheme>:<hex value>. Supported schemes are "MD5" and "EMPTY".
        optional string checksum = 2;

        // Arguments to be passed to pod agent via command line.
        map<string, string> configuration = 3 [(NYT.NYson.NProto.yson_map) = true];

        message TLayer
        {
            // URL to download layer from.
            optional string url = 1;

            // <scheme>:<hex value>. Supported schemes are "MD5" and "EMPTY".
            optional string checksum = 2;
        }

        // List of layers to construct pod chroot fs from, from top to bottom (same order as used by porto).
        repeated TLayer layers = 5;
    }

    message TPodAgentPayload
    {
        optional NInfra.NPodAgent.API.TPodAgentSpec spec = 1;
        optional TPodAgentDeploymentMeta meta = 2;
    }

    // Pod agent deployment and its workload specs.
    // COMPAT(babenko): Either this or iss_payload/iss should be present.
    optional TPodAgentPayload pod_agent_payload = 14;

    // Node id this pod must be assigned to.
    // XXX(babenko): WILL BE REMOVED SOON. DON'T USE.
    optional string node_id = 2;

    message TSchedulingHint
    {
        optional string uuid = 1;
        optional google.protobuf.Timestamp creation_time = 2;
        optional string node_id = 3;

        // If true, scheduler must satisfy hint (if there are strong hints with different node ids, the pod will not be scheduled).
        // If false, node_id from hint is preferred, but not obligated.
        optional bool strong = 4;
    }

    message TScheduling
    {
        // Hints, that scheduler will take into account during planning of pod allocation.
        repeated TSchedulingHint hints = 1;
    }

    optional TScheduling scheduling = 26
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TResourceRequests
    {
        optional uint64 vcpu_guarantee = 1;
        optional uint64 vcpu_limit = 2;

        optional uint64 memory_guarantee = 3;
        optional uint64 memory_limit = 4;
        optional uint64 anonymous_memory_limit = 5;
        optional uint64 dirty_memory_limit = 6;

        optional uint64 slot = 7;

        optional uint64 network_bandwidth_guarantee = 8;
        optional uint64 network_bandwidth_limit = 9;

        // Pod container thread limit.
        // Requires use permission for pod set node segment attribute /access/scheduling/change_thread_limit.
        optional uint64 thread_limit = 10;
    };
    // CPU and memory resources to allocate and configure for this pod upon assignment.
    optional TResourceRequests resource_requests = 3
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TIP6AddressRequest
    {
        // Id of network_project.
        // This attribute supports update without rescheduling.
        required string network_id = 1;

        // Will be matched against /node/spec/ip6_subnets/*/vlan_id.
        required string vlan_id = 2;

        // These labels get propagated to /pod/status/ip6_address_allocations/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;

        // If true, this address is published to DNS.
        optional bool enable_dns = 5;

        // If non-empty, full DNS name is prepended with this string (plus dot).
        optional string dns_prefix = 6;

        // If true, internet tunnels is configured (InternetAddress is allocated and assigned to pod). See st/YP-1213.
        optional bool enable_internet = 7;

        // If given, virtual service tunnels are configured.
        repeated string virtual_service_ids = 8;

        // If given, InternetAddress is allocated in given pool.
        // Otherwise InternetAddress is allocated in default pool if enable_internet is set.
        optional string ip4_address_pool_id = 9;
    }
    // IP6 addresses to allocate for this pod upon assignment.
    repeated TIP6AddressRequest ip6_address_requests = 5
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TIP6SubnetRequest
    {
        // Id of network_project.
        // If omitted, no network configuration is actually being applied at nodes;
        // however the IP6 address nonce is still being reserved.
        optional string network_id = 3;

        // Will be matched against /node/spec/ip6_subnets/*/vlan_id.
        required string vlan_id = 1;

        // These labels get propagated to /node/status/ip6_subnet_allocations/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 2;
    }
    // IP6 subnets to allocate for this pod upon assignment.
    repeated TIP6SubnetRequest ip6_subnet_requests = 6
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TDiskVolumeRequest
    {
        // Pod-wise unique id.
        // TODO(babenko): rename to "name"
        required string id = 1;

        // These labels get propagated to /pod/status/disk_volume_allocations/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 2;

        // E.g. ssd, hdd.
        required string storage_class = 3;

        message TQuotaPolicy
        {
            // Guaranteed volume capacity.
            required uint64 capacity = 1;

            // Guaranteed volume bandwidth in bytes per second.
            optional uint64 bandwidth_guarantee = 2;

            // Volume bandwidth limit in bytes per second.
            optional uint64 bandwidth_limit = 3;
        }

        message TExclusivePolicy
        {
            // Minimum capacity the disk must have.
            // The client, however, will be charged for the whole disk capacity.
            required uint64 min_capacity = 1;

            // Minimum bandwidth in bytes per second the disk must provide.
            // The client, however, will be charged for the whole disk bandwidth.
            optional uint64 min_bandwidth = 2;
        }

        oneof concrete_policy
        {
            TQuotaPolicy quota_policy = 6;
            TExclusivePolicy exclusive_policy = 7;
        }
    }
    // Transient disk volumes to allocate for this pod upon assignment.
    repeated TDiskVolumeRequest disk_volume_requests = 13
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TDiskVolumeClaim
    {
        // Altogether, TDiskVolumeRequest.id and TDiskVolumeClaim.name are pod-wise unique
        // and enable addressing volumes (both transient and persistent) within a pod.
        required string name = 1;

        // These labels get propagated to /pod/status/disk_volume_mounts/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 2;

        // Persistent volume claim whose associated volume must be mounted into the pod.
        required string claim_id = 3;
    }
    // Persistent disk volumes (indirectly represented by claims) to mount into this pod upon assignment.
    repeated TDiskVolumeClaim disk_volume_claims = 25
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TGpuRequest
    {
        // Pod-wise unique id.
        required string id = 1;

        // GPU model.
        required string model = 2;

        // In bytes.
        optional uint64 min_memory = 3;

        // In bytes.
        optional uint64 max_memory = 4;
    }
    // GPUs to allocate for this pod upon assignment.
    repeated TGpuRequest gpu_requests = 23
    [(NYP.NClient.NApi.NProto.etc) = true];

    // If false then YP will not be scheduling this pod.
    optional bool enable_scheduling = 7;

    // If given, controls which nodes are eligible for this pod.
    // Filter is a query language predicate; it can only refer to node labels, not other attributes.
    optional string node_filter = 8
    [(NYP.NClient.NApi.NProto.etc) = true];

    message THostDevice
    {
        // E.g. /dev/kvm
        required string path = 1;

        // E.g. "r", "rw"
        required string mode = 2;
    }
    // Host devices to configure.
    // https://wiki.yandex-team.ru/porto/propertiesanddata/#resursy
    repeated THostDevice host_devices = 10
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TSysctlProperty
    {
        required string name = 1;
        required string value = 2;
    }
    // Sysctl properties to configure.
    repeated TSysctlProperty sysctl_properties = 11
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TVirtualServiceOptions
    {
        optional uint32 ip4_mtu = 2;
        optional uint32 ip6_mtu = 3;
        optional string decapsulator_anycast_address = 4;
    }
    optional TVirtualServiceOptions virtual_service_options = 12
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Determines the kind of "hostname" Porto property: either
    // "persistent" or "transient" pod FQDN can be used.
    optional EPodHostNameKind host_name_kind = 15
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TSecret
    {
        required string secret_id = 1;
        required string secret_version = 2;
        required string delegation_token = 3;
    }

    // Defines secrets to be delivered to the pod.
    map<string, TSecret> secrets = 16
    [(NYT.NYson.NProto.yson_map) = true];

    // If given, overrides the podset's account.
    optional string account_id = 17;

    message TDynamicAttributes
    {
        // COMPAT(babenko): all labels are now passed by default
        reserved "labels"; reserved 1;

        // List of pod annotation keys to be delivered to the pod.
        repeated string annotations = 2;
    }

    // Provides means to deliver certain parts of pod's metadata to the node.
    optional TDynamicAttributes dynamic_attributes = 18;

    // Dynamic resources for the pod.
    repeated TPodDynamicResourceSpec dynamic_resources = 19;

    message TPodAgentResourceCache
    {
        optional NInfra.NPodAgent.API.TPodAgentResourceCacheSpec spec = 1;
    }

    // Resource cache for the pod
    optional TPodAgentResourceCache resource_cache = 20;

    // Defines the behavior policy when OOM occurs on one of the containers.
    // "oom_is_fatal: false" will be set if the OOMP_KILL_PROCESS parameter is passed.
    // "oom_is_fatal: true" will be set if the OOMP_REBUILD_POD parameter is passed.
    // Nothing will be set for "oom_is_fatal" property otherwise.
    optional EPodOutOfMemoryPolicy out_of_memory_policy = 21
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Host infrastructure settings.
    // Available on host via node agent REST interface.
    optional THostInfraInfo host_infra = 22
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Host capability names as they will be forwarded to node agent.
    // http://man7.org/linux/man-pages/man7/capabilities.7.html
    repeated string capabilities = 24
    [(NYP.NClient.NApi.NProto.etc) = true];
}

enum EEvictionState
{
    ES_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ES_REQUESTED = 100
    [(NYT.NYson.NProto.enum_value_name) = "requested"];

    ES_ACKNOWLEDGED = 200
    [(NYT.NYson.NProto.enum_value_name) = "acknowledged"];
}

enum EEvictionReason
{
    ER_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ER_HFSM = 100
    [(NYT.NYson.NProto.enum_value_name) = "hfsm"];

    ER_SCHEDULER = 200
    [(NYT.NYson.NProto.enum_value_name) = "scheduler"];

    ER_CLIENT = 300
    [(NYT.NYson.NProto.enum_value_name) = "client"];
}

message TPodDynamicResourceStatus
{
    // Resource identifier.
    optional string id = 1;

    // Current resource revision in pod.
    optional uint64 revision = 2;

    // Short label describing deploy group.
    optional string mark = 6;

    // Resource is currently active.
    optional TCondition ready = 3;

    // Resource is currently being deployed.
    optional TCondition in_progress = 4;

    // Resource deploy failed with error.
    optional TCondition error = 5;
}

message TPodStatus
{
    // Node where this pod currently belongs to.
    optional string node_id = 1;

    message TAgent
    {
        option (NYP.NClient.NApi.NProto.etc_type_name) = "TPodAgentStatusEtc";

        // ISS pod state.
        optional EPodCurrentState state = 1;

        // Raw ISS payload received from agent.
        // COMPAT(babenko): will be deprecated after switching to pod agent.
        optional bytes iss_payload = 3 [deprecated = true];

        // Structured ISS status.
        // COMPAT(babenko): will be deprecated after switching to pod agent.
        optional NYP.NClient.NApi.NClusterApiProto.HostCurrentState iss = 4;

        message TPodAgentPayload
        {
            optional NInfra.NPodAgent.API.TPodAgentStatus status = 1;
        }

        // Pod agent status.
        // COMPAT(babenko): Either this or iss_payload/iss should be present.
        optional TPodAgentPayload pod_agent_payload = 5;

        // Error in pod execution passed from agent via heartbeat.
        optional NYT.NProto.TError execution_error = 6
        [(NYP.NClient.NApi.NProto.etc) = true];

        // Error occurred while installing this pod to the node.
        optional NYT.NProto.TError install_error = 9
        [(NYP.NClient.NApi.NProto.etc) = true];

        // Contains the spec timestamps for which install_error was observed.
        optional uint64 failed_install_attempt_spec_timestamp = 10
        [(NYP.NClient.NApi.NProto.etc) = true];

        // Errors in pod spec validation passed from agent via heartbeat.
        repeated string validation_failures = 8
        [(NYP.NClient.NApi.NProto.etc) = true];

        // The instant the last heartbeat from agent containing the status of this pod was received.
        optional uint64 last_heartbeat_time = 7
        [(NYP.NClient.NApi.NProto.etc) = true];

        // Pod spec timestamp currently considered as a target by the agent.
        optional uint64 current_spec_timestamp = 11
        [(NYP.NClient.NApi.NProto.etc) = true];

        // Describes pod spec currently considered as a target by the agent.
        // Indicates whether the spec is completely applied.
        optional TCondition current_spec_applied = 12
        [(NYP.NClient.NApi.NProto.etc) = true];
    }
    optional TAgent agent = 2;

    message TResourceAllocation
    {
        optional string resource_id = 1;
    }
    repeated TResourceAllocation scheduled_resource_allocations = 4
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TIP6AddressAllocation
    {
        // IP6 address assigned by YP, in textual form.
        optional string address = 1;

        // Copied from /pod/spec/ip6_addresses/*/vlan_id.
        optional string vlan_id = 2;

        // Copied from /pod/spec/ip6_subnet_requests/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;

        // Persistent DNS name assigned to this address (if any) of the form:
        // [<dns_prefix>.]<pod-id>.<suffix>
        // This FQDN never changes.
        optional string persistent_fqdn = 5;

        // Transient DNS name assigned to this address (if any) of the form:
        // [<dns_prefix>.]<node-short-name>-<generation-number>.<pod-id>.<suffix>
        // This FQDN changes each time pod gets reassigned to another node.
        optional string transient_fqdn = 6;

        message TInternetAddress
        {
            required string id = 1;
            required string ip4_address = 2;
        }

        // Internet address assigned to this allocation.
        optional TInternetAddress internet_address = 7;

        message TVirtualService
        {
            // IP6 address, in textual form.
            repeated string ip6_addresses = 1;
            // IP4 address, in textual form.
            repeated string ip4_addresses = 2;
        }

        // Virtual services assigned to this allocation.
        repeated TVirtualService virtual_services = 8;
    }
    repeated TIP6AddressAllocation ip6_address_allocations = 5
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TIP6SubnetAllocation
    {
        // IP6 /112-subnet assigned by YP, in textual form.
        optional string subnet = 1;

        // Copied from /pod/spec/ip6_addresses/*/vlan_id.
        optional string vlan_id = 2;

        // Copied from /node/spec/ip6_address_requests/*/labels
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;
    }
    repeated TIP6SubnetAllocation ip6_subnet_allocations = 6
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TDiskVolumeAllocation
    {
        // Copied from /pod/spec/disk_volume_requests/*/id.
        // TODO(babenko): rename to "name"
        optional string id = 1;

        // Copied from /pod/spec/disk_volume_requests/*/labels.
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 3;

        // Total volume capacity in bytes.
        optional uint64 capacity = 4;

        // Id of disk resource where this volume will reside.
        optional string resource_id = 5;

        // Globally-unique volume id.
        // This is generated each time a "new" volume is assigned to the pod or an "old" volume is reallocated.
        // "New" volumes are recognized based on /pod/spec/disk_volume_allocations/*/id.
        optional string volume_id = 6;

        // Copied from /resource/spec/disk/device.
        optional string device = 7;

        // Guaranteed volume read bandwidth in bytes per second.
        optional uint64 read_bandwidth_guarantee = 8;

        // Volume read bandwidth limit in bytes per second.
        optional uint64 read_bandwidth_limit = 9;

        // Guaranteed volume write bandwidth in bytes per second.
        optional uint64 write_bandwidth_guarantee = 10;

        // Volume write bandwidth limit in bytes per second.
        optional uint64 write_bandwidth_limit = 11;

        // Guaranteed volume read operation rate in operations per second.
        optional uint64 read_operation_rate_guarantee = 12;

        // Volume read operation rate limit in operations per second.
        optional uint64 read_operation_rate_limit = 13;

        // Guaranteed volume write operation rate in operations per second.
        optional uint64 write_operation_rate_guarantee = 14;

        // Volume write operation rate limit in operations per second.
        optional uint64 write_operation_rate_limit = 15;
    }
    repeated TDiskVolumeAllocation disk_volume_allocations = 14
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TDiskVolumeMount
    {
        // Copied from /pod/spec/disk_volume_claims/*/name.
        optional string name = 1;

        // Copied from /pod/spec/disk_volume_claims/*/labels.
        optional NYT.NYTree.NProto.TAttributeDictionary labels = 2;

        // Id of persistent volume satisfying the claim.
        optional string volume_id = 3;
    }
    repeated TDiskVolumeMount disk_volume_mounts = 19
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TGpuAllocation
    {
        // Globally unique allocation identifier, generated on master.
        optional string id = 1;

        // Copied from /pod/spec/gpu_requests/*/id
        optional string request_id = 2;

        // Corresponding GPU resource id.
        optional string resource_id = 3;

        // Copied from /resource/spec/gpu/uuid
        optional string device_uuid = 4;
    }
    repeated TGpuAllocation gpu_allocations = 16
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TDns
    {
        // Persistent FQDN of the form:
        // <pod-id>.<suffix>
        // This FQDN never changes.
        optional string persistent_fqdn = 7;

        // Transient FQDN of the form:
        // <node-short-name>-<generation-number>.<pod-id>.<suffix>
        // This FQDN changes each time pod gets reassigned to another node.
        optional string transient_fqdn = 8;
    }
    optional TDns dns = 7
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TEviction
    {
        optional EEvictionState state = 1;
        optional EEvictionReason reason = 2;
        optional uint64 last_updated = 3;
        optional string message = 4;
    }
    optional TEviction eviction = 8
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TMaintenance
    {
        optional EPodMaintenanceState state = 1;
        optional uint64 last_updated = 2;
        optional string message = 3;
        optional TMaintenanceInfo info = 4;
    }
    optional TMaintenance maintenance = 17
    [(NYP.NClient.NApi.NProto.etc) = true];

    // Node alerts which are periodically fetched from the /node/status/alerts.
    // Empty if pod is not assigned to a node.
    repeated TNodeAlert node_alerts = 18
    [(NYP.NClient.NApi.NProto.etc) = true];

    message TScheduling
    {
        option (NYP.NClient.NApi.NProto.etc_type_name) = "TPodStatusSchedulingEtc";

        optional ESchedulingState state = 1
        [(NYP.NClient.NApi.NProto.etc) = true];

        optional string node_id = 2;

        optional uint64 last_updated = 3
        [(NYP.NClient.NApi.NProto.etc) = true];

        optional string message = 4
        [(NYP.NClient.NApi.NProto.etc) = true];

        optional NYT.NProto.TError error = 5
        [(NYP.NClient.NApi.NProto.etc) = true];
    }
    optional TScheduling scheduling = 9;

    // Increased each time the pod is being assigned to another node.
    optional uint64 generation_number = 10;

    // Timestamp of the last spec update.
    optional uint64 master_spec_timestamp = 11;

    // Timestamp of the last known spec reported by the agent.
    optional uint64 agent_spec_timestamp = 12;

    // Materialized view of dynamic attributes to be pushed to agent.
    optional NYP.NClient.NApi.NProto.TDynamicAttributes pod_dynamic_attributes = 13;

    // List of dynamic resources currently present in pod.
    repeated TPodDynamicResourceStatus dynamic_resources = 15;
}

message TPodControl
{
    message TAcknowledgeEviction
    {
        // Comment for the acknowledgement.
        optional string message = 1;
    }

    message TRequestEviction
    {
        // Comment for the request.
        optional string message = 1;

        // If true, eviction request fails with an error for the existent
        // and empty pod disruption budget.
        // If false, eviction can be successfully requested even for the existent
        // and empty pod disruption budget.
        optional bool validate_disruption_budget = 2 [default = true];

        // Reason of the request.
        optional EEvictionReason reason = 3;
    }

    message TAbortEviction
    {
        // Comment for the abort.
        optional string message = 1;
    }

    message TEvict
    {
        // Comment for the request.
        optional string message = 1;

        // See TRequestEviction.
        optional bool validate_disruption_budget = 2 [default = true];
    }

    message TTouchMasterSpecTimestamp
    {
        // Comment for the touch.
        optional string message = 1;
    }

    message TReallocateResources
    {
        // Comment for the reallocation.
        optional string message = 1;
    }

    message TAcknowledgeMaintenance
    {
        // Comment for the acknowledgement.
        optional string message = 1;
    }

    message TRenounceMaintenance
    {
        // Comment for the renouncement.
        optional string message = 1;
    }

    message TAddSchedulingHint
    {
        optional string node_id = 1;

        // See TPodSpec_TSchedulingHint.
        optional bool strong = 2;
    }

    message TRemoveSchedulingHint
    {
        // Uuid of hint in /spec/scheduling/hints to remove.
        optional string uuid = 1;
    }

    // Acknowledges eviction of the pod.
    // Pod must have /status/eviction/state == "requested" prior to this call and
    // the latter changes it to "acknowledged".
    optional TAcknowledgeEviction acknowledge_eviction = 1;

    // Requests eviction of the pod.
    // Pod must have /status/eviction/state == "none" prior to this call and
    // the latter changes it to "requested".
    // Successful request decrements pod disruption budget if any.
    optional TRequestEviction request_eviction = 2;

    // Aborts eviction of the pod.
    // Pod must have /status/eviction/state == "requested" prior to this call and
    // the latter changes it to "none".
    optional TAbortEviction abort_eviction = 3;

    // Requests and acknowledges eviction of the pod.
    optional TEvict evict = 8;

    // Updates master spec timestamp of the pod.
    optional TTouchMasterSpecTimestamp touch_master_spec_timestamp = 4;

    // Reallocates resources of the pod.
    // The method just schedules reallocation;
    // actual reallocation is deferred to the transaction commit.
    optional TReallocateResources reallocate_resources = 5;

    // Acknowledges maintenance of the pod.
    optional TAcknowledgeMaintenance acknowledge_maintenance = 6;

    // Renounces previously acknowledged maintenance of the pod.
    optional TRenounceMaintenance renounce_maintenance = 7;

    // Adds scheduling hint.
    optional TAddSchedulingHint add_scheduling_hint = 9;

    // Removes scheduling hint.
    optional TRemoveSchedulingHint remove_scheduling_hint = 10;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "PodSet"
    snake_case_name: "pod_set"
    type_value: 2
};

message TPodSetSpec
{
    // Limits placing pods of this pod set to the same topology zone (e.g. node, rack, DC).
    repeated TAntiaffinityConstraint antiaffinity_constraints = 1;

    // Specifies a node segment where all pods of this pod set must be scheduled to.
    optional string node_segment_id = 2;

    // Account that must be charged for this podset.
    optional string account_id = 3;

    // Pod disruption budget that limits this podset disruptions.
    // Missing value corresponds to the zero budget, i.e. without disruptions at all.
    optional string pod_disruption_budget_id = 4;

    // If given, controls which nodes are eligible for pods of this pod set.
    // This filter is only active for a pod of this pod set if this pod's own node_filter is empty.
    // Filter is a query language predicate; it can only refer to node labels, not other attributes.
    optional string node_filter = 5;

    message TViolateNodeSegmentConstraints
    {
        // If true then pods of this pod set can violate pod vcpu guarantee to limit constraint.
        optional bool vcpu_guarantee_to_limit_ratio = 1;
    }

    // Permissions to violate constraints applied to all pods of the pod set.
    optional TViolateNodeSegmentConstraints violate_node_segment_constraints = 6
    [(NYP.NClient.NApi.NProto.etc) = true];
}

message TPodSetStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Endpoint"
    snake_case_name: "endpoint"
    type_value: 5
};

message TEndpointMetaBase
{
    optional string endpoint_set_id = 4;
}

message TEndpointSpec
{
    optional string protocol = 1;
    optional string fqdn = 2;
    optional string ip4_address = 3;
    optional string ip6_address = 4;
    optional int32 port = 5;
}

message TEndpointStatus
{
    /* True, if pod relating to this endpoint is "ready".
     * Conditions when pod is considered as "ready": @see TEndpointSetSpec.pod_filter comments.
     */
    optional bool ready = 1;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "EndpointSet"
    snake_case_name: "endpoint_set"
    type_value: 6
};

message TEndpointSetSpec
{
    /* If given, for each "ready" pod matching this filter, an endpoint will be created.
     * Pod considers as "ready" (has endpoint) when all described below conditions are true:
     *     1. * For pods with Pod Agent: pod's state is ACTIVE.
              * For other pods: pod's state is ACTIVE or pod's target state is ACTIVE.
     *     2. Pod has backbone vlan in status.ip6_address_allocations.
     */
    optional string pod_filter = 1;

    // If given, this value will be propagated to /endpoint/spec/protocol of each created endpoint.
    optional string protocol = 2;

    // If given, this value will be propagated to /endpoint/spec/port of each created endpoint.
    optional int32 port = 3;

    /* If given, guarantees that endpoints_count >= ceil(liveness_limit_ratio * pods_count).
     * Where endpoints_count - endpoints count within endpoint set, pods_count - pod count within endpoint set.
     *
     * Will start working after YP-1502.
     *
     * If "ready" pods count >= ceil(liveness_limit_ratio * pods_count) - liveness_limit_ratio has no affect.
     *
     * In case when endpoints count is less than ceil(liveness_limit_ratio * pods_count),
     * enpoints will be created one by one (in unspecified order, even for not ready pods)
     * until number of endpoints reaches ceil(liveness_limit_ratio * pods_count).
     *
     * In case when endpoints count is greater than ceil(liveness_limit_ratio * pods_count),
     * endpoints, pointing to "unready" pods, will be deleted one by one (in unspecified order)
     * until number of endpoints reaches ceil(liveness_limit_ratio * pods_count).
     */
    optional double liveness_limit_ratio = 4 [default = 0.0];
}

message TEndpointSetStatus
{
    // Timestamp of the last change of set of endpoints contained in the endpoint_set
    // or change of meta, spec or labels of any endpoint in endpoint_set.
    optional uint64 last_endpoints_update_timestamp = 1;

    message TController
    {
        // Errors' codes are unused, they set only because it is required proto field.
        optional NYT.NProto.TError error = 1;
    }

    // For service controller's report.
    optional TController controller = 2 [(NYP.NClient.NApi.NProto.etc) = true];
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "NetworkProject"
    snake_case_name: "network_project"
    type_value: 4
};

message TNetworkProjectSpec
{
    // "Project id" part of IPv6 addresses.
    required uint32 project_id = 1;
}

message TNetworkProjectStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "NodeSegment"
    snake_case_name: "node_segment"
    type_value: 7
};

message TNodeSegmentSpec
{
    // Describes nodes belonging to this segment.
    required string node_filter = 1;

    // If enable_unsafe_porto is false, all pods in this segment must be safe.
    optional bool enable_unsafe_porto = 2;

    message TPodConstraints
    {
        message TVcpuGuaranteeToLimitRatioConstraint
        {
            optional double multiplier = 1;
            optional uint64 additive = 2;
        }

        // Vcpu guarantee to limit ratio (vcpu_limit <= multiplier * vcpu_guarantee + additive).
        optional TVcpuGuaranteeToLimitRatioConstraint vcpu_guarantee_to_limit_ratio = 1;
    }

    // Constraints that will be applied to all pods in this node segment.
    optional TPodConstraints pod_constraints = 3;
}

message TNodeSegmentStatus
{
    // Aggregates for all nodes belonging to this segment, regardless of their HFSM state.
    optional TPerSegmentResourceTotals total_resources = 1;
    // Aggregates for all nodes belonging to this segment and having "up" HFSM state.
    optional TPerSegmentResourceTotals schedulable_resources = 2;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "VirtualService"
    snake_case_name: "virtual_service"
    type_value: 8
};

message TVirtualServiceSpec
{
    // IP6 address, in textual form.
    repeated string ip6_addresses = 1;
    // IP4 address, in textual form.
    repeated string ip4_addresses = 2;
}

message TVirtualServiceStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "User"
    snake_case_name: "user"
    type_value: 9
};

message TUserSpec
{
    // If true, user is forbidden from accessing the cluster.
    optional bool banned = 1;
}

message TUserStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Group"
    snake_case_name: "group"
    type_value: 10
};

message TGroupSpec
{
    // List of subjects (users and groups) that are members of this group.
    repeated string members = 1;
}

message TGroupStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "InternetAddress"
    snake_case_name: "internet_address"
    type_value: 11
};

message TInternetAddressSpec
{
    required string ip4_address = 1;
    required string network_module_id = 2;
}

message TInternetAddressStatus
{
    optional string pod_id = 1;
}

message TInternetAddressMetaBase
{
    optional string ip4_address_pool_id = 4;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "IP4AddressPool"
    snake_case_name: "ip4_address_pool"
    human_readable_name: "IP4 address pool"
    type_value: 21
};

message TIP4AddressPoolSpec
{ }

message TIP4AddressPoolStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "DnsRecordSet"
    snake_case_name: "dns_record_set"
    human_readable_name: "DNS record set"
    type_value: 14
};

message TDnsRecordSetSpec
{
    message TResourceRecord
    {
        optional uint64 ttl = 1;
        optional string class = 2;

        enum EType
        {
            A = 1
            [(NYT.NYson.NProto.enum_value_name) = "A"];

            CNAME = 5
            [(NYT.NYson.NProto.enum_value_name) = "CNAME"];

            PTR = 12
            [(NYT.NYson.NProto.enum_value_name) = "PTR"];

            TXT = 16
            [(NYT.NYson.NProto.enum_value_name) = "TXT"];

            AAAA = 28
            [(NYT.NYson.NProto.enum_value_name) = "AAAA"];

            SRV = 33
            [(NYT.NYson.NProto.enum_value_name) = "SRV"];
        }
        optional EType type = 3;
        optional string data = 4;
    }

    repeated TResourceRecord records = 1;
}

message TDnsRecordSetStatus
{ }

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "Account"
    snake_case_name: "account"
    type_value: 12
};

message TAccountSpec
{
    optional string parent_id = 1;
    optional TResourceTotals resource_limits = 2
    [(NYP.NClient.NApi.NProto.etc) = true];
}

message TAccountStatus
{
    optional TResourceTotals resource_usage = 1;
    optional TResourceTotals immediate_resource_usage = 2;
}

////////////////////////////////////////////////////////////////////////////////

option (NYP.NClient.NApi.NProto.object_type) = {
    camel_case_name: "PodDisruptionBudget"
    snake_case_name: "pod_disruption_budget"
    type_value: 20
};

message TPodDisruptionBudgetSpec
{
    // Limit on the maximum number of unavailable pods.
    optional int32 max_pods_unavailable = 1;

    // Limit on the maximum number of pod disruptions between consecutive synchronizations.
    optional int32 max_pod_disruptions_between_syncs = 2;
}

message TPodDisruptionBudgetStatus
{
    // Number of currently allowed pod disruptions.
    optional int32 allowed_pod_disruptions = 1;

    // Time of the last status update.
    optional google.protobuf.Timestamp last_update_time = 2;

    // Comment for the last status update.
    optional string last_update_message = 3;
}

////////////////////////////////////////////////////////////////////////////////
