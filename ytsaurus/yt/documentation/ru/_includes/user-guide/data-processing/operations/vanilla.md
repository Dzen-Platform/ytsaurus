# Vanilla

Vanilla операция отличается от других операций, так как у неё отсутствуют входные таблицы, но могут быть указаны выходные таблицы, таблица для сохранения данных из стандартного потока ошибок (stderr таблицы) и таблицы с coredump. Операцию Vanilla можно использовать в ситуации, когда требуется запустить распределённый процесс, описав несколько видов джобов и указав желаемое количество джобов каждого вида. [Планировщик {{product-name}}](../../../../user-guide/data-processing/scheduler/scheduler-and-pools.md) берёт на себя функцию поддержания жизнедеятельности данного распределённого процесса, добиваясь того, чтобы нужное количество джобов каждого вида было запланировано и успешно завершилось, как и в любой другой операции {{product-name}}. 

Получение входных данных джобом Vanilla операции выполняется с помощью опции `file_paths` в спецификации пользовательского скрипта или путём чтения данных джобом напрямую по сети.
{% note warning "Внимание" %}

При загрузке данных в джоб напрямую по сети предварительно обсудите предполагаемый способ использования с администратором системы {{product-name}} и с сервисом, откуда вы планируете забирать данные, чтобы не создать слишком большую нагрузку на сеть и сервис-источник данных.

{% endnote %}

{% note info "Примечание" %}

Вся координация и распределение работы между запущенными джобами, а также поддержание консистентности в случае перезапусков джобов ложится на пользователя.

{% endnote %}

Выходные данные джоб может как писать по сети (в таком случае следует также оценить нагрузку на сеть), так и выводить в таблицы. Для каждого вида джобов при этом будут свои выходные таблицы.

Основной частью описания операции Vanilla является перечисление всевозможных **тасков**. В экосистеме {{product-name}} таск  — это группа джобов одного вида, запущенных в рамках операции. Описание таска представляет из себя описание пользовательского скрипта, указание количества джобов, которые должны запуститься в рамках этого таска и, возможно, описание выходных таблиц из данного таска.

Описание таска в операции Vanilla очень похоже на описание пользовательского скрипта, но стоит разделять эти понятия, потому что они отвечают разным сущностям в [Планировщике](../../../../user-guide/data-processing/scheduler/scheduler-and-pools.md).

Описание пользовательского скрипта — это исключительно указание того, как нужно запускать пользовательский код на машине. В нём нет информации о том, какой объём данных необходимо передать каждому джобу. Например: опция `data_weight_per_map_job` в операции MapReduce не занесена в спецификацию пользовательского скрипта, потому что она не имеет отношения к тому, как нужно запускать пользовательский скрипт map стадии, который может отсутствовать.

Описание таска — это спецификация того, как планировщик должен управлять джобами данного вида. Данное понятие встречается только в операции Vanilla, и в нём оно практически не отличается от описания пользовательского скрипта.

Общие параметры для всех типов операций описаны в разделе [Настройки операций](../../../../user-guide/data-processing/operations/operations-options.md).

У операции Vanilla имеются следующие дополнительные параметры:

* `tasks` — словарь, описывающий таски операции. Каждому таску должна соответствовать пара ключ-значение, где ключом является название таска, а значение — спецификация таска. В {{product-name}} предпочтителен lowercase_with_underscores стиль именования тасков, например `partition_map`. Название таска будет отображено в веб-интерфейсе на странице операции, а также будет доступно в виде ключей в yson-представлении прогресса операции, поэтому не стоит делать его слишком длинным. Спецификация таска состоит из тех же параметров, что и спецификация пользовательского скрипта, а также содержит дополнительные параметры:
  * `job_count` — количество джобов данного вида, которые должны запуститься в рамках конкретного таска. В случае когда опция `fail_on_job_restart`  в спецификации операции не установлена, таск будет считаться успешно завершённым, если ровно `job_count` джобов данного вида успешно завершилось (то есть, завершилось с кодом 0 и не было прервано по каким-то причинам);
  * `output_table_paths` — список выходных таблиц (возможно пустой). В случае, когда одна и та же таблица является выходной для разных тасков, во всех вхождениях на ней должны быть указаны одинаковые атрибуты на путях.

{% note info "Примечание" %}

С помощью опций `max_failed_job_count` и `fail_on_job_restart`, общих для всех операций, удобно контролировать перезапуски джобов.

{% endnote %}

## Пример спецификации

```yaml
{
  tasks = {
    master = {
      job_count = 1;
      command = "python run_master.py < duties.dat";
      file_paths = ["//tmp/run_master.py"; "<file_name=duties.dat>//tmp/duties_180124.dat"];
    };
    slave = {
      job_count = 100;
      command = "python run_slave.py";
      file_paths = ["//tmp/run_slave.py"];
    };
  };
  max_failed_job_count = 1;
  stderr_table_path = "//tmp/stderrs";
}
```

