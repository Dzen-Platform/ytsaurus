## Системные субъекты { #system_subjects }

В системе {{product-name}} присутствует набор субъектов, выполняющих системные функции. Таких субъектов нельзя удалить. К системным субъектам относятся:

1. Пользователи `guest`, `root`, `scheduler` и `job`;
2. Группы `everyone`, `users`, `superusers`.

## Атрибуты субъектов { #subject_attributes }

В таблице представлен список атрибутов, которые имеются у всех субъектов.

| **Атрибут**         | **Тип**         | **Описание**                                                 |
| ------------------- | --------------- | ------------------------------------------------------------ |
| `name`              | `string`        | Имя субъекта (непустая строка)                               |
| `member_of`         | `array<string>` | Список имен групп, которым непосредственно принадлежит данный субъект |
| `member_of_closure` | `array<string>` | Список имен групп, которым принадлежит субъект (прямо или косвенно) |
| `aliases`           | `array<string>` | Список имен, которые могут использоваться в ACL в качестве ссылки на данный субъект |

## Атрибуты пользователей { #user_attributes }

Помимо атрибутов, присущих всем субъектам, пользователи имеют атрибуты представленные в таблице.

| **Атрибут**                | **Тип**         | **Описание**                                                 | **Обязательный**    |
| -------------------------- | --------------- | ------------------------------------------------------------ | ------------------- |
| `banned`                   | `bool`          | Заблокирован ли пользователь                                 | Нет                 |
| `access_time`              | `DateTime`      | Время последнего запроса от пользователя.                    | Да                  |
| `access_counter`           | `integer`       | Общее число запросов, заданных пользователем.                | Да                  |
| `request_rate`             | `double`        | Количество запросов в секунду от пользователя.               | Да                  |
| `request_rate_limit`       | `double`        | Ограничение на количество запросов в секунду от пользователя. По умолчанию 100. | Да   |
| `request_queue_size_limit` | `double`        | Длина очереди запросов. По умолчанию 100.                    | Да                  |
| `usable_accounts`          | `array<string>` | Список аккаунтов, которые пользователю разрешено использовать. | Да                |

## Атрибуты групп { #group_attributes }

Помимо атрибутов, присущих всем субъектам, группы имеют атрибуты представленные в таблице.

| **Атрибут** | **Тип**         | **Описание**                                              |
| ----------- | --------------- | --------------------------------------------------------- |
| `members`   | `array<string>` | Список имен членов группы (пользователей и других групп). |

## Управление группами { #group_control }

{% note info "Примечание" %}

На больших кластерах управление группами напрямую доступно только администраторам {{product-name}}.

{% endnote %}

Чтобы создать новую группу, используется команда `create`. При создании не нужно указывать путь объекта, но требуется указать атрибут `name`.
```bash
yt create group --attributes '{name=my_group}'
```

Удаляются группы командой `remove`. При удалении группа автоматически удаляется из всех ACL, где она участвовала.
```bash
yt remove //sys/groups/my_group
```

## Авторизация { #authorization }

Модуль авторизации на мастер-сервере решает следующую задачу: разрешить ли пользователю `U` доступ типа `P` для объекта `O`? Вариантов ответа может быть два: разрешить или не разрешать. Разберем все три компонента (U, P и O) по-отдельности.

В качестве `U` может выступать любой пользователь системы. Отметим, что `U` не может быть группой, хотя членство в группах учитывается при принятии решения. Если `U` — это `root`, то запрос доступа автоматически удовлетворяется.

Тип доступа `P` иначе также называется **правом** (permission). Права, которые поддерживаются системой {{product-name}} представлены в таблице.

| Право        | Описание                                                     |
| ------------ | ------------------------------------------------------------ |
| `read`       | Обозначает чтение значения или получение информации об объекте либо его атрибутах. |
| `write`      | Обозначает изменение состояния объекта или его атрибутов.    |
| `use`        | Применяется к аккаунтам, пулам и бандлам и означает использование (то есть возможность вписать новые объекты в квоту данного аккаунта, запустить операции в пуле или переложить динамическую таблицу в бандл). |
| `administer` | Обозначает изменение дескриптора доступа объекта.            |
| `create`     | Применяется только к схемам и обозначает создание объектов данного типа. |
| `remove`     | Обозначает удаление объекта.                                 |
| `mount`      | Обозначает монтирование, размонтирование, перемонтирование и решардирование динамической таблицы. |
| `manage`     | Применяется только к операциям (не к узлам Кипариса) и обозначает управление состоянием этой операции или её джобов. |

Объект `O` означает произвольный объект системы: узел Кипариса, пользователя, группу, аккаунт, чанк, транзакцию и так далее.

Чтобы принять решение, система неявно строит **эффективный список управления доступом** (effective ACL) для объекта `O`. Эффективный список управления доступом — это список управления доступом узла и все, унаследованные от родителей. Любой **список управления доступом** (ACL) представляет собой список **записей управления доступом** (ACE). Порядок записей в этом списке не играет роли. Объект может наследовать свой ACL, за это отвечает атрибут `inherit_acl = %true`. При наследовании для каждой ACE определяется режим наследования (ключ `inheritance_mode` в записи `acl`). Последний может быть равен `object_only`, `object_and_descendants`, `descendants_only` и `immediate_descendants_only`.

Значение `object_only` означает, что данная запись влияет только на сам объект. При значении `object_and_descendants` — на объект и всех его потомков, включая непрямых. При значении `descendants_only` — только на потомков, включая непрямых. При значении `immediate_descendants_only` — только на прямых потомков (сыновей). Каждая запись имеет структуру представленную в таблице.

| **Атрибут**        | **Тип**             | **Описание**                                                 |
| ------------------ | ------------------- | ------------------------------------------------------------ |
| `action`           | `string`            | Либо `allow` (разрешающая запись), либо `deny` (запрещающая запись). |
| `subjects`         | `array<string>`     | Список имен субъектов, на которые распространяется запись.   |
| `permissions`      | `array<Permission>` | Список прав доступа, на которые распространяется действие, указанное в атрибуте `action`. |
| `inheritance_mode` | `InheritanceMode`   | Режим наследования данной ACE, по умолчанию `object_and_descendants`. |

Как только эффективный список построен, решение о предоставлении или непредоставлении доступа принимается по следующей схеме:

1. Если в списке есть хотя бы одна разрешающая запись для `U` и `P`, и нет ни одной запрещающей записи для `U` и `P`, то доступ выдается;
2. Иначе доступ запрещается.

«Запись для `U` и `P`» означает, что `P` упомянуто в списке `permissions` , а пользователь `U`], либо хотя бы одна группа, в которой он числится прямо или косвенно — в списке `subjects`. Из представленного описания в частности следует, что если эффективный список пуст, то доступ будет запрещен.

## Владелец объекта и пользователь owner { #owner}

При создании объекта пользователем `U`, он также становится владельцем данного объекта, что находит отражение в атрибуте `owner`.

{% note info "Примечание" %}

Изменить владельца может лишь суперпользователь (член группы `superusers`).

{% endnote %}

Также в системе есть специальный фиктивный пользователь `owner`. Им невозможно аутентифицироваться, однако на него можно ссылаться в ACL в качестве субъекта. При этом в момент проверки прав `owner` заменяется на фактического владельца объекта. Это позволяет, например, описать ограничение «в данном каталоге удалять узлы могут только те, кто их создал» таким ACE:`{action=allow; permissions=[remove]; subjects=[owner]; inheritance_mode = descendants_only}`, при этом важно не забыть отключить наследование прав, указав `inherit_acl = %false`.

## Управление операциями

Любая операция имеет связанный с ней ACL аналогично узлам Кипариса. Данный ACL можно получить из атрибута по пути `runtime_parameters/acl` операции.
Права доступа имеют следующую семантику:

- право `read` отвечает за чтение live preview выходных и промежуточных данных операции, а также «артефактов» её джобов: stderr, fail context, входных данных отдельных джобов;
- право `manage` отвечает управлению операцией, влияющему на её состояние, то есть действиям `Abort`, `Complete`, `Suspend` и `Resume`. Кнопки для них находятся в правом верхнем углу страницы операции в веб-интерфейсе. А также действиям с джобами: `Abort`, `Abandon` и `Send signal`. Кнопки для них находятся в выпадающем меню в правой части страницы `Jobs` в веб-интерфейсе {{product-name}};
- использование [Job Shell](../../../user-guide/problems/jobshell-and-slowjobs.md) требует одновременно прав `read` и `manage` , так как наличие доступа через консоль позволяет читать или произвольным образом менять состояние джоба.

Существует возможность указать ACL для операции при её запуске. Для этого в спецификации операции необходимо указать секцию `"acl"` следующего содержания:

```python
yt.run_map(..., spec={"acl": [{
 "action": "allow",
 "subjects": ["u1", "u2"],
 "permissions": ["read", "manage"],
}]})
```

Пользователь, запустивший операцию, и администраторы по умолчанию добавляются в результирующий ACL операции.

## Как правильно использовать ACL { #acl_usage}

Представленная выше схема управления доступом весьма общая и гибкая. При ее использовании важно стараться ставить роли на максимально высоком уровне с наследованием один раз, а не управлять доступом на уровне отдельных таблиц. Наследование ACL поощряет группировать данные с общими правилами доступа в каталоги.

В нормальном режиме следует иметь исключительно разрешающие записи. Запрещающие записи можно выставлять для быстрого решения проблемы, если оказалось, что доступ чрезмерно расширен, затем следует проводить ревизию ACL, и решать проблему, корректируя разрешающие записи.

Не рекомендуется упоминать в ACL конкретных пользователей. При выдаче доступа вместо отдельных пользователей рекомендуется использовать группы с однотипными потребностями.

Наследование ACL следует использовать везде, кроме мест, где характер доступа радикально меняется. Например, на корне Кипариса по умолчанию установлена запись, разрешающая всем пользователям (кроме `guest`) выполнять чтение. В тех местах Кипариса, где хранится чувствительная с точки зрения безопасности информация, например, списки токенов, доступ переопределяется с нуля.

## Проверка ACL { #check_acl}

Проверить наличие у пользователя определённого права на определённый узел Кипариса можно командой `check-permission`. Пример запуска:

```bash
yt check-permission yql write //tmp
{
  "action" = "allow";
  "object_id" = "1-3-411012f-1888ce1f";
  "object_name" = "node //tmp";
  "subject_id" = "c4-8aaa-41101f6-bec6113b";
  "subject_name" = "YTsaurus";
}
```

## Запрос доступа { #request_access }

Для получения доступа к существующему аккаунту или директории в {{product-name}} обратитесь к администратору системы.

