// Autogenerated, do not edit!

#pragma once

#include <yt/yt/client/table_client/record_descriptor.h>

#include <yt/yt/core/misc/singleton.h>

#include <initializer_list>

{% if h_verbatim %}
{{h_verbatim}}
{% endif %}

namespace {{namespace}} {

////////////////////////////////////////////////////////////////////////////////

{% for type in types %}
struct {{type.type_name}};
struct {{type.type_name}}Key;
struct {{type.type_name}}IdMapping;
class {{type.type_name}}Descriptor;

enum class E{{type.type_name[1:]}}Field
{
{%- for field in type.fields %}
    {{field.cpp_name}},
{%- endfor %}
};

struct {{type.type_name}}IdMapping
{
    explicit {{type.type_name}}IdMapping(const NYT::NTableClient::TNameTablePtr& nameTable);

{% for field in type.fields %}
    const std::optional<int> {{field.cpp_name}};
{%- endfor %}
};

class {{type.type_name}}Descriptor
    : public NYT::NTableClient::IRecordDescriptor
{
public:
    using TRecord = {{type.type_name}};
    using TKey = {{type.type_name}}Key;
    using TIdMapping = {{type.type_name}}IdMapping;
{% if type.descriptor_verbatim %}
{{type.descriptor_verbatim}}
{% endif %}

    static const {{type.type_name}}Descriptor* Get();

    const NTableClient::TTableSchemaPtr& GetSchema() const override;
    const NTableClient::TNameTablePtr& GetNameTable() const override;
    const {{type.type_name}}IdMapping& GetIdMapping() const;

private:
    const NTableClient::TTableSchemaPtr Schema_;
    const NTableClient::TNameTablePtr NameTable_;
    const {{type.type_name}}IdMapping IdMapping_;

    DECLARE_LEAKY_SINGLETON_FRIEND()

    {{type.type_name}}Descriptor();
};

struct {{type.type_name}}Key
{
    using TRecordDescriptor = {{type.type_name}}Descriptor;
{% if type.key_verbatim %}
{{type.key_verbatim}}
{% endif %}
{%- for field in type.fields if field.sort_order %}
    {{field.cpp_type}} {{field.cpp_name}}{};
{%- endfor %}

    NYT::NTableClient::TLegacyKey ToKey(const NYT::NTableClient::TRowBufferPtr& rowBuffer) const;
    static {{type.type_name}}Key FromKey(NYT::NTableClient::TLegacyKey key);
};

struct {{type.type_name}}
    : public {{type.type_name}}Key
{
{% if type.record_verbatim %}
{{type.record_verbatim}}
{% endif %}
{% for field in type.fields if not(field.sort_order)%}
    {{field.cpp_type}} {{field.cpp_name}}{};
{%- endfor %}

    NYT::NTableClient::TUnversionedRow ToUnversionedRow(
        const NYT::NTableClient::TRowBufferPtr& rowBuffer,
        const {{type.type_name}}IdMapping& idMapping = {{type.type_name}}Descriptor::Get()->GetIdMapping()) const;
    NYT::NTableClient::TUnversionedRow ToUnversionedRow(
        const NYT::NTableClient::TRowBufferPtr& rowBuffer,
        std::initializer_list<E{{type.type_name[1:]}}Field> fields,
        const {{type.type_name}}IdMapping& idMapping = {{type.type_name}}Descriptor::Get()->GetIdMapping()) const;
    static {{type.type_name}} FromUnversionedRow(
        NYT::NTableClient::TUnversionedRow row,
        const {{type.type_name}}IdMapping& idMapping = {{type.type_name}}Descriptor::Get()->GetIdMapping());
};

{% endfor %}
////////////////////////////////////////////////////////////////////////////////

} // namespace {{namespace}}
