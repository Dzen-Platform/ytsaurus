package NYT.NTableClient.NProto;

import "yt/client/table_chunk_format/proto/column_meta.proto";

////////////////////////////////////////////////////////////////////////////////

message TLogicalType
{
    message TStructField
    {
        optional string name = 1;
        optional TLogicalType type = 2;
    }

    message TStructLogicalType
    {
        repeated TStructField fields = 1;
    }

    message TTupleLogicalType
    {
        repeated TLogicalType elements = 1;
    }

    message TVariantTupleLogicalType
    {
        repeated TLogicalType elements = 1;
    }

    message TVariantStructLogicalType
    {
        repeated TStructField fields = 1;
    }

    message TDictLogicalType
    {
        optional TLogicalType key = 1;
        optional TLogicalType value = 2;
    }

    message TTaggedLogicalType
    {
        optional string tag = 1;
        optional TLogicalType element = 2;
    }

    oneof type {
        int32 simple = 1;
        TLogicalType optional = 2;
        TLogicalType list = 3;
        TStructLogicalType struct_ = 4;
        TTupleLogicalType tuple = 5;
        TVariantTupleLogicalType variant_tuple = 6;
        TVariantStructLogicalType variant_struct = 7;
        TDictLogicalType dict = 8;
        TTaggedLogicalType tagged = 9;
    }
}

message TColumnSchema
{
    required string name = 1;

    // `type', `simple_logical_type` `logical_type' describe type of the column.
    //
    // `type' contains value of enumeration NTableClient::EValueType and represents physical type.
    required int32 type = 2;

    // `simple_logical_type' contains value of enumeration NTableClient::ESimpleLogicalValueType.
    // It describes logical type and was used before introduction of complex logical types.
    // We might miss it for very old chunks.
    optional int32 simple_logical_type = 8;
    optional bool required = 9 [default = false];

    // `logical_type` contains description of logical type that might be complex
    optional TLogicalType logical_type = 10;

    optional string lock = 3;
    optional string expression = 4;
    optional string aggregate = 5;
    optional int32 sort_order = 6;
    optional string group = 7;
    // Next tag: 11
}

message TTableSchemaExt
{
    repeated TColumnSchema columns = 1;
    optional bool strict = 2 [default = true];
    optional bool unique_keys = 3 [default = false];
    optional int32 schema_modification = 4 [default = 0]; // ETableSchemaModification
}

message TSchemaDictionary
{
    repeated TColumnSchema columns = 1;

    message TTableSchemaInternal
    {
        repeated int32 columns = 1;
        optional bool strict = 2 [default = true];
        optional bool unique_keys = 3 [default = false];
    }

    repeated TTableSchemaInternal tables = 2;
}

message TColumnNameFilter
{
    repeated string admitted_names = 1;
}

message TColumnFilterDictionary
{
    repeated TColumnNameFilter column_filters = 1;
}

message TNameTableExt
{
    repeated string names = 1;
}

message TBlockMeta
{
    required int32 row_count = 1;
    required int64 uncompressed_size = 2;
    required int64 chunk_row_count = 3;

    required int32 block_index = 7;

    optional int32 partition_index = 8 [default = -1];
    optional bytes last_key = 9;

    extensions 100 to max;
}

message TSimpleVersionedBlockMeta
{
    extend TBlockMeta
    {
        optional TSimpleVersionedBlockMeta block_meta_ext = 100;
    }

    required int32 value_count = 1;
    required int32 timestamp_count = 2;
}

message TBlockMetaExt
{
    repeated TBlockMeta blocks = 1;
}

// Chunk meta extension.
message TBoundaryKeysExt
{
    required bytes min = 1;
    required bytes max = 2;
}

message TSamplesExt
{
    repeated bytes entries = 1;
    repeated int32 weights = 2;
}

message TPartitionsExt
{
    repeated int64 row_counts = 1;
    repeated int64 uncompressed_data_sizes = 2;
}

message TKeyColumnsExt
{
    repeated string names = 1;
}

message TColumnMetaExt
{
    repeated NTableChunkFormat.NProto.TColumnMeta columns = 1;
}

message TColumnarStatisticsExt
{
    repeated int64 data_weights = 1;
    // Total weight of all write and delete timestamps.
    optional int64 timestamp_weight = 2;
}

message TColumnRenameDescriptor
{
    required string original_name = 1;
    required string new_name = 2;
}

message THeavyColumnStatisticsExt
{
    required int32 version = 1;

    optional uint32 salt = 2;

    optional int64 data_weight_unit = 3;

    repeated uint32 column_name_hashes = 4;

    optional bytes column_data_weights = 5;
}

////////////////////////////////////////////////////////////////////////////////
