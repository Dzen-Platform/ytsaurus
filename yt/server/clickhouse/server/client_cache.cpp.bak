#include "client_cache.h"

#include "config.h"

#include <yt/ytlib/api/native_client.h>
#include <yt/ytlib/api/native_connection.h>

#include <yt/core/misc/expiring_cache.h>

#include <util/generic/hash.h>

////////////////////////////////////////////////////////////////////////////////

template <>
struct THash<NYT::NApi::TClientOptions>
{
    size_t operator ()(const NYT::NApi::TClientOptions& options) const
    {
        return options.User.hash();
    }
};

template <>
struct TEqualTo<NYT::NApi::TClientOptions>
{
    bool operator ()(const NYT::NApi::TClientOptions& l,
                     const NYT::NApi::TClientOptions& r) const
    {
        return l.User == r.User;
    }
};

namespace NYT {
namespace NClickHouse {

using namespace NYT::NApi;

////////////////////////////////////////////////////////////////////////////////

class TNativeClientCache
    : public INativeClientCache
    , public TExpiringCache<TClientOptions, INativeClientPtr>
{
private:
    const INativeConnectionPtr Connection;

public:
    TNativeClientCache(TNativeClientCacheConfigPtr config,
                       INativeConnectionPtr connection)
        : TExpiringCache(std::move(config))
        , Connection(std::move(connection))
    {}

    INativeClientPtr CreateNativeClient(const TClientOptions& options) override
    {
        return Get(options).Get().ValueOrThrow();
    }

private:
    TFuture<INativeClientPtr> DoGet(const TClientOptions& options) override
    {
        return MakeFuture(Connection->CreateNativeClient(options));
    }
};

////////////////////////////////////////////////////////////////////////////////

INativeClientCachePtr CreateNativeClientCache(
    TNativeClientCacheConfigPtr config,
    INativeConnectionPtr connection)
{
    return New<TNativeClientCache>(
        std::move(config),
        std::move(connection));
}

}   // namespace NClickHouse
}   // namespace NYT
