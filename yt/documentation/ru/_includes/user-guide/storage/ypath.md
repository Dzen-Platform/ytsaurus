# YPATH

В данном разделе собрана информация про YPath — язык, описывающий пути к объектам в системе {{product-name}}.

YPath представляет собой язык описания путей, которые идентифицируют объекты в системе {{product-name}}. Язык позволяет обращаться к узлам и указывать аннотации, которые могут быть полезны при совершении операций над узлами, например, при записи в таблицу. При помощи аннотаций можно определить, будут ли новые данные дописаны в конце таблицы, или таблица будет полностью перезаписана. 

Например:

- `//home/user/table` — путь к таблице `table` в домашнем каталоге пользователя;
- `#0-25-3ec012f-406daf5c/@type` — путь к атрибуту `type` объекта с идентификатором `0-25-3ec012f-406daf5c`;
- `//home/user/table[#10:#20]` — строки с 10-ю по 19-ю включительно таблицы `table` в домашнем каталоге пользователя.

Существует несколько разновидностей YPath. В самом простом случае YPath представляет собой строку, кодирующую путь.

## Простой YPath { #simple_ypath }

### Лексика { #simple_ypath_lexis }

Строка, кодирующая простой YPath, разбивается на следующие **токены**:

1. **Специальные символы**: прямой слеш (`/`), «собака» (`@`), амперсанд (`&`), звездочка (`*`);
2. **Литералы**: максимальная непустая последовательность неспециальных символов. В литералах разрешен escaping вида `\<escape-sequence>`, где в качестве `<escape-sequence>` может выступать один из символов `\`, `/`, `@`, `&`, `*`, `[`, `{`, а также выражение вида `x<hex1><hex2>`, где `<hex1>` и `<hex2>` — шестнадцатеричные цифры.

### Синтаксис и семантика { #simple_ypath_syntax }

Структурно YPath имеет вид `<root-designator><relative-path>`. Здесь `<root-designator>` бывает двух видов:

1. **Корень Кипариса**: токен `/`.
   Пример: `//home/user`; здесь `<root-designator>` равен `/`, а `<relative-path>` равен `/home/user`;
2. **Объектный корень**: токен-литерал, кодирующий строку вида `#<id>`.
   Пример: `#1-2-3-4/@type`; здесь `<root-designator>` равен `#1-2-3-4`, а `<relative-path>` равен `/@type`.

Тем самым, `<root-designator>` определяет начальную точку отсчета, к которой применяется `<relative-path>`. Последний разбирается последовательно слева направо, в результате чего возникают шаги перемещения по дереву следующих видов:

- **Переход к потомку**: последовательность из токена `/` и литерала.
  Данный тип шагов применим к словарям и спискам. В случае словаря литерал должен содержать имя потомка. Пример: `/child` — переход к потомку с именем `child`.
  В случае списка литерал должен содержать целое число в десятичной системе счисления — номер потомка. Потомки в списке нумеруются с нуля. Разрешены также отрицательные номера, которые нумеруют потомков с конца списка. Примеры: `/1` — переход ко второму потомку в списке, `/-1` — переход к последнему потомку в списке;
- **Переход к атрибуту**: последовательность из токенов `/@` и литерала.
  Данный тип шагов применим в любой точке пути и означает переход к атрибуту с данными именем. Пример: `/@attr` — переход к атрибуту с именем `attr`.

{% note info "Примечание" %}

В YPath относительные пути начинаются со слешей. Тем самым, слеш служит не разделителем как в случае файловых систем, а полноправным членом команды перемещения по дереву метаинформации. В частности, для склейки двух YPath достаточно обычной конкатенации строк. 

{% endnote %}

###  Примеры { #simple_ypath_examples }

```json
% Корень Кипариса
/

% В корневой директории узел home, в ней — узел user.
//home/user

% Начальный элемент в списке //home/user/list 
//home/user/list/0

% Последний элемент в списке //home/user/list 
//home/user/list/-1

% Атрибут attr узла //home/user
//home/user/@attr

% Объект с идентификатором 1-2-a-b
#1-2-a-b

% Потомок child объекта с идентификатором 1-2-a-b
#1-2-a-b/child

% Атрибут attr объекта с идентификатором 1-2-a-b
#1-2-a-b/@attr
```

### Особенности поведения { #simple_ypath_behavior }

Помимо указанных выше правил действует ряд специальных соглашений. Большинство из них связано с тем, что YPath может идентифицировать не только уже существующие метаинформационные сущности, но и новые, создаваемые в момент выполнения команды, аргументом которой служит данный YPath.

- **Указание всех потомков**: в команде `remove_node` есть возможность удалить всех потомков словаря или списка, для этого следует использовать вместо имени токен `*`.
  Пример:

  ```json
  % Очистить домашний каталог пользователя
  yt remove //home/user/*
  ```

- **Указание всех атрибутов**: в командах чтения (`get_node`, `list_nodes`), а также изменения (`set_node`) есть возможность обратиться к коллекции всех атрибутов объекта, для чего в качестве пути надо использовать путь вида `/@`. При этом изменение через `set_node` распространяется лишь на пользовательские атрибуты.
   
  Примеры:
  
  ```json
  % Получить значения всех атрибутов домашнего каталога пользователя
  yt get //home/user/@

  % Получить имена всех атрибутов домашнего каталога пользователя
  yt list //home/user/@

  % Удалить все пользовательские атрибуты
  yt set //home/user/@ '{}'

  % Выставить один пользовательский атрибут, удалив все остальные имеющиеся
  yt set //home/user/@ '{attr=value}'
  
  % Выставить один пользовательский атрибут, не трогать остальные
  yt set //home/user/@attr value

  % Выставить вложенный пользовательский атрибут
  yt set //home/user/@attr/some/key value
  ```
  
- **Указание позиции вставки в список**: в командах, создающих новые узлы (например `set_node`) есть возможность указать положение создаваемого узла в списке относительно уже имеющихся. Для этого нужно вместо номера потомка использовать специальные строки `begin` (начало списка), `end` (конец списка), `before:<index>` (позиция перед потомком с номером `<index>`), а также `after:<index>` (позиция после потомка с номером `<index>`). Примеры:

  ```json
  % Добавить элемент "value" в конец списка //home/user/list
  yt set //home/user/list/end value
  
  % Вставить элемент "value" в начало списка //home/user/list
  yt set //home/user/list/before:0 value
  % Или
  yt set //home/user/list/begin value
  
  % Вставить элемент "value" перед вторым элементом списка //home/user/list
  yt set //home/user/list/before:2 value
  
  % Вставить элемент "value" после пятого элемента списка //home/user/list
  yt set //home/user/list/after:5 value
  ```

- **Отключение перенаправления**: токен `&` может использоваться для подавления перенаправления по [символической ссылке](../../../user-guide/storage/links.md).
  Примеры:

  ```json
  % Узнать идентификатор самого объекта-ссылки, а не объекта, на который ссылка указывает
  yt get //home/user/link&/@id
  ```

## Сложный YPath { #rich_ypath }

**Сложный** (**rich**) YPath представляет собой расширенный YPath, имеющий вид строки с дополнительными аннотациями. Эти аннотации могут быть заданы двумя способами: в виде **атрибутов** (пар вида ключ-значение), а также **синтаксически** с помощью добавления специальных префиксов и суффиксов к простому YPath, из-за чего он превращается в строку вида `<prefix><simple-ypath><suffix>`.

При отсутствии префикса `<prefix>` и суффикса `<suffix>` сложный YPath может иметь, например, такой вид:

```json
<
  append = %true;
  compression_codec = lz4;
>
//home/user/table
```

Данный путь указывает на домашний каталог пользователя и несет в себе два атрибута.

На любом пути можно указать произвольный набор атрибутов. Точный их смысл зависит от того, как данный путь используется в системе. Например, при записи в таблицу имеет смысл атрибут `append`, позволяющий дописывать в конец, а не перезаписать результат. Для входных таблиц некоторых mapreduce-операций можно указать флаг `foreign`, означающий, что данная таблица является вторичной (таблицей-справочником), поэтому системе необходимо выполнять join специального вида.

Атрибуты, имена которых системе неизвестны, или которые не имеют смысла в заданном контексте, системой игнорируются.

Префикс и суффикс пути позволяют закодировать атрибуты в более компактном виде. Обе эти части используют лексику [YSON](../../../user-guide/storage/yson.md). Подробнее об их устройстве:

### Префикс { #rich_ypath_prefix }

Часть `<prefix>` либо пуста, либо задает атрибуты в виде map-fragment в формате [YSON](../../../user-guide/storage/yson.md).
Пример: `<append=%true>//home/user/table` задает путь к таблице в домашнем каталоге пользователя, а также сообщает нам дополнительный атрибут `append`.

Основное предназначение префикса — упростить передачу атрибутов при использовании команд из консоли.

### Суффикс { #rich_ypath_suffix }

Часть `<suffix>` либо пуста, либо указывает колонки и/или диапазоны строк обрабатываемой таблицы.

Сначала всегда указываются модификатор выбора колонок, если он есть, а затем модификатор выбора строк, если он есть.

**Модификатор выбора колонок** представляет собой разделенный запятыми и взятый в фигурные скобки набор имен колонок. Каждое имя представлено YSON-строкой.

Примеры модификаторов выбора колонок: `{a}`, `{a,b}`, `{}` .

Формальная грамматика модификаторов выбора колонок:

```json
<column-selector> = '{' { <column-selector-item> ',' } [ <column-selector-item> ] '}'
<column-selector-item> = <string>
```

**Модификатор выбора строк** представляет собой разделенный запятыми и взятый в квадратные скобки набор диапазонов строк таблицы. Каждый диапазон — пара из нижней и верхней границы диапазона, разделенных двоеточием, либо точное значение границы, которую нужно прочитать. В случае пары одна или обе границы могут отсутствовать. 
Граница может быть либо числом с приписанным слева символом `#` — тогда это номер строки в таблице, либо списком значений — тогда это граница по значениям ключевых колонок, по которым таблица отсортирована. Указанный список может быть короче, чем количество полей, по котором отсортирована таблица, тогда рассматриваются только соответствующие колонки, являющиеся префиксом ключа. Запрос с указанием средней части композитного ключа невозможен. В случае, если список состоит из одного элемента, его можно не обрамлять в круглые скобки. Элемент должен быть корректным YSON-значением скалярного типа  `int64`, `uint64`, `string`, `double`, `bool`).

{% note info "Примечание" %}

Обратите внимание, что с точки зрения системы `int64` и `uint64` — это разные типы, сравнение значений между которыми не имеет смысла. Если в таблице находятся данные типа `uint64`, при выборе строк также нужно указывать беззнаковые лимиты в помощью суффикса `u`.

{% endnote %}

Примеры модификаторов выбора строк: `[:]`, `[#10:#100]`, `[a:m]`, `[(abc,8):(xyz,5)]`, `[:5.0,10.0:]`, `[#10]`, `[a,#100,#1:#2]`, `[100u:200u]`. В последнем случае данные содержат беззнаковые числа.

Формальная грамматика модификаторов выбора строк:

```json
<row-selector> = '[' { <row-range> ',' } <row-range> ] ']'

<row-range> = <row-index-range-selector> | <row-key-range-selector> | <row-index> | <row-composite-key> | ''

<row-index-range-selector> = [ <row-index> ] ':' [ <row-index> ]

<row-index> = '#' <int64>

<row-key-range-selector> = [ <row-composite-key> ] ':' [ <row-composite-key> ]

<row-composite-key> = <row-key> | <row-key-tuple>

<row-key-tuple> = '(' { <row-key> ',' } [ <row-key> ] ')'
                                         
<row-key> = <string> | <int64> | <uint64> | <bool> | <double>
```

{% note info "Примечание" %}

Сравнение композитных ключей производится лексикографически. Сначала сравнивается первая координата, при её совпадении сравнивается вторая координата, и т.д. Если ключ A является префиксом (по координатам) ключа B, то A <= B. Внутри каждого типа значения сравниваются естественным образом. Сравнение значений разных типов зависит только от типов, но не от значений. Порядок типов не специфицирован ( `0 < 1`, `0.0 < 1.0`, но нельзя полагаться на `0.0 < 1`).

{% endnote %}

### Примеры  { #rich_ypath_examples }

{% note info "Примечание" %}

Сложные пути стоит брать в одинарные кавычки для надлежащего парсинга bash-ем. Ниже эти кавычки опущены для более лаконичного вида примеров.

{% endnote %}

```json
% Прочитать целиком таблицу '//home/user/table'
yt read //home/user/table

% Прочитать все строки таблицы '//home/user/table', но не выбрать ни одной колонки
yt read //home/user/table{}

% Прочитать колонку 'a'
yt read //home/user/table{a}

% Прочитать колонки 'a', 'b'
yt read //home/user/table{a,b}

% Прочитать первые 100 строк таблицы '//home/user/table' (и выбрать все колонки)
yt read //home/user/table[#0:#100]

% Прочитать все строки, пропустив первые 100
yt read //home/user/table[#100:]

% Прочитать строку с номером 100 (считая с 0)
yt read //home/user/table[#100]

% Прочитать строки с ключом (или первой координатой ключа) 'abc'
yt read //home/user/table["abc":"abc\x00"]

% Запрос выше можно также выразить короче:
yt read //home/user/table["abc"]

% Прочитать строки с ключами, не меньшими '(a,1)'
yt read //home/user/table[(a,1):]

% Прочитать строки у которых первые две компоненты ключа равны 'a' и '1' соответственно
yt read //home/user/table[(a,1)]

% Прочитать строки, у которых первый ключ 'a', второй ключ начинается с 'b', и, если второй ключ равен 'b', то третий ключ не меньше '1'.
yt read //home/user/table[(a,b,1):(a,c)]

% Прочитать строки, у которых первый ключ начинается с 'a', а также строки, у которых первый ключ 'b', а второй - меньше '1'.
yt read //home/user/table[a:(b,1)]

% Прочитать строки, у которых первый ключ начинается с 'a', а также строки, у которых первый ключ 'b', а второй - меньше '1', а также строки, у которых первый ключ 'b', второй ключ - '1', а третий - отрицательный типа double. Выбрать колонки 'ab', 'ac'
yt read //home/user/table{ab,ac}[a:(b,1,0.0)]

% Преобразовать table1 со столбцами a,b,c,d в table2 со столбцами a,b,c и сортировкой по полям a,b
yt sort --src "//home/users/table1{a,b,c}" --dst //home/users/table2 --sort-by "a" --sort-by "b" --spec '{schema_inference_mode = from_output}'

% Преобразовать table1 со столбцами a,b,c,d в table2 со столбцами a,b,c
yt merge --src "//home/users/table1{a,b,c}" --dst //home/users/table2 --spec '{schema_inference_mode = from_output}'
```

## Каноническая форма YPath { #ypath_canonical_form }

[Сложный YPath](#rich_ypath) может быть приведен к **канонической форме**, в которой отсутствуют префикс и суффикс, вся информация из которых явно вынесена в атрибуты, назначенные строке — [простому YPath](#simple_ypath).

Пример: после канонизации пути `<append=true>//home/user/table[#10:#20]` получается следующая YSON-структура:

```json
<
  append = true;
  ranges = [
    {
      lower_limit = {row_index = 10};
      upper_limit = {row_index = 20}
    }
  ]
>
"//home/user/table"
```

Внутри система {{product-name}} предпочитает работать с канонической формой путей. Эта форма более громоздка, поэтому во всех путях, принимаемых системой на вход, разрешается использовать более удобную форму с префиксом и суффиксом:

```
<append=true>//home/user/table[#10:#20]
```
Префикс — `<append=true>`;

Суффикс — `[#10:#20]`.

Внутри системы это будет развернуто в широкую запись:

```
  ranges = [
    {
      lower_limit = {row_index = 10};
      upper_limit = {row_index = 20}
    }
  ]
```

Существует [команда](../../../api/commands.md#parse_ypath) `parse_ypath` драйвера, позволяющая канонизировать сложный YPath. 

## Поддерживаемые атрибуты { #known_attributes }

[Сложный YPath](#rich_ypath) может быть проаннотирован произвольными атрибутами, что дает возможность расширения. В таблице представлен список атрибутов, которые поддерживает система.

| **Атрибут**         | **Тип**                       | **Описание**                                                 |
| ------------------- | ----------------------------- | ------------------------------------------------------------ |
| `append`            | `bool`                        | Распознается командами записи данных (`write_table` и `write_file`) и означает, что новые данные дописываются в конец существующих, а не перезаписывают их. Также распознается на выходных путях таблиц в спецификациях всех операций планировщика и имеет аналогичную семантику. |
| `sorted_by`         | `array<string>`               | Распознается командой записи табличных данных ( `write_table`). При указании этого атрибута пользователь обещает, что записываемые данные упорядочены по указанному набору колонок. Система проверяет это свойство. Ключи должны идти в порядке неубывания, а в случае записи с добавлением проверяется также, что первый записываемый ключ не меньше последнего уже существующего. Атрибут также распознается системой на выходных путях таблиц в спецификациях всех операций планировщика и имеет там аналогичную семантику. В последнем случае также дополнительно требуется, чтобы диапазоны ключей, порождаемые различными джобами, не имели пересечения по внутренней точке, пересечения по границам разрешаются. |
| `ranges`            | `array<ReadRange>`            | Распознается командами чтения данных (`read_table` и `read_file`) и задает список читаемых диапазонов. Если отсутствует, читаются данные целиком. Также распознается на входных путях таблиц в спецификациях всех операций планировщика. Описание структуры словаря `ReadRange` представлено в таблице ниже.|
| `columns`           | `array<string>`               | Распознается командой чтения табличных данных ( `read_table` ) и задает список имен читаемых колонок. Если отсутствует, то читаются все колонки. Также распознается на входных путях таблиц в спецификациях всех операций планировщика. |
| `optimize_for`      | `string`                      | Устанавливает формат хранения для создаваемой таблицы. Атрибут можно указывать c командой `write_table` и на выходных путях операций. Данный атрибут **не совместим** с `<append=true>`. |
| `compression_codec` | `string`                      | Устанавливает формат сжатия для создаваемой таблицы. Атрибут можно указывать с командами `write_file` , `write_table` и на выходных путях операций. Данный атрибут **несовместим** с `<append=true>`. |
| `erasure_codec`     | `string`                      | Выключает erasure-кодирование для создаваемой таблицы. Атрибут можно указывать с командами `write_file` , `write_table` и на выходных путях операций. Данный атрибут **несовместим** с `<append=true>`. |
| `schema`            | `yson-list` с валидной схемой | Валидирует данные относительно указанной схемы и проставляет данную схему на таблицу по окончании операции. Атрибут можно указывать с командой `write_table` и на выходных путях операций. Данный атрибут **несовместим** с `<append=true>`. |
| `transaction_id`    | `string` вида id              | Указание планировщику, под какой транзакцией необходимо обращаться к входной таблице, если на ней указан данный атрибут. |
| `rename_columns`    | `yson-map`                    | Распознается на входящих путях таблиц. Переименовывает названия колонок согласно маппингу перед подачей таблицы на вход операции. Данный атрибут **несовместим** с `teleport` таблицами. |

Атрибут `ranges` указывает, какие диапазоны строк таблицы следует прочитать. Указанные диапазоны будут читаться последовательно, в том порядке, в котором они указаны в атрибутах команды. В частности, если диапазоны пересекаются, то на выходе строки будут повторены соответствующее число раз.

| **Атрибут**   | **Тип**     | **Описание**                                                 |
| ------------- | ----------- | ------------------------------------------------------------ |
| `lower_limit` | `ReadLimit` | Нижняя граница чтения (включительно)                         |
| `upper_limit` | `ReadLimit` | Верхняя граница чтения (не включительно)                     |
| `exact`       | `ReadLimit` | Точное значение границы чтения (не может быть указано вместе с lower_limit или upper_limit) |

`ReadLimit` описывает отдельную границу чтения. Граница может определяться ключом. Это верно только для сортированных таблиц. При этом его длина не обязательно должна быть равна количеству ключевых колонок в таблице, вместо этого будет происходить лексикографическое сравнение последовательностей. Граница также может определяться номером строки (только для таблиц и журналов), номером чанка или байтовым смещением (только для файлов). В границе может быть указано произвольное количество параметров. При этом они все действуют одновременно, усиливая друг друга, то есть уменьшая диапазон выбираемых значений.

| **Атрибут** | **Тип** | **Описание**                                         |
| ----------- | ------- | ---------------------------------------------------- |
| `key`       | `list`  | Список значений, образующих ключ (только для таблиц) |
| `row_index` | `int`   | Номер строки (только для таблиц)                     |
| `offset`    | `int`   | Байтовое смещение (только для файлов)                |

Поддерживаемые системой {{product-name}} YPath атрибуты на путях **файлов**

| **Атрибут**             | **Тип**                       | **Описание**                                                 |
| ----------------------- | ----------------------------- | ------------------------------------------------------------ |
| `file_name`             | `string`                      | Распознается при заказе файла в `sandbox` джоба. Атрибут задает относительный путь, по которому надо положить файл. |
| `executable`            | `bool`                        | Распознается при заказе файла в `sandbox` джоба. Атрибут указывает системе необходимость проставить executable-бит на заказанный файл. |
| `bypass_artifact_cache` | `bool`                        | Распознается при заказе файла в `sandbox` джоба. Атрибут включает прямое скачивание файла в `sandbox` джоба минуя файловый кэш на ноде. |
| `format`                | `string`                      | Распознается при заказе табличного файла в `sandbox` джоба. Атрибут обозначает формат, в котором надо сформатировать таблицу при её скачивании в `sandbox` джоба. |
